<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>JsonAdapters.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">IU Java Utilities API Reference</a> &gt; <a href="../index.html" class="el_bundle">iu-java-client</a> &gt; <a href="index.source.html" class="el_package">iu.client</a> &gt; <span class="el_source">JsonAdapters.java</span></div><h1>JsonAdapters.java</h1><pre class="source lang-java linenums">/*
 * Copyright Â© 2024 Indiana University
 * All rights reserved.
 *
 * BSD 3-Clause License
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 
 * - Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 * 
 * - Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 * 
 * - Neither the name of the copyright holder nor the names of its
 *   contributors may be used to endorse or promote products derived from
 *   this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package iu.client;

import java.lang.reflect.Array;
import java.lang.reflect.GenericArrayType;
import java.lang.reflect.ParameterizedType;
import java.lang.reflect.Type;
import java.lang.reflect.TypeVariable;
import java.lang.reflect.WildcardType;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.net.URI;
import java.net.URL;
import java.time.Duration;
import java.time.Instant;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.LocalTime;
import java.time.OffsetDateTime;
import java.time.OffsetTime;
import java.time.Period;
import java.time.ZoneId;
import java.time.ZoneOffset;
import java.time.ZonedDateTime;
import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Collection;
import java.util.Date;
import java.util.Deque;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.NavigableMap;
import java.util.NavigableSet;
import java.util.Optional;
import java.util.Properties;
import java.util.Queue;
import java.util.Set;
import java.util.SimpleTimeZone;
import java.util.SortedMap;
import java.util.SortedSet;
import java.util.TimeZone;
import java.util.TreeMap;
import java.util.TreeSet;
import java.util.WeakHashMap;
import java.util.function.Function;
import java.util.function.IntFunction;
import java.util.regex.Pattern;
import java.util.stream.Stream;

import edu.iu.IuException;
import edu.iu.client.IuJsonAdapter;

/**
 * Provides standard {@link IuJsonAdapter} instances.
 */
public final class JsonAdapters {

<span class="fc" id="L95">	private static final Map&lt;Class&lt;?&gt;, Class&lt;?&gt;&gt; ARRAY_TYPES = new WeakHashMap&lt;&gt;();</span>

	/**
	 * {@link IuJsonAdapter} factory method.
	 * 
	 * @param type         Java type
	 * @param valueAdapter value type adapter
	 * @return {@link JsonAdapter}
	 */
	@SuppressWarnings({ &quot;unchecked&quot;, &quot;rawtypes&quot; })
	public static IuJsonAdapter adapt(Type type, Function&lt;Class&lt;?&gt;, IuJsonAdapter&lt;?&gt;&gt; valueAdapter) {
<span class="fc" id="L106">		Class erased = erase(type);</span>

<span class="fc bfc" id="L108" title="All 2 branches covered.">		if (erased == Object.class)</span>
<span class="fc" id="L109">			return BasicJsonAdapter.INSTANCE;</span>

<span class="fc bfc" id="L111" title="All 2 branches covered.">		if (erased == Boolean.class)</span>
<span class="fc" id="L112">			return BooleanJsonAdapter.INSTANCE;</span>
<span class="fc bfc" id="L113" title="All 2 branches covered.">		if (erased == boolean.class)</span>
<span class="fc" id="L114">			return BooleanJsonAdapter.PRIMITIVE;</span>

<span class="fc bfc" id="L116" title="All 4 branches covered.">		if (erased == BigDecimal.class //</span>
				|| erased == Number.class)
<span class="fc" id="L118">			return NumberAdapter.BIG_DECIMAL;</span>
<span class="fc bfc" id="L119" title="All 2 branches covered.">		if (erased == BigInteger.class)</span>
<span class="fc" id="L120">			return NumberAdapter.BIG_INTEGER;</span>
<span class="fc bfc" id="L121" title="All 2 branches covered.">		if (erased == Byte.class)</span>
<span class="fc" id="L122">			return NumberAdapter.BYTE;</span>
<span class="fc bfc" id="L123" title="All 2 branches covered.">		if (erased == byte.class)</span>
<span class="fc" id="L124">			return NumberAdapter.BYTE_PRIMITIVE;</span>
<span class="fc bfc" id="L125" title="All 2 branches covered.">		if (erased == Double.class)</span>
<span class="fc" id="L126">			return NumberAdapter.DOUBLE;</span>
<span class="fc bfc" id="L127" title="All 2 branches covered.">		if (erased == double.class)</span>
<span class="fc" id="L128">			return NumberAdapter.DOUBLE_PRIMITIVE;</span>
<span class="fc bfc" id="L129" title="All 2 branches covered.">		if (erased == Float.class)</span>
<span class="fc" id="L130">			return NumberAdapter.FLOAT;</span>
<span class="fc bfc" id="L131" title="All 2 branches covered.">		if (erased == float.class)</span>
<span class="fc" id="L132">			return NumberAdapter.FLOAT_PRIMITIVE;</span>
<span class="fc bfc" id="L133" title="All 2 branches covered.">		if (erased == Long.class)</span>
<span class="fc" id="L134">			return NumberAdapter.LONG;</span>
<span class="fc bfc" id="L135" title="All 2 branches covered.">		if (erased == long.class)</span>
<span class="fc" id="L136">			return NumberAdapter.LONG_PRIMITIVE;</span>
<span class="fc bfc" id="L137" title="All 2 branches covered.">		if (erased == Integer.class)</span>
<span class="fc" id="L138">			return NumberAdapter.INT;</span>
<span class="fc bfc" id="L139" title="All 2 branches covered.">		if (erased == int.class)</span>
<span class="fc" id="L140">			return NumberAdapter.INT_PRIMITIVE;</span>
<span class="fc bfc" id="L141" title="All 2 branches covered.">		if (erased == Short.class)</span>
<span class="fc" id="L142">			return NumberAdapter.SHORT;</span>
<span class="fc bfc" id="L143" title="All 2 branches covered.">		if (erased == short.class)</span>
<span class="fc" id="L144">			return NumberAdapter.SHORT_PRIMITIVE;</span>

<span class="fc bfc" id="L146" title="All 4 branches covered.">		if (erased == CharSequence.class //</span>
				|| erased == String.class)
<span class="fc" id="L148">			return TextJsonAdapter.INSTANCE;</span>

<span class="fc bfc" id="L150" title="All 2 branches covered.">		if (erased == byte[].class)</span>
<span class="fc" id="L151">			return BinaryJsonAdapter.INSTANCE;</span>

<span class="fc bfc" id="L153" title="All 2 branches covered.">		if (erased == Calendar.class)</span>
<span class="fc" id="L154">			return CalendarJsonAdapter.INSTANCE;</span>
<span class="fc bfc" id="L155" title="All 2 branches covered.">		if (erased == Date.class)</span>
<span class="fc" id="L156">			return DateJsonAdapter.INSTANCE;</span>
<span class="fc bfc" id="L157" title="All 2 branches covered.">		if (erased == Duration.class)</span>
<span class="fc" id="L158">			return ParsingJsonAdapter.of(Duration.class, Duration::parse);</span>
<span class="fc bfc" id="L159" title="All 2 branches covered.">		if (erased == Instant.class)</span>
<span class="fc" id="L160">			return ParsingJsonAdapter.of(Instant.class, Instant::parse);</span>
<span class="fc bfc" id="L161" title="All 2 branches covered.">		if (erased == LocalDate.class)</span>
<span class="fc" id="L162">			return ParsingJsonAdapter.of(LocalDate.class, LocalDate::parse);</span>
<span class="fc bfc" id="L163" title="All 2 branches covered.">		if (erased == LocalTime.class)</span>
<span class="fc" id="L164">			return ParsingJsonAdapter.of(LocalTime.class, LocalTime::parse);</span>
<span class="fc bfc" id="L165" title="All 2 branches covered.">		if (erased == LocalDateTime.class)</span>
<span class="fc" id="L166">			return ParsingJsonAdapter.of(LocalDateTime.class, LocalDateTime::parse);</span>
<span class="fc bfc" id="L167" title="All 2 branches covered.">		if (erased == OffsetDateTime.class)</span>
<span class="fc" id="L168">			return ParsingJsonAdapter.of(OffsetDateTime.class, OffsetDateTime::parse);</span>
<span class="fc bfc" id="L169" title="All 2 branches covered.">		if (erased == OffsetTime.class)</span>
<span class="fc" id="L170">			return ParsingJsonAdapter.of(OffsetTime.class, OffsetTime::parse);</span>
<span class="fc bfc" id="L171" title="All 2 branches covered.">		if (erased == Pattern.class)</span>
<span class="fc" id="L172">			return ParsingJsonAdapter.of(Pattern.class, Pattern::compile);</span>
<span class="fc bfc" id="L173" title="All 2 branches covered.">		if (erased == Period.class)</span>
<span class="fc" id="L174">			return ParsingJsonAdapter.of(Period.class, Period::parse);</span>
<span class="fc bfc" id="L175" title="All 2 branches covered.">		if (erased == SimpleTimeZone.class)</span>
<span class="fc" id="L176">			return TimeZoneJsonAdapter.INSTANCE;</span>
<span class="fc bfc" id="L177" title="All 2 branches covered.">		if (erased == TimeZone.class)</span>
<span class="fc" id="L178">			return TimeZoneJsonAdapter.INSTANCE;</span>
<span class="fc bfc" id="L179" title="All 2 branches covered.">		if (erased == ZonedDateTime.class)</span>
<span class="fc" id="L180">			return ParsingJsonAdapter.of(ZonedDateTime.class, ZonedDateTime::parse);</span>
<span class="fc bfc" id="L181" title="All 2 branches covered.">		if (erased == ZoneId.class)</span>
<span class="fc" id="L182">			return ParsingJsonAdapter.of(ZoneId.class, ZoneId::of);</span>
<span class="fc bfc" id="L183" title="All 2 branches covered.">		if (erased == ZoneOffset.class)</span>
<span class="fc" id="L184">			return ParsingJsonAdapter.of(ZoneOffset.class, ZoneOffset::of);</span>
<span class="fc bfc" id="L185" title="All 2 branches covered.">		if (erased == URI.class)</span>
<span class="fc" id="L186">			return ParsingJsonAdapter.of(URI.class, URI::create);</span>
<span class="fc bfc" id="L187" title="All 2 branches covered.">		if (erased == URL.class)</span>
<span class="fc" id="L188">			return ParsingJsonAdapter.of(URL.class, a -&gt; IuException.unchecked(() -&gt; new URL(a)));</span>

<span class="fc bfc" id="L190" title="All 2 branches covered.">		if (erased.isEnum())</span>
<span class="fc" id="L191">			return ParsingJsonAdapter.of(erased, v -&gt; Enum.valueOf(erased, v));</span>

<span class="fc bfc" id="L193" title="All 2 branches covered.">		if (erased == Optional.class)</span>
<span class="fc bfc" id="L194" title="All 2 branches covered.">			if (valueAdapter != null)</span>
<span class="fc" id="L195">				return new OptionalJsonAdapter(valueAdapter.apply(item(type)));</span>
<span class="fc bfc" id="L196" title="All 2 branches covered.">			else if (type instanceof ParameterizedType)</span>
<span class="fc" id="L197">				return new OptionalJsonAdapter(IuJsonAdapter.of(item(type)));</span>
			else
<span class="fc" id="L199">				return OptionalJsonAdapter.INSTANCE;</span>

<span class="fc bfc" id="L201" title="All 2 branches covered.">		if (erased.isArray()) {</span>
<span class="fc" id="L202">			final var item = item(type);</span>
<span class="fc" id="L203">			final IntFunction factory = n -&gt; Array.newInstance(item, n);</span>
			final IuJsonAdapter itemAdapter;
<span class="fc bfc" id="L205" title="All 2 branches covered.">			if (valueAdapter != null)</span>
<span class="fc" id="L206">				itemAdapter = valueAdapter.apply(item);</span>
			else
<span class="fc" id="L208">				itemAdapter = IuJsonAdapter.of(item);</span>

<span class="fc" id="L210">			return new ArrayAdapter(itemAdapter, factory);</span>
		}

<span class="fc bfc" id="L213" title="All 8 branches covered.">		if (Iterable.class.isAssignableFrom(erased) //</span>
				|| erased == Enumeration.class //
				|| erased == Iterator.class //
				|| erased == Stream.class) {
			final IuJsonAdapter itemAdapter;
<span class="fc bfc" id="L218" title="All 2 branches covered.">			if (valueAdapter != null)</span>
<span class="fc" id="L219">				itemAdapter = valueAdapter.apply(item(type));</span>
<span class="fc bfc" id="L220" title="All 2 branches covered.">			else if (type instanceof ParameterizedType)</span>
<span class="fc" id="L221">				itemAdapter = IuJsonAdapter.of(item(type));</span>
			else
<span class="fc" id="L223">				itemAdapter = BasicJsonAdapter.INSTANCE;</span>

<span class="fc bfc" id="L225" title="All 2 branches covered.">			if (erased == Iterable.class)</span>
<span class="fc" id="L226">				return new IterableAdapter(itemAdapter);</span>

<span class="fc bfc" id="L228" title="All 8 branches covered.">			if (erased == Collection.class //</span>
					|| erased == Queue.class //
					|| erased == Deque.class //
					|| erased == ArrayDeque.class)
<span class="fc" id="L232">				return new CollectionAdapter(itemAdapter, ArrayDeque::new);</span>

<span class="fc bfc" id="L234" title="All 4 branches covered.">			if (erased == List.class //</span>
					|| erased == ArrayList.class)
<span class="fc" id="L236">				return new CollectionAdapter(itemAdapter, ArrayList::new);</span>

<span class="fc bfc" id="L238" title="All 4 branches covered.">			if (erased == Set.class //</span>
					|| erased == LinkedHashSet.class)
<span class="fc" id="L240">				return new CollectionAdapter(itemAdapter, LinkedHashSet::new);</span>

<span class="fc bfc" id="L242" title="All 6 branches covered.">			if (erased == SortedSet.class //</span>
					|| erased == NavigableSet.class //
					|| erased == TreeSet.class)
<span class="fc" id="L245">				return new CollectionAdapter(itemAdapter, TreeSet::new);</span>

<span class="fc bfc" id="L247" title="All 2 branches covered.">			if (erased == HashSet.class)</span>
<span class="fc" id="L248">				return new CollectionAdapter(itemAdapter, HashSet::new);</span>

<span class="fc bfc" id="L250" title="All 2 branches covered.">			if (erased == Enumeration.class)</span>
<span class="fc" id="L251">				return new EnumerationAdapter(itemAdapter);</span>
<span class="fc bfc" id="L252" title="All 2 branches covered.">			if (erased == Iterator.class)</span>
<span class="fc" id="L253">				return new IteratorAdapter(itemAdapter);</span>
<span class="fc bfc" id="L254" title="All 2 branches covered.">			if (erased == Stream.class)</span>
<span class="fc" id="L255">				return new StreamAdapter(itemAdapter);</span>
		}

<span class="fc bfc" id="L258" title="All 2 branches covered.">		if (Map.class.isAssignableFrom(erased)) {</span>
<span class="fc bfc" id="L259" title="All 2 branches covered.">			if (valueAdapter == null)</span>
<span class="fc bfc" id="L260" title="All 2 branches covered.">				if (type instanceof ParameterizedType)</span>
<span class="fc" id="L261">					valueAdapter = IuJsonAdapter::of;</span>
				else
<span class="fc" id="L263">					valueAdapter = a -&gt; BasicJsonAdapter.INSTANCE;</span>
			final IuJsonAdapter keyAdapter ;	
<span class="fc bfc" id="L265" title="All 2 branches covered.">			if (type instanceof ParameterizedType)	</span>
<span class="fc" id="L266">					keyAdapter = valueAdapter.apply(erase(((ParameterizedType) type).getActualTypeArguments()[0]));</span>
			else 
<span class="fc" id="L268">				    keyAdapter = BasicJsonAdapter.INSTANCE;</span>
					
<span class="fc bfc" id="L270" title="All 4 branches covered.">			if (erased == Map.class //</span>
					|| erased == LinkedHashMap.class)
<span class="fc" id="L272">				return new JsonObjectAdapter(keyAdapter, valueAdapter.apply(item(type)), LinkedHashMap::new);</span>

<span class="fc bfc" id="L274" title="All 2 branches covered.">			if (erased == HashMap.class)</span>
<span class="fc" id="L275">				return new JsonObjectAdapter(keyAdapter, valueAdapter.apply(item(type)), HashMap::new);</span>

<span class="fc bfc" id="L277" title="All 6 branches covered.">			if (erased == SortedMap.class //</span>
					|| erased == NavigableMap.class //
					|| erased == TreeMap.class)
<span class="fc" id="L280">				return new JsonObjectAdapter(keyAdapter, valueAdapter.apply(item(type)), TreeMap::new);</span>

<span class="fc bfc" id="L282" title="All 2 branches covered.">			if (erased == Properties.class)</span>
<span class="fc" id="L283">				return new JsonObjectAdapter(keyAdapter, valueAdapter.apply(item(type)), Properties::new);</span>
		}

<span class="fc" id="L286">		throw new UnsupportedOperationException(&quot;Unsupported for JSON conversion: &quot; + type);</span>
	}

	private static Class&lt;?&gt; erase(Type type) {
<span class="fc bfc" id="L290" title="All 2 branches covered.">		if (type instanceof Class)</span>
<span class="fc" id="L291">			return (Class&lt;?&gt;) type;</span>
<span class="fc bfc" id="L292" title="All 2 branches covered.">		else if (type instanceof GenericArrayType) {</span>
<span class="fc" id="L293">			final var component = erase(((GenericArrayType) type).getGenericComponentType());</span>
<span class="fc" id="L294">			var array = ARRAY_TYPES.get(component);</span>
<span class="fc bfc" id="L295" title="All 2 branches covered.">			if (array == null) {</span>
<span class="fc" id="L296">				array = Array.newInstance(component, 0).getClass();</span>
<span class="fc" id="L297">				synchronized (ARRAY_TYPES) {</span>
<span class="fc" id="L298">					ARRAY_TYPES.put(component, array);</span>
<span class="fc" id="L299">				}</span>
			}
<span class="fc" id="L301">			return array;</span>
<span class="fc bfc" id="L302" title="All 2 branches covered.">		} else if (type instanceof ParameterizedType)</span>
<span class="fc" id="L303">			return erase(((ParameterizedType) type).getRawType());</span>
<span class="fc bfc" id="L304" title="All 2 branches covered.">		else if (type instanceof TypeVariable)</span>
<span class="fc" id="L305">			return erase(((TypeVariable&lt;?&gt;) type).getBounds()[0]);</span>
		else // if (type instanceof WildcardType)
<span class="fc" id="L307">			return erase(((WildcardType) type).getUpperBounds()[0]);</span>
	}

	private static Class&lt;?&gt; item(Type type) {
<span class="fc bfc" id="L311" title="All 2 branches covered.">		if (type instanceof Class) {</span>
<span class="fc" id="L312">			return ((Class&lt;?&gt;) type).getComponentType();</span>
<span class="fc bfc" id="L313" title="All 2 branches covered.">		} else if (type instanceof GenericArrayType)</span>
<span class="fc" id="L314">			return erase(((GenericArrayType) type).getGenericComponentType());</span>
		else {
			// assumes erase() was invoked and returned a supported type first
<span class="fc" id="L317">			final var p = (ParameterizedType) type;</span>
<span class="fc" id="L318">			final var raw = erase(p);</span>
<span class="fc bfc" id="L319" title="All 2 branches covered.">			if (Map.class.isAssignableFrom(raw))</span>
<span class="fc" id="L320">				return erase(p.getActualTypeArguments()[1]);</span>
			else
<span class="fc" id="L322">				return erase(p.getActualTypeArguments()[0]);</span>
		}
	}

	private JsonAdapters() {
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.10.202304240956</span></div></body></html>