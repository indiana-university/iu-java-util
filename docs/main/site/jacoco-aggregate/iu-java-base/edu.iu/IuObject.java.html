<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>IuObject.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">IU Java Utilities API Reference</a> &gt; <a href="../index.html" class="el_bundle">iu-java-base</a> &gt; <a href="index.source.html" class="el_package">edu.iu</a> &gt; <span class="el_source">IuObject.java</span></div><h1>IuObject.java</h1><pre class="source lang-java linenums">/*
 * Copyright Â© 2024 Indiana University
 * All rights reserved.
 *
 * BSD 3-Clause License
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 
 * - Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 * 
 * - Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 * 
 * - Neither the name of the copyright holder nor the names of its
 *   contributors may be used to endorse or promote products derived from
 *   this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package edu.iu;

import java.lang.reflect.Array;
import java.time.Duration;
import java.time.Instant;
import java.util.Arrays;
import java.util.Comparator;
import java.util.Iterator;
import java.util.Map;
import java.util.Set;
import java.util.SortedSet;
import java.util.concurrent.TimeoutException;
import java.util.function.BooleanSupplier;
import java.util.function.Supplier;

/**
 * Simplifies building efficient {@link Object#equals(Object)},
 * {@link Object#hashCode()}, and {@link Comparable#compareTo(Object)} methods
 * on plain Java objects.
 * 
 * &lt;p&gt;
 * The use of this utility is preferred, following the examples below, over
 * other methods of generating these methods. When following these examples, the
 * implements can be expected to follow the expected contracts in a null-safe
 * and type-safe manner without undue object creation.
 * &lt;/p&gt;
 * 
 * &lt;dl&gt;
 * &lt;dt&gt;Top level object:&lt;/dt&gt;
 * &lt;dd&gt;
 * 
 * &lt;pre&gt;
 * &amp;#064;Override
 * public int hashCode() {
 * 	return ObjectUtil.hashCode(val1, val2);
 * }
 * 
 * &amp;#064;Override
 * public boolean equals(Object obj) {
 * 	if (!ObjectUtil.typeCheck(this, obj))
 * 		return false;
 * 	MyClass other = (MyClass) obj;
 * 	return ObjectUtil.equals(this.val1, other.val1) &amp;amp;&amp;amp; ObjectUtil.equals(this.val2, other.val2);
 * }
 * 
 * &amp;#064;Override
 * public int compareTo(T o) {
 * 	Integer rv = ObjectUtil.compareNullCheck(this, o);
 * 	if (rv != null)
 * 		return rv;
 * 
 * 	rv = ObjectUtil.compareTo(this.val1, o.val1);
 * 	if (rv != 0)
 * 		return rv;
 * 
 * 	return ObjectUtil.compareTo(this.val2, o.val2);
 * }
 * &lt;/pre&gt;
 * 
 * &lt;/dd&gt;
 * 
 * &lt;dt&gt;Subclass object:&lt;/dt&gt;
 * &lt;dd&gt;
 * 
 * &lt;pre&gt;
 * &amp;#064;Override
 * public int hashCode() {
 * 	return ObjectUtil.hashCodeSuper(super.hashCode(), val1, val2);
 * }
 * 
 * &amp;#064;Override
 * public boolean equals(Object obj) {
 * 	if (!ObjectUtil.typeCheck(this, obj))
 * 		return false;
 * 	MyClass other = (MyClass) obj;
 * 	return super.equals(obj) &amp;amp;&amp;amp; ObjectUtil.equals(this.val1, other.val1) &amp;amp;&amp;amp; ObjectUtil.equals(this.val2, other.val2);
 * }
 * 
 * &amp;#064;Override
 * public int compareTo(T o) {
 * 	Integer rv = ObjectUtil.compareNullCheck(this, o);
 * 	if (rv != null)
 * 		return rv;
 * 
 * 	rv = ObjectUtil.compareTo(this.val1, o.val1);
 * 	if (rv != 0)
 * 		return rv;
 * 
 * 	rv = ObjectUtil.compareTo(this.val2, o.val2);
 * 	if (rv != 0)
 * 		return rv;
 * 
 * 	return super.compareTo(o);
 * }
 * &lt;/pre&gt;
 * 
 * &lt;/dd&gt;
 * &lt;/dl&gt;
 * 
 * @since 4.0
 */
public final class IuObject {

	/**
	 * Perform identity and and null check on two objects, returning a valid value
	 * for {@link Comparable#compareTo(Object)} if any of the checks result in a
	 * conclusive result.
	 * 
	 * @param o1 any object
	 * @param o2 any object
	 * @return 0 if o1 == o2, -1 if o1 is null, 1 if o2 is null; otherwise, return
	 *         null indicating that compareTo should continue to inspect each
	 *         object's specific data.
	 */
	public static Integer compareNullCheck(Object o1, Object o2) {
<span class="fc bfc" id="L147" title="All 2 branches covered.">		if (o1 == o2)</span>
<span class="fc" id="L148">			return 0;</span>
<span class="fc bfc" id="L149" title="All 2 branches covered.">		if (o1 == null)</span>
<span class="fc" id="L150">			return -1;</span>
<span class="fc bfc" id="L151" title="All 2 branches covered.">		if (o2 == null)</span>
<span class="fc" id="L152">			return 1;</span>
<span class="fc" id="L153">		return null;</span>
	}

	/**
	 * Compares two objects with null checks (see
	 * {@link #compareNullCheck(Object, Object)}) and also consistent sort order
	 * based for objects that don't implement {@link Comparable}.
	 * 
	 * @param o1 any object
	 * @param o2 any object
	 * @return Valid {@link Comparator} return value enforcing consistent sort order
	 *         within the same JVM instance.
	 */
	@SuppressWarnings({ &quot;rawtypes&quot;, &quot;unchecked&quot; })
	public static int compareTo(Object o1, Object o2) {
<span class="fc" id="L168">		Integer rv = compareNullCheck(o1, o2);</span>
<span class="fc bfc" id="L169" title="All 2 branches covered.">		if (rv != null)</span>
<span class="fc" id="L170">			return rv;</span>

		Comparable v1;
		Comparable v2;
<span class="fc bfc" id="L174" title="All 4 branches covered.">		if ((o1.getClass() != o2.getClass()) || !(o1 instanceof Comparable)) {</span>
<span class="fc" id="L175">			v1 = (Comparable) Integer.valueOf(o1.hashCode());</span>
<span class="fc" id="L176">			v2 = (Comparable) Integer.valueOf(o2.hashCode());</span>
		} else {
<span class="fc" id="L178">			v1 = (Comparable) o1;</span>
<span class="fc" id="L179">			v2 = (Comparable) o2;</span>
		}

<span class="fc" id="L182">		return v1.compareTo(v2);</span>
	}

	/**
	 * Generates a hash code for a top-level object based on related values (i.e.
	 * field, bean property values, etc).
	 * 
	 * @param oa related values
	 * @return hash code
	 */
	public static int hashCode(Object... oa) {
<span class="fc" id="L193">		return hashCodeSuper(1, oa);</span>
	}

	/**
	 * Generate a hash code for a subclass object based on its parent class' hash
	 * code and related values.
	 * 
	 * @param superHashCode parent class hash code
	 * @param oa            related values
	 * @return hash code
	 */
	public static int hashCodeSuper(int superHashCode, Object... oa) {
<span class="fc" id="L205">		final int prime = 31;</span>
<span class="fc" id="L206">		int result = superHashCode;</span>
<span class="fc bfc" id="L207" title="All 2 branches covered.">		for (Object o : oa) {</span>
			int hash;
<span class="fc bfc" id="L209" title="All 2 branches covered.">			if (o == null)</span>
<span class="fc" id="L210">				hash = 0;</span>
<span class="fc bfc" id="L211" title="All 2 branches covered.">			else if (o instanceof boolean[])</span>
<span class="fc" id="L212">				hash = Arrays.hashCode((boolean[]) o);</span>
<span class="fc bfc" id="L213" title="All 2 branches covered.">			else if (o instanceof byte[])</span>
<span class="fc" id="L214">				hash = Arrays.hashCode((byte[]) o);</span>
<span class="fc bfc" id="L215" title="All 2 branches covered.">			else if (o instanceof char[])</span>
<span class="fc" id="L216">				hash = Arrays.hashCode((char[]) o);</span>
<span class="fc bfc" id="L217" title="All 2 branches covered.">			else if (o instanceof double[])</span>
<span class="fc" id="L218">				hash = Arrays.hashCode((double[]) o);</span>
<span class="fc bfc" id="L219" title="All 2 branches covered.">			else if (o instanceof float[])</span>
<span class="fc" id="L220">				hash = Arrays.hashCode((float[]) o);</span>
<span class="fc bfc" id="L221" title="All 2 branches covered.">			else if (o instanceof int[])</span>
<span class="fc" id="L222">				hash = Arrays.hashCode((int[]) o);</span>
<span class="fc bfc" id="L223" title="All 2 branches covered.">			else if (o instanceof long[])</span>
<span class="fc" id="L224">				hash = Arrays.hashCode((long[]) o);</span>
<span class="fc bfc" id="L225" title="All 2 branches covered.">			else if (o instanceof short[])</span>
<span class="fc" id="L226">				hash = Arrays.hashCode((short[]) o);</span>
<span class="fc bfc" id="L227" title="All 2 branches covered.">			else if (o.getClass().isArray()) {</span>
<span class="fc" id="L228">				int l = Array.getLength(o);</span>
<span class="fc" id="L229">				int h = o.getClass().getComponentType().hashCode();</span>
<span class="fc bfc" id="L230" title="All 2 branches covered.">				for (int i = 0; i &lt; l; i++)</span>
<span class="fc" id="L231">					h = prime * h + hashCode(Array.get(o, i));</span>
<span class="fc" id="L232">				hash = h;</span>
<span class="fc" id="L233">			} else</span>
<span class="fc" id="L234">				hash = o.hashCode();</span>
<span class="fc" id="L235">			result = prime * result + hash;</span>
		}
<span class="fc" id="L237">		return result;</span>
	}

	/**
	 * Determine if two objects are both non-null instances of the same class. This
	 * method is useful as a null and type safety check when implementing equals. If
	 * this returns true, and the type of one of the objects is known, then it is
	 * safe to cast the other object to the same type.
	 * 
	 * @param &lt;T&gt; object type
	 * @param o1  any object
	 * @param o2  any object
	 * @return True if both objects are not null and instances of the same class.
	 */
	public static &lt;T&gt; boolean typeCheck(T o1, T o2) {
<span class="fc" id="L252">		return typeCheck(o1, o2, null);</span>
	}

	/**
	 * Determine if two objects are both instances of a specific class, or
	 * subclasses of that class. This method is useful as a null and type safety
	 * check when implementing equals. If this returns true, then it is safe to cast
	 * the both objects to the type provided.
	 * 
	 * @param &lt;T&gt;  object type
	 * 
	 * @param o1   any object
	 * @param o2   any object
	 * @param type the type to check, may be null for the behavior outlined in
	 *             {@link #typeCheck(Object, Object)}.
	 * @return True if both objects are not null and instances of the given type, or
	 *         are the same class if type is null.
	 */
	public static &lt;T&gt; boolean typeCheck(T o1, T o2, Class&lt;?&gt; type) {
<span class="fc bfc" id="L271" title="All 2 branches covered.">		if (type != null)</span>
<span class="fc bfc" id="L272" title="All 4 branches covered.">			return type.isInstance(o1) &amp;&amp; type.isInstance(o2);</span>
<span class="fc bfc" id="L273" title="All 2 branches covered.">		if (o1 == o2)</span>
<span class="fc" id="L274">			return true;</span>
<span class="fc bfc" id="L275" title="All 4 branches covered.">		if (o1 == null || o2 == null)</span>
<span class="fc" id="L276">			return false;</span>
<span class="fc bfc" id="L277" title="All 2 branches covered.">		return o1.getClass() == o2.getClass();</span>
	}

	/**
	 * Determine if two objects are equal, checking first for identity and null.
	 * 
	 * @param o1 any object
	 * @param o2 any object
	 * @return true if o1 and o2 refer to the same object, are both null, or if
	 *         o1.equals(o2) returns true. Otherwise, return false.
	 */
	public static boolean equals(Object o1, Object o2) {
<span class="fc bfc" id="L289" title="All 2 branches covered.">		if (o1 == o2)</span>
<span class="fc" id="L290">			return true;</span>
<span class="fc bfc" id="L291" title="All 4 branches covered.">		if (o1 == null || o2 == null)</span>
<span class="fc" id="L292">			return false;</span>

<span class="fc bfc" id="L294" title="All 2 branches covered.">		if (o1.getClass() != o2.getClass())</span>
<span class="fc bfc" id="L295" title="All 8 branches covered.">			if (o1 instanceof Set &amp;&amp; o2 instanceof Set &amp;&amp; !(o1 instanceof SortedSet) &amp;&amp; !(o2 instanceof SortedSet)) {</span>
<span class="fc" id="L296">				Set&lt;?&gt; s1 = (Set&lt;?&gt;) o1;</span>
<span class="fc" id="L297">				Set&lt;?&gt; s2 = (Set&lt;?&gt;) o2;</span>
<span class="fc bfc" id="L298" title="All 2 branches covered.">				if (s1.size() != s2.size())</span>
<span class="fc" id="L299">					return false;</span>
<span class="fc" id="L300">				return s1.containsAll(s2);</span>
<span class="fc bfc" id="L301" title="All 4 branches covered.">			} else if (o1 instanceof Iterable &amp;&amp; o2 instanceof Iterable) {</span>
<span class="fc" id="L302">				Iterator&lt;?&gt; i1 = ((Iterable&lt;?&gt;) o1).iterator();</span>
<span class="fc" id="L303">				Iterator&lt;?&gt; i2 = ((Iterable&lt;?&gt;) o2).iterator();</span>
<span class="fc bfc" id="L304" title="All 2 branches covered.">				while (i1.hasNext()) {</span>
<span class="fc bfc" id="L305" title="All 2 branches covered.">					if (!i2.hasNext())</span>
<span class="fc" id="L306">						return false;</span>
<span class="fc bfc" id="L307" title="All 2 branches covered.">					if (!equals(i1.next(), i2.next()))</span>
<span class="fc" id="L308">						return false;</span>
				}
<span class="fc bfc" id="L310" title="All 2 branches covered.">				if (i2.hasNext())</span>
<span class="fc" id="L311">					return false;</span>
<span class="fc" id="L312">				return true;</span>
<span class="fc bfc" id="L313" title="All 4 branches covered.">			} else if ((o1 instanceof Map &amp;&amp; o2 instanceof Map)) {</span>
<span class="fc" id="L314">				Map&lt;?, ?&gt; m1 = (Map&lt;?, ?&gt;) o1;</span>
<span class="fc" id="L315">				Map&lt;?, ?&gt; m2 = (Map&lt;?, ?&gt;) o2;</span>
<span class="fc bfc" id="L316" title="All 2 branches covered.">				if (!equals(m1.keySet(), m2.keySet()))</span>
<span class="fc" id="L317">					return false;</span>
<span class="fc bfc" id="L318" title="All 2 branches covered.">				for (Object k : m1.keySet())</span>
<span class="fc bfc" id="L319" title="All 2 branches covered.">					if (!equals(m1.get(k), m2.get(k)))</span>
<span class="fc" id="L320">						return false;</span>
<span class="fc" id="L321">				return true;</span>
			} else
<span class="fc" id="L323">				return false;</span>

<span class="fc bfc" id="L325" title="All 2 branches covered.">		if (o1 instanceof boolean[])</span>
<span class="fc" id="L326">			return Arrays.equals((boolean[]) o1, (boolean[]) o2);</span>
<span class="fc bfc" id="L327" title="All 2 branches covered.">		if (o1 instanceof byte[])</span>
<span class="fc" id="L328">			return Arrays.equals((byte[]) o1, (byte[]) o2);</span>
<span class="fc bfc" id="L329" title="All 2 branches covered.">		if (o1 instanceof char[])</span>
<span class="fc" id="L330">			return Arrays.equals((char[]) o1, (char[]) o2);</span>
<span class="fc bfc" id="L331" title="All 2 branches covered.">		if (o1 instanceof double[])</span>
<span class="fc" id="L332">			return Arrays.equals((double[]) o1, (double[]) o2);</span>
<span class="fc bfc" id="L333" title="All 2 branches covered.">		if (o1 instanceof float[])</span>
<span class="fc" id="L334">			return Arrays.equals((float[]) o1, (float[]) o2);</span>
<span class="fc bfc" id="L335" title="All 2 branches covered.">		if (o1 instanceof int[])</span>
<span class="fc" id="L336">			return Arrays.equals((int[]) o1, (int[]) o2);</span>
<span class="fc bfc" id="L337" title="All 2 branches covered.">		if (o1 instanceof long[])</span>
<span class="fc" id="L338">			return Arrays.equals((long[]) o1, (long[]) o2);</span>
<span class="fc bfc" id="L339" title="All 2 branches covered.">		if (o1 instanceof short[])</span>
<span class="fc" id="L340">			return Arrays.equals((short[]) o1, (short[]) o2);</span>
<span class="fc bfc" id="L341" title="All 2 branches covered.">		if (o1.getClass().isArray()) {</span>
<span class="fc" id="L342">			int l1 = Array.getLength(o1);</span>
<span class="fc" id="L343">			int l2 = Array.getLength(o2);</span>
<span class="fc bfc" id="L344" title="All 2 branches covered.">			if (l1 != l2)</span>
<span class="fc" id="L345">				return false;</span>
<span class="fc bfc" id="L346" title="All 2 branches covered.">			for (int i = 0; i &lt; l1; i++)</span>
<span class="fc bfc" id="L347" title="All 2 branches covered.">				if (!equals(Array.get(o1, i), Array.get(o2, i)))</span>
<span class="fc" id="L348">					return false;</span>
<span class="fc" id="L349">			return true;</span>
		}

<span class="fc" id="L352">		return o1.equals(o2);</span>
	}

	/**
	 * Waits until a condition is met or a timeout interval expires.
	 * 
	 * @param lock      object to synchronize on
	 * @param condition condition to wait for
	 * @param timeout   timeout interval
	 * 
	 * @throws InterruptedException if the current thread is interrupted while
	 *                              waiting for the condition to be met
	 * @throws TimeoutException     if the timeout interval expires before the
	 *                              condition is met
	 * 
	 */
	public static void waitFor(Object lock, BooleanSupplier condition, Duration timeout)
			throws InterruptedException, TimeoutException {
<span class="fc" id="L370">		waitFor(lock, condition, Instant.now().plus(timeout));</span>
<span class="fc" id="L371">	}</span>

	/**
	 * Waits until a condition is met or a timeout interval expires.
	 * 
	 * @param lock           object to synchronize on
	 * @param condition      condition to wait for
	 * @param timeout        timeout interval
	 * @param timeoutFactory creates a timeout exception to be thrown if the
	 *                       condition is not met before the expiration time
	 * 
	 * @throws InterruptedException if the current thread is interrupted while
	 *                              waiting for the condition to be met
	 * @throws TimeoutException     if the timeout interval expires before the
	 *                              condition is met
	 * 
	 */
	public static void waitFor(Object lock, BooleanSupplier condition, Duration timeout,
			Supplier&lt;TimeoutException&gt; timeoutFactory) throws InterruptedException, TimeoutException {
<span class="fc" id="L390">		waitFor(lock, condition, Instant.now().plus(timeout), timeoutFactory);</span>
<span class="fc" id="L391">	}</span>

	/**
	 * Waits until a condition is met or a timeout interval expires.
	 * 
	 * @param lock      object to synchronize on to receive status change
	 *                  notifications
	 * @param condition condition to wait for
	 * @param expires   timeout interval expiration time
	 * 
	 * @throws InterruptedException if the current thread is interrupted while
	 *                              waiting for the condition to be met
	 * @throws TimeoutException     if the timeout interval expires before the
	 *                              condition is met
	 */
	public static void waitFor(Object lock, BooleanSupplier condition, Instant expires)
			throws InterruptedException, TimeoutException {
<span class="fc" id="L408">		final var init = Instant.now();</span>
<span class="fc" id="L409">		waitFor(lock, condition, expires, () -&gt; {</span>
<span class="fc" id="L410">			StringBuilder sb = new StringBuilder(&quot;Timed out in &quot;);</span>
<span class="fc" id="L411">			sb.append(Duration.between(init, expires));</span>
<span class="fc" id="L412">			return new TimeoutException(sb.toString());</span>
		});
<span class="fc" id="L414">	}</span>

	/**
	 * Waits until a condition is met or a timeout interval expires.
	 * 
	 * @param lock           object to synchronize on to receive status change
	 *                       notifications
	 * @param condition      condition to wait for
	 * @param expires        timeout interval expiration time
	 * @param timeoutFactory creates a timeout exception to be thrown if the
	 *                       condition is not met before the expiration time
	 * 
	 * @throws InterruptedException if the current thread is interrupted while
	 *                              waiting for the condition to be met
	 * @throws TimeoutException     if the timeout interval expires before the
	 *                              condition is met
	 */
	public static void waitFor(Object lock, BooleanSupplier condition, Instant expires,
			Supplier&lt;TimeoutException&gt; timeoutFactory) throws InterruptedException, TimeoutException {
<span class="fc" id="L433">		synchronized (lock) {</span>
<span class="fc bfc" id="L434" title="All 2 branches covered.">			while (!condition.getAsBoolean()) {</span>
<span class="fc" id="L435">				final var now = Instant.now();</span>
<span class="fc bfc" id="L436" title="All 2 branches covered.">				if (now.isBefore(expires)) {</span>
<span class="fc" id="L437">					final var waitFor = Duration.between(now, expires);</span>
<span class="fc" id="L438">					lock.wait(waitFor.toMillis(), waitFor.toNanosPart() % 1_000_000);</span>
<span class="fc" id="L439">				} else</span>
<span class="fc" id="L440">					throw timeoutFactory.get();</span>
<span class="fc" id="L441">			}</span>
<span class="fc" id="L442">		}</span>
<span class="fc" id="L443">	}</span>

	private IuObject() {
	};

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.10.202304240956</span></div></body></html>