<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>SamlServiceProvider.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">IU SAML 2.0 Service Provider</a> &gt; <a href="index.source.html" class="el_package">iu.auth.saml</a> &gt; <span class="el_source">SamlServiceProvider.java</span></div><h1>SamlServiceProvider.java</h1><pre class="source lang-java linenums">/*
 * Copyright Â© 2024 Indiana University
 * All rights reserved.
 *
 * BSD 3-Clause License
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 
 * - Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 * 
 * - Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 * 
 * - Neither the name of the copyright holder nor the names of its
 *   contributors may be used to endorse or promote products derived from
 *   this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package iu.auth.saml;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.InputStream;
import java.net.InetAddress;
import java.net.URI;
import java.time.Instant;
import java.util.Base64;
import java.util.Collections;
import java.util.LinkedHashMap;
import java.util.Map;
import java.util.Objects;
import java.util.logging.Logger;
import java.util.zip.Deflater;
import java.util.zip.DeflaterOutputStream;

import javax.security.auth.Subject;

import org.opensaml.core.xml.config.XMLObjectProviderRegistrySupport;
import org.opensaml.core.xml.util.XMLObjectSupport;
import org.opensaml.saml.common.SAMLVersion;
import org.opensaml.saml.saml2.core.AuthnRequest;
import org.opensaml.saml.saml2.core.Issuer;
import org.opensaml.saml.saml2.core.NameIDPolicy;
import org.opensaml.saml.saml2.core.Response;

import edu.iu.IuException;
import edu.iu.IuIterable;
import edu.iu.IuObject;
import edu.iu.IuText;
import edu.iu.IuWebUtils;
import edu.iu.auth.IuAuthenticationException;
import edu.iu.auth.IuPrincipalIdentity;
import edu.iu.auth.config.IuSamlServiceProviderMetadata;
import edu.iu.crypt.WebKey;
import edu.iu.crypt.WebKey.Algorithm;
import iu.auth.config.AuthConfig;
import iu.auth.config.IuAuthConfig;
import iu.auth.config.IuSamlServiceProvider;
import iu.auth.config.IuTrustedIssuer;
import iu.auth.principal.PrincipalVerifier;

/**
 * SAML Service Provider implementation class.
 */
public final class SamlServiceProvider implements IuSamlServiceProvider, PrincipalVerifier&lt;SamlPrincipal&gt; {
	static {
<span class="fc" id="L80">		IuObject.assertNotOpen(SamlServiceProvider.class);</span>
	}

<span class="fc" id="L83">	private static final Logger LOG = Logger.getLogger(SamlServiceProvider.class.getName());</span>

	/**
	 * Locates a SAML Service Provider configured with a given HTTP POST Binding URI
	 * as its {@link IuAuthConfig#getAuthenticationEndpoint() registered
	 * authentication endpoint}.
	 * 
	 * @param postUri HTTP POST Binding URI
	 * @return {@link SamlServiceProvider}
	 */
	static SamlServiceProvider withBinding(URI postUri) {
<span class="fc" id="L94">		Iterable&lt;IuSamlServiceProvider&gt; providers = AuthConfig.get(IuSamlServiceProvider.class);</span>
<span class="fc bfc" id="L95" title="All 2 branches covered.">		for (final var sp : providers) {</span>
<span class="fc" id="L96">			final var samlServiceProvider = (SamlServiceProvider) sp;</span>
<span class="fc bfc" id="L97" title="All 2 branches covered.">			if (postUri.equals(samlServiceProvider.postUri))</span>
<span class="fc" id="L98">				return samlServiceProvider;</span>
<span class="fc" id="L99">		}</span>
<span class="fc" id="L100">		throw new IllegalArgumentException();</span>
	}

	private final String realm;
	private final URI postUri;
	private final SamlBuilder samlBuilder;

	/**
	 * Initialize SAML provider
	 * 
	 * @param postUri HTTP POST Binding URI
	 * @param realm   authentication realm to use for reloading the config as needed
	 *                for future operations.
	 * @param config  {@link IuSamlServiceProviderMetadata}
	 */
<span class="fc" id="L115">	public SamlServiceProvider(URI postUri, String realm, IuSamlServiceProviderMetadata config) {</span>
<span class="fc" id="L116">		var matchAcs = false;</span>
<span class="fc bfc" id="L117" title="All 2 branches covered.">		for (final var acsUri : config.getAcsUris())</span>
<span class="fc bfc" id="L118" title="All 2 branches covered.">			if (acsUri.equals(postUri)) {</span>
<span class="fc" id="L119">				matchAcs = true;</span>
<span class="fc" id="L120">				break;</span>
			}

<span class="fc bfc" id="L123" title="All 2 branches covered.">		if (!matchAcs)</span>
<span class="fc" id="L124">			throw new IllegalArgumentException(</span>
					&quot;Post URI doesn't match with allowed list of Assertion Consumer Service URLs&quot;);

<span class="fc" id="L127">		this.postUri = postUri;</span>
<span class="fc" id="L128">		this.realm = realm;</span>
<span class="fc" id="L129">		this.samlBuilder = new SamlBuilder(config);</span>
<span class="fc" id="L130">	}</span>

	@Override
	public String getRealm() {
<span class="fc" id="L134">		return realm;</span>
	}

	@Override
	public String getAuthScheme() {
<span class="fc" id="L139">		return null;</span>
	}

	@Override
	public URI getAuthenticationEndpoint() {
<span class="fc" id="L144">		return postUri;</span>
	}

	@Override
	public Class&lt;SamlPrincipal&gt; getType() {
<span class="fc" id="L149">		return SamlPrincipal.class;</span>
	}

	@Override
	public boolean isAuthoritative() {
<span class="fc" id="L154">		return true;</span>
	}

	@Override
	public void verify(SamlPrincipal id) throws IuAuthenticationException {
<span class="fc" id="L159">		id.verify(realm);</span>
<span class="fc" id="L160">		LOG.info(() -&gt; &quot;saml:verify:&quot; + id.getName() + &quot;; serviceProvider: &quot; + realm);</span>
<span class="fc" id="L161">	}</span>

	/**
	 * Gets the service provider metadata for external hosting.
	 * 
	 * @return SP metadata
	 */
	public String getServiceProviderMetaData() {
<span class="fc" id="L169">		return samlBuilder.getServiceProviderMetadata();</span>
	}

	/**
	 * Generate SAML authentication request use by client to redirect user to
	 * identity provider system for authentication.
	 * 
	 * @param relayState RelayState parameter value
	 * @param sessionId  SAML AuthnRequest ID
	 * @return SAML AuthnRequest Redirect URI
	 */
	URI getAuthnRequest(String relayState, String sessionId) {
<span class="fc" id="L181">		final var destinationLocation = samlBuilder.singleSignOnLocation.toString();</span>

<span class="fc" id="L183">		final var authnRequest = (AuthnRequest) XMLObjectProviderRegistrySupport.getBuilderFactory()</span>
<span class="fc" id="L184">				.getBuilder(AuthnRequest.DEFAULT_ELEMENT_NAME).buildObject(AuthnRequest.DEFAULT_ELEMENT_NAME);</span>
<span class="fc" id="L185">		authnRequest.setAssertionConsumerServiceURL(postUri.toString());</span>
<span class="fc" id="L186">		authnRequest.setDestination(destinationLocation);</span>
<span class="fc" id="L187">		authnRequest.setID(sessionId);</span>
<span class="fc" id="L188">		authnRequest.setIssueInstant(Instant.now());</span>
<span class="fc" id="L189">		authnRequest.setProtocolBinding(&quot;urn:oasis:names:tc:SAML:2.0:bindings:HTTP-POST&quot;);</span>
<span class="fc" id="L190">		authnRequest.setVersion(SAMLVersion.VERSION_20);</span>

<span class="fc" id="L192">		final var issuer = (Issuer) XMLObjectProviderRegistrySupport.getBuilderFactory()</span>
<span class="fc" id="L193">				.getBuilder(Issuer.DEFAULT_ELEMENT_NAME).buildObject(Issuer.DEFAULT_ELEMENT_NAME);</span>
<span class="fc" id="L194">		issuer.setValue(samlBuilder.serviceProviderEntityId);</span>
<span class="fc" id="L195">		authnRequest.setIssuer(issuer);</span>

<span class="fc" id="L197">		final var nameIdPolicy = (NameIDPolicy) XMLObjectProviderRegistrySupport.getBuilderFactory()</span>
<span class="fc" id="L198">				.getBuilder(NameIDPolicy.DEFAULT_ELEMENT_NAME).buildObject(NameIDPolicy.DEFAULT_ELEMENT_NAME);</span>
<span class="fc" id="L199">		nameIdPolicy.setAllowCreate(true);</span>
<span class="fc" id="L200">		authnRequest.setNameIDPolicy(nameIdPolicy);</span>

<span class="fc" id="L202">		final var samlRequest = IuException.unchecked(() -&gt; {</span>
<span class="fc" id="L203">			var s = XmlDomUtil.getContent(XMLObjectProviderRegistrySupport.getMarshallerFactory()</span>
<span class="fc" id="L204">					.getMarshaller(authnRequest).marshall(authnRequest));</span>
<span class="fc bfc" id="L205" title="All 2 branches covered.">			if (s.startsWith(&quot;&lt;?xml&quot;)) {</span>
<span class="fc" id="L206">				StringBuilder sb = new StringBuilder(s);</span>
<span class="fc" id="L207">				int i = sb.indexOf(&quot;?&gt;\n&quot;, 4);</span>
<span class="fc bfc" id="L208" title="All 2 branches covered.">				if (i != -1)</span>
<span class="fc" id="L209">					sb.delete(0, i + 3);</span>
<span class="fc" id="L210">				s = sb.toString();</span>
			}

<span class="fc" id="L213">			final var deflater = new Deflater(Deflater.DEFLATED, true);</span>
<span class="fc" id="L214">			final var samlRequestBuffer = new ByteArrayOutputStream();</span>
<span class="fc" id="L215">			try (DeflaterOutputStream d = new DeflaterOutputStream(samlRequestBuffer, deflater)) {</span>
<span class="fc" id="L216">				d.write(IuText.utf8(s));</span>
			}

<span class="fc" id="L219">			return Base64.getEncoder().encodeToString(samlRequestBuffer.toByteArray());</span>
		});

<span class="fc" id="L222">		final Map&lt;String, Iterable&lt;String&gt;&gt; idpParams = new LinkedHashMap&lt;&gt;();</span>
<span class="fc" id="L223">		idpParams.put(&quot;SAMLRequest&quot;, Collections.singleton(samlRequest));</span>
<span class="fc" id="L224">		idpParams.put(&quot;RelayState&quot;, Collections.singleton(relayState));</span>
<span class="fc" id="L225">		return URI.create(destinationLocation + '?' + IuWebUtils.createQueryString(idpParams));</span>
	}

	/**
	 * Gets the token signature verification algorithm.
	 * 
	 * @return {@link Algorithm}
	 */
	Algorithm getVerifyAlg() {
<span class="fc" id="L234">		return samlBuilder.verifyAlg;</span>
	}

	/**
	 * Gets the token signature verification key.
	 * 
	 * @return {@link WebKey}
	 */
	WebKey getVerifyKey() {
<span class="fc" id="L243">		final var config = AuthConfig.load(IuSamlServiceProviderMetadata.class, realm);</span>
<span class="fc" id="L244">		final var identity = serviceProviderIdentity(config);</span>
<span class="fc" id="L245">		return identity.getSubject().getPrivateCredentials(WebKey.class).stream()</span>
<span class="fc" id="L246">				.filter(a -&gt; &quot;verify&quot;.equals(a.getKeyId())).findFirst().get();</span>
	}

	/**
	 * Looks for an authoritative trusted issuer identity matching the SAML Service
	 * Provider configuration and returns its principal identity.
	 * 
	 * &lt;p&gt;
	 * This identity will have {@link Subject#getPrivateCredentials(Class) private}
	 * {@link WebKey} {@link Subject#getPrivateCredentials(Class) credentials} with
	 * kid values {@code verify} and {@code encrypt} suitable for use with
	 * SP-related crypto operations.
	 * &lt;/p&gt;
	 * 
	 * @param config {@link IuSamlServiceProviderMetadata}
	 * @return {@link IuPrincipalIdentity}
	 */
	static IuPrincipalIdentity serviceProviderIdentity(IuSamlServiceProviderMetadata config) {
<span class="fc" id="L264">		final var identity = IuIterable.stream(AuthConfig.get(IuTrustedIssuer.class)) //</span>
<span class="fc" id="L265">				.map(a -&gt; a.getPrincipal(config.getIdentity())) //</span>
<span class="fc" id="L266">				.filter(Objects::nonNull).findFirst() //</span>
<span class="fc" id="L267">				.orElseThrow(() -&gt; new IllegalStateException(&quot;service provider is not trusted&quot;));</span>

<span class="fc bfc" id="L269" title="All 2 branches covered.">		if (!IuException.unchecked(() -&gt; IuPrincipalIdentity.verify(identity, identity.getName())))</span>
<span class="fc" id="L270">			throw new IllegalStateException(&quot;service provider is not authoritative&quot;);</span>
		else
<span class="fc" id="L272">			return identity;</span>
	}

	/**
	 * Authorize SAML response return back from IDP
	 * 
	 * @param address      IP address use by user to authenticate
	 * @param samlResponse xml SAML response back from identity provider
	 * @param sessionId    SAML session ID from original AuthnRequest
	 * @return {@link SamlPrincipal}
	 */
	SamlPrincipal verifyResponse(InetAddress address, String samlResponse, String sessionId) {
<span class="fc" id="L284">		Thread current = Thread.currentThread();</span>
<span class="fc" id="L285">		ClassLoader currentLoader = current.getContextClassLoader();</span>
		try {
<span class="fc" id="L287">			current.setContextClassLoader(XMLObjectSupport.class.getClassLoader());</span>

<span class="fc" id="L289">			final var response = IuException.unchecked(() -&gt; {</span>
<span class="fc" id="L290">				try (InputStream in = new ByteArrayInputStream(Base64.getDecoder().decode(samlResponse))) {</span>
<span class="fc" id="L291">					return (Response) XMLObjectSupport</span>
<span class="fc" id="L292">							.unmarshallFromInputStream(XMLObjectProviderRegistrySupport.getParserPool(), in);</span>
				}
			}, &quot;Invalid SAMLResponse&quot;);

<span class="fc" id="L296">			String entityId = response.getIssuer().getValue();</span>
<span class="fc" id="L297">			LOG.fine(() -&gt; &quot;SAML2 authentication response\nEntity ID: &quot; + entityId + &quot;\nPOST URL: &quot; + postUri.toString()</span>
<span class="fc" id="L298">					+ &quot;\n&quot; + XmlDomUtil.getContent(response.getDOM()));</span>

<span class="fc" id="L300">			final var samlResponseValidator = new SamlResponseValidator(realm, postUri, entityId, sessionId, address, samlBuilder);</span>
<span class="fc" id="L301">			return IuException.unchecked(() -&gt; samlResponseValidator.validate(response));</span>

		} finally {
<span class="fc" id="L304">			current.setContextClassLoader(currentLoader);</span>
		}
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.10.202304240956</span></div></body></html>