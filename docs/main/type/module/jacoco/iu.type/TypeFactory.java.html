<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>TypeFactory.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">IU Type Introspection Module</a> &gt; <a href="index.source.html" class="el_package">iu.type</a> &gt; <span class="el_source">TypeFactory.java</span></div><h1>TypeFactory.java</h1><pre class="source lang-java linenums">/*
 * Copyright © 2024 Indiana University
 * All rights reserved.
 *
 * BSD 3-Clause License
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 
 * - Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 * 
 * - Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 * 
 * - Neither the name of the copyright holder nor the names of its
 *   contributors may be used to endorse or promote products derived from
 *   this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package iu.type;

import java.lang.reflect.Array;
import java.lang.reflect.GenericArrayType;
import java.lang.reflect.ParameterizedType;
import java.lang.reflect.Type;
import java.lang.reflect.TypeVariable;
import java.lang.reflect.WildcardType;
import java.util.ArrayDeque;
import java.util.Deque;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.Map;
import java.util.Objects;
import java.util.WeakHashMap;
import java.util.function.Consumer;

import edu.iu.type.IuType;
import edu.iu.type.IuTypeKey;

/**
 * Provides fully formed instances of {@link TypeTemplate} to
 * {@link TypeSpi#resolveType(Type)}.
 */
final class TypeFactory {

<span class="fc" id="L58">	private static final Map&lt;Class&lt;?&gt;, TypeTemplate&lt;?, ?&gt;&gt; RAW_TYPES = new WeakHashMap&lt;&gt;();</span>
<span class="fc" id="L59">	private static final ThreadLocal&lt;Map&lt;IuTypeKey, TypeTemplate&lt;?, ?&gt;&gt;&gt; PENDING_GENERIC_TYPES = new ThreadLocal&lt;&gt;();</span>
<span class="fc" id="L60">	private static final ThreadLocal&lt;Map&lt;Class&lt;?&gt;, TypeTemplate&lt;?, ?&gt;&gt;&gt; PENDING_RAW_TYPES = new ThreadLocal&lt;&gt;();</span>

	/**
	 * Clears all indexed and cached data.
	 * 
	 * &lt;p&gt;
	 * &lt;em&gt;Should&lt;/em&gt; be used:
	 * &lt;/p&gt;
	 * 
	 * &lt;ul&gt;
	 * &lt;li&gt;Between internal unit tests to reset state.&lt;/li&gt;
	 * &lt;li&gt;As an administrative function from a container management interface.&lt;/li&gt;
	 * &lt;/ul&gt;
	 */
	static void clear() {
<span class="fc" id="L75">		synchronized (RAW_TYPES) {</span>
<span class="fc" id="L76">			RAW_TYPES.clear();</span>
<span class="fc" id="L77">		}</span>
<span class="fc" id="L78">	}</span>

	/**
	 * Gets the type erasure for a generic type.
	 * 
	 * @param type raw or generic type
	 * @return type erasure
	 * @see IuType#erasedClass()
	 */
	static Class&lt;?&gt; getErasedClass(Type type) {
<span class="fc bfc" id="L88" title="All 2 branches covered.">		if (type instanceof Class)</span>
<span class="fc" id="L89">			return (Class&lt;?&gt;) type;</span>

<span class="fc" id="L91">		record Node(Type type, int array) {</span>
		}

<span class="fc" id="L94">		Deque&lt;Node&gt; todo = new ArrayDeque&lt;&gt;();</span>
<span class="fc" id="L95">		var node = new Node(type, 0);</span>
<span class="fc" id="L96">		todo.push(node);</span>

<span class="fc bfc" id="L98" title="All 2 branches covered.">		while (!todo.isEmpty()) {</span>
<span class="fc" id="L99">			node = todo.pop();</span>

			// JLS 21 4.6: The erasure of an array type T[] is |T|[].
<span class="fc bfc" id="L102" title="All 2 branches covered.">			if (node.type instanceof GenericArrayType)</span>
<span class="fc" id="L103">				todo.push(new Node(((GenericArrayType) node.type).getGenericComponentType(), node.array + 1));</span>

			// JLS 21 4.6: The erasure of a parameterized type (§4.5) G&lt;T1,...,Tn&gt; is |G|.
<span class="fc bfc" id="L106" title="All 2 branches covered.">			else if (node.type instanceof ParameterizedType)</span>
<span class="fc" id="L107">				todo.push(new Node(((ParameterizedType) node.type).getRawType(), node.array));</span>

			// JLS 21 4.6: The erasure of a type variable (§4.4) is the erasure of its
			// leftmost bound
<span class="fc bfc" id="L111" title="All 2 branches covered.">			else if (node.type instanceof TypeVariable)</span>
				/*
				 * This method implements the logic for a **reference** type variable. That is,
				 * The type variable at the end of a reference chain. For example, The type
				 * variable E in the parameterized type ArrayList&lt;E&gt; refers to the variable E in
				 * List&lt;E&gt;, which in turn refers to the variable T in Iterable&lt;T&gt;. If the
				 * introspected instance is an ArrayList, but the type of the element being
				 * introspected is Iterable&lt;?&gt; and the purpose of introspection is to determine
				 * the item type for elements in the iteration, this method is only responsible
				 * for resolving the type variable E on ArrayList&lt;String&gt; to the class String,
				 * not for derefencing the two type variable references it takes to reach that
				 * reference variable.
				 */
<span class="fc" id="L124">				todo.push(new Node(((TypeVariable&lt;?&gt;) node.type).getBounds()[0], node.array));</span>

			/*
			 * During capture conversion, a wildcard type arguments translates to a type
			 * variable with bounds equivalent to the upper bound of upper bound of the
			 * wildcard. So, may be erased to its left-most upper bound for determining the
			 * equivalent raw type of a type argument.
			 */
			// JLS 21 5.1.10:
			// If Ti is a wildcard type argument of the form ? extends Bi, then Si is a
			// fresh type variable whose upper bound is glb(Bi, Ui[A1:=S1,...,An:=Sn]) and
			// whose lower bound is the null type.
			// glb(V1,...,Vm) is defined as V1 &amp; ... &amp; Vm
<span class="fc bfc" id="L137" title="All 2 branches covered.">			else if (node.type instanceof WildcardType)</span>
<span class="fc" id="L138">				todo.push(new Node(((WildcardType) node.type).getUpperBounds()[0], node.array));</span>

<span class="fc bfc" id="L140" title="All 2 branches covered.">			else if (!(node.type instanceof Class))</span>
				// java.lang.reflect.Type should be considered effectively sealed to the only
				// the types handled above. Custom implementations are not covered by JLS and
				// cannot be generated by the compiler.
<span class="fc" id="L144">				throw new IllegalArgumentException(</span>
						&quot;Invalid generic type, must be ParameterizedType, GenericArrayType, TypeVariable, or WildcardType&quot;);
		}

<span class="fc" id="L148">		var erasure = (Class&lt;?&gt;) node.type;</span>
<span class="fc bfc" id="L149" title="All 2 branches covered.">		for (var i = 0; i &lt; node.array; i++)</span>
<span class="fc" id="L150">			erasure = Array.newInstance(erasure, 0).getClass();</span>
<span class="fc" id="L151">		return erasure;</span>
	}

	/**
	 * Applies a front-loaded pre-initialization cache to the current thread to
	 * prevent head recursion while resolving type templates for the global raw type
	 * cache.
	 * 
	 * &lt;p&gt;
	 * This encapsulates both raw global cache and tail-recursive hierarchy
	 * resolution with global cache resolution.
	 * &lt;/p&gt;
	 * 
	 * @param &lt;T&gt;      raw type
	 * @param rawClass raw class
	 * @param register pre-initialization hook consumer. &lt;em&gt;Must&lt;/em&gt; implement all
	 *                 cache-miss resolution logic; will be passed a value to supply
	 *                 to {@link TypeTemplate#TypeTemplate(Class, Consumer)} for
	 *                 registering the new instance on the current thread before
	 *                 applying internal constructor logic. At least one
	 *                 {@link TypeTemplate} instance &lt;em&gt;must&lt;/em&gt; be created, the
	 *                 last instance created will be applied to the global cache and
	 *                 returned. Exceptions thrown from
	 *                 {@link Consumer#accept(Object)} will pending
	 *                 {@link TypeTemplate}s cached on the current thread to be
	 *                 discarded.
	 * @return cached or resolved {@link TypeTemplate} instance
	 */
	@SuppressWarnings({ &quot;rawtypes&quot;, &quot;unchecked&quot; })
	static &lt;T&gt; TypeTemplate&lt;?, T&gt; applyRawTypeCache(Class&lt;T&gt; rawClass,
			Consumer&lt;Consumer&lt;TypeTemplate&lt;?, ?&gt;&gt;&gt; register) {
<span class="fc" id="L182">		TypeTemplate resolvedType = RAW_TYPES.get(rawClass);</span>
<span class="fc bfc" id="L183" title="All 2 branches covered.">		if (resolvedType != null)</span>
<span class="fc" id="L184">			return resolvedType;</span>

<span class="fc" id="L186">		final var threadRawTypes = PENDING_RAW_TYPES.get();</span>
		final Map&lt;Class&lt;?&gt;, TypeTemplate&lt;?, ?&gt;&gt; pendingRawTypes;
<span class="fc bfc" id="L188" title="All 2 branches covered.">		if (threadRawTypes == null)</span>
<span class="fc" id="L189">			PENDING_RAW_TYPES.set(pendingRawTypes = new HashMap&lt;&gt;());</span>
		else
<span class="fc" id="L191">			pendingRawTypes = threadRawTypes;</span>

<span class="fc" id="L193">		resolvedType = pendingRawTypes.get(rawClass);</span>
<span class="fc bfc" id="L194" title="All 2 branches covered.">		if (resolvedType != null)</span>
<span class="fc" id="L195">			return resolvedType;</span>

		try {
<span class="fc" id="L198">			register.accept(s -&gt; pendingRawTypes.put(rawClass, s));</span>
<span class="fc" id="L199">			resolvedType = Objects.requireNonNull(pendingRawTypes.get(rawClass));</span>

<span class="fc" id="L201">			synchronized (RAW_TYPES) {</span>
<span class="fc" id="L202">				RAW_TYPES.put(rawClass, resolvedType);</span>
<span class="fc" id="L203">			}</span>

<span class="fc" id="L205">			return resolvedType;</span>
		} finally {
<span class="fc bfc" id="L207" title="All 2 branches covered.">			if (threadRawTypes == null)</span>
<span class="fc" id="L208">				PENDING_RAW_TYPES.remove();</span>
		}
	}

	/**
	 * Gets a resolved type facade for a raw class.
	 * 
	 * @param &lt;T&gt;      raw type
	 * @param rawClass raw class
	 * @return {@link TypeFacade}
	 */
	@SuppressWarnings({ &quot;rawtypes&quot;, &quot;unchecked&quot; })
	static &lt;T&gt; TypeTemplate&lt;?, T&gt; resolveRawClass(Class&lt;T&gt; rawClass) {
		// Box pattern helps maintain hierarchy reference chain
		// by facilitating in-place swap for finer-grained references
		// as discovered in the type hierarchy
		class Box {
			IuType&lt;?, ? super T&gt; value;

<span class="fc" id="L227">			Box(IuType&lt;?, ? super T&gt; value) {</span>
<span class="fc" id="L228">				this.value = value;</span>
<span class="fc" id="L229">			}</span>
		}

<span class="fc" id="L232">		return applyRawTypeCache(rawClass, preInitHook -&gt; {</span>
<span class="fc" id="L233">			final var resolvedType = new TypeTemplate&lt;&gt;(rawClass, preInitHook);</span>

			// LinkedHashMap maintains object-first order
<span class="fc" id="L236">			final Map&lt;Class&lt;?&gt;, Box&gt; hierarchyByErasure = new LinkedHashMap&lt;&gt;();</span>

			// Create a top-down (Object-first) traversal queue for all classes
			// extended and interfaces implemented by the raw class
<span class="fc" id="L240">			final Deque&lt;Type&gt; hierarchy = new ArrayDeque&lt;&gt;();</span>
			{
<span class="fc" id="L242">				final Deque&lt;Type&gt; todo = new ArrayDeque&lt;&gt;();</span>
<span class="fc" id="L243">				todo.push(rawClass); // bottom-up traversal stack</span>

<span class="fc bfc" id="L245" title="All 2 branches covered.">				while (!todo.isEmpty()) {</span>
<span class="fc" id="L246">					final var type = todo.pop();</span>
<span class="fc bfc" id="L247" title="All 2 branches covered.">					if (type != rawClass) // don't include raw class in hierarchy</span>
<span class="fc" id="L248">						hierarchy.push(type); // push in reverse of traversal order</span>

<span class="fc" id="L250">					final var erasedClass = getErasedClass(type);</span>

					// truncate hierarchy at Object for Java language-native types
<span class="fc bfc" id="L253" title="All 2 branches covered.">					if (erasedClass == Object.class)</span>
<span class="fc" id="L254">						continue;</span>
<span class="fc bfc" id="L255" title="All 2 branches covered.">					else if (erasedClass == Class.class)</span>
<span class="fc" id="L256">						todo.push(Object.class);</span>

					else {
						// traversal stack will be reversed, so push Object before interfaces
						// : last in stack traversal results in first queued
<span class="fc" id="L261">						final var superType = erasedClass.getGenericSuperclass();</span>
<span class="fc bfc" id="L262" title="All 2 branches covered.">						if (superType != null)</span>
<span class="fc" id="L263">							todo.push(superType);</span>

<span class="fc bfc" id="L265" title="All 2 branches covered.">						for (final var implemented : erasedClass.getGenericInterfaces())</span>
<span class="fc" id="L266">							todo.push(implemented);</span>
					}
<span class="fc" id="L268">				}</span>
			}

			// This loop trusts getHierarchy() to return Object-first so super classes may
			// be resolved first, in place, while scanning deeper in the hierarchy
<span class="fc bfc" id="L273" title="All 2 branches covered.">			for (var superType : hierarchy) {</span>
<span class="fc" id="L274">				final var erasedSuperClass = (Class&lt;? super T&gt;) getErasedClass(superType);</span>
<span class="fc" id="L275">				final var rawSuperType = applyRawTypeCache(erasedSuperClass, superPreInitHook -&gt; {</span>
<span class="fc" id="L276">					var pendingRawSuperType = new TypeTemplate&lt;&gt;(erasedSuperClass, superPreInitHook);</span>

					// Build and cache new template on the fly. This is possible since we
					// already have the interim type's full hierarchy available.
<span class="fc" id="L280">					final Deque&lt;IuType&lt;?, ? super T&gt;&gt; superHierarchy = new ArrayDeque&lt;&gt;();</span>
<span class="fc bfc" id="L281" title="All 2 branches covered.">					for (var superTypeBox : hierarchyByErasure.values()) {</span>
<span class="fc" id="L282">						final var inheritedSuperType = superTypeBox.value;</span>
<span class="fc" id="L283">						final var erasedClass = inheritedSuperType.erasedClass();</span>

						// filter super-type hierarchy to only include assignable elements
						// Note that interfaces do not declare Object as superclass
						// https://docs.oracle.com/javase/specs/jls/se21/html/jls-9.html
<span class="fc bfc" id="L288" title="All 4 branches covered.">						if ((erasedClass != Object.class || !erasedSuperClass.isInterface()) //</span>
<span class="fc bfc" id="L289" title="All 2 branches covered.">								&amp;&amp; erasedClass.isAssignableFrom(erasedSuperClass))</span>
<span class="fc" id="L290">							superHierarchy.push(inheritedSuperType);</span>
<span class="fc" id="L291">					}</span>

<span class="fc" id="L293">					pendingRawSuperType.sealHierarchy((Iterable) superHierarchy);</span>
<span class="fc" id="L294">				});</span>

				TypeTemplate&lt;?, ? super T&gt; superTypeTemplate;
<span class="fc bfc" id="L297" title="All 2 branches covered.">				if (superType == erasedSuperClass)</span>
<span class="fc" id="L298">					superTypeTemplate = (TypeTemplate&lt;?, ? super T&gt;) rawSuperType;</span>
				else
<span class="fc" id="L300">					superTypeTemplate = (TypeTemplate&lt;?, ? super T&gt;) resolveType(superType);</span>

				// replace previously resolved super type references with references through the
				// declaring extended class or implemented interface
<span class="fc bfc" id="L304" title="All 2 branches covered.">				for (var inheritedSuperType : superTypeTemplate.hierarchy()) {</span>
<span class="fc" id="L305">					var inheritedErasedClass = inheritedSuperType.erasedClass();</span>
<span class="fc" id="L306">					var inheritedBox = Objects.requireNonNull(hierarchyByErasure.get(inheritedErasedClass));</span>
<span class="fc" id="L307">					inheritedBox.value = inheritedSuperType;</span>
<span class="fc" id="L308">				}</span>

<span class="fc" id="L310">				hierarchyByErasure.put(erasedSuperClass, new Box(superTypeTemplate));</span>
<span class="fc" id="L311">			}</span>

<span class="fc" id="L313">			final Deque&lt;IuType&lt;?, ? super T&gt;&gt; hierarchyTemplates = new ArrayDeque&lt;&gt;();</span>
<span class="fc bfc" id="L314" title="All 2 branches covered.">			for (final var hierarchyReference : hierarchyByErasure.values())</span>
<span class="fc" id="L315">				hierarchyTemplates.push(hierarchyReference.value);</span>

<span class="fc" id="L317">			resolvedType.sealHierarchy(hierarchyTemplates);</span>
<span class="fc" id="L318">		});</span>
	}

	/**
	 * Resolves a facade for a generic type.
	 * 
	 * @param type generic type
	 * @return {@link TypeFacade}
	 */
	static TypeTemplate&lt;?, ?&gt; resolveType(Type type) {
<span class="fc" id="L328">		Objects.requireNonNull(type, &quot;type&quot;);</span>
<span class="fc bfc" id="L329" title="All 2 branches covered.">		if (type instanceof Class)</span>
<span class="fc" id="L330">			return resolveRawClass((Class&lt;?&gt;) type);</span>
		else {
			// Establish base case for self and loop references
<span class="fc" id="L333">			final var restorePendingGenericTypes = PENDING_GENERIC_TYPES.get();</span>
			try {
				final Map&lt;IuTypeKey, TypeTemplate&lt;?, ?&gt;&gt; pendingGenericTypes;
<span class="fc bfc" id="L336" title="All 2 branches covered.">				if (restorePendingGenericTypes == null) {</span>
<span class="fc" id="L337">					pendingGenericTypes = new HashMap&lt;&gt;();</span>
<span class="fc" id="L338">					PENDING_GENERIC_TYPES.set(pendingGenericTypes);</span>
				} else
<span class="fc" id="L340">					pendingGenericTypes = restorePendingGenericTypes;</span>

<span class="fc" id="L342">				final var key = IuTypeKey.of(type);</span>
<span class="fc" id="L343">				final var resolvedType = pendingGenericTypes.get(key);</span>
<span class="fc bfc" id="L344" title="All 2 branches covered.">				if (resolvedType != null)</span>
<span class="fc" id="L345">					return resolvedType;</span>

<span class="fc" id="L347">				return new TypeTemplate&lt;&gt;(s -&gt; pendingGenericTypes.put(key, s), type,</span>
<span class="fc" id="L348">						resolveRawClass(getErasedClass(type)));</span>
			} finally {
<span class="fc bfc" id="L350" title="All 2 branches covered.">				if (restorePendingGenericTypes == null)</span>
<span class="fc" id="L351">					PENDING_GENERIC_TYPES.remove();</span>
			}
		}
	}

	private TypeFactory() {
	}

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.10.202304240956</span></div></body></html>