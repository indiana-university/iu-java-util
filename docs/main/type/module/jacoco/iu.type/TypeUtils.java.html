<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>TypeUtils.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">IU Type Introspection Module</a> &gt; <a href="index.source.html" class="el_package">iu.type</a> &gt; <span class="el_source">TypeUtils.java</span></div><h1>TypeUtils.java</h1><pre class="source lang-java linenums">/*
 * Copyright Â© 2023 Indiana University
 * All rights reserved.
 *
 * BSD 3-Clause License
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 
 * - Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 * 
 * - Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 * 
 * - Neither the name of the copyright holder nor the names of its
 *   contributors may be used to endorse or promote products derived from
 *   this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package iu.type;

import java.lang.reflect.AnnotatedElement;
import java.lang.reflect.Executable;
import java.lang.reflect.Field;
import java.lang.reflect.GenericArrayType;
import java.lang.reflect.Parameter;
import java.lang.reflect.ParameterizedType;
import java.lang.reflect.Type;

import edu.iu.UnsafeSupplier;
import edu.iu.type.IuType;

/**
 * Miscellaneous type introspection utilities.
 */
final class TypeUtils {

	/**
	 * Determines if a type name is exempt from the {@link ClassLoader} delegation
	 * suppression required for web applications.
	 * 
	 * @param name type name
	 * @return {code true} if a platform type; else false
	 * 
	 * @see &lt;a href=
	 *      &quot;https://jakarta.ee/specifications/servlet/6.0/jakarta-servlet-spec-6.0#web-application-class-loader&quot;&gt;
	 *      Servlet 6.0, section 10.7.2&lt;/a&gt;
	 */
	static boolean isPlatformType(String name) {
<span class="fc bfc" id="L62" title="All 2 branches covered.">		return name.startsWith(&quot;jakarta.&quot;) //</span>
<span class="fc bfc" id="L63" title="All 2 branches covered.">				|| name.startsWith(&quot;java.&quot;) //</span>
<span class="fc bfc" id="L64" title="All 2 branches covered.">				|| name.startsWith(&quot;javax.&quot;) //</span>
<span class="fc bfc" id="L65" title="All 2 branches covered.">				|| name.startsWith(&quot;jdk.&quot;);</span>
	}

	/**
	 * Gets the context class loader appropriate for a given annotated element.
	 * 
	 * @param element annotated element
	 * @return class loader that loaded the element
	 */
	static ClassLoader getContext(AnnotatedElement element) {
<span class="fc bfc" id="L75" title="All 2 branches covered.">		if (element instanceof Class)</span>
<span class="fc" id="L76">			return ((Class&lt;?&gt;) element).getClassLoader();</span>
<span class="fc bfc" id="L77" title="All 2 branches covered.">		else if (element instanceof Executable)</span>
<span class="fc" id="L78">			return ((Executable) element).getDeclaringClass().getClassLoader();</span>
<span class="fc bfc" id="L79" title="All 2 branches covered.">		else if (element instanceof Field)</span>
<span class="fc" id="L80">			return ((Field) element).getDeclaringClass().getClassLoader();</span>
<span class="fc bfc" id="L81" title="All 2 branches covered.">		else if (element instanceof Parameter)</span>
<span class="fc" id="L82">			return ((Parameter) element).getDeclaringExecutable().getDeclaringClass().getClassLoader();</span>
		else
<span class="fc" id="L84">			throw new UnsupportedOperationException(&quot;Cannot determine context for &quot; + element);</span>
	}

	/**
	 * Invokes an {@link UnsafeSupplier} using a specific context class loader.
	 * 
	 * @param &lt;T&gt;           return type
	 * @param contextLoader {@link ClassLoader}
	 * @param supplier      {@link UnsafeSupplier}
	 * @return result of {@link UnsafeSupplier#get()}
	 * 
	 * @throws Throwable from {@link UnsafeSupplier#get()}
	 */
	static &lt;T&gt; T callWithContext(ClassLoader contextLoader, UnsafeSupplier&lt;T&gt; supplier) throws Throwable {
<span class="fc" id="L98">		var current = Thread.currentThread();</span>
<span class="fc" id="L99">		var loader = current.getContextClassLoader();</span>
		try {
<span class="fc" id="L101">			current.setContextClassLoader(contextLoader);</span>
<span class="fc" id="L102">			return supplier.get();</span>
		} finally {
<span class="fc" id="L104">			current.setContextClassLoader(loader);</span>
		}
	}

	/**
	 * Invokes an {@link UnsafeSupplier} using a context appropriate for an
	 * annotated element.
	 * 
	 * @param &lt;T&gt;      return type
	 * @param element  {@link AnnotatedElement}
	 * @param supplier {@link UnsafeSupplier}
	 * @return result of {@link UnsafeSupplier#get()}
	 * 
	 * @throws Throwable from {@link UnsafeSupplier#get()}
	 */
	static &lt;T&gt; T callWithContext(AnnotatedElement element, UnsafeSupplier&lt;T&gt; supplier) throws Throwable {
<span class="fc" id="L120">		return callWithContext(getContext(element), supplier);</span>
	}

	/**
	 * Prints a generic type.
	 * 
	 * @param type generic type
	 * @return human-readable form
	 */
	static String printType(Type type) {
<span class="fc bfc" id="L130" title="All 2 branches covered.">		if (type instanceof Class) {</span>
<span class="fc" id="L131">			var c = (Class&lt;?&gt;) type;</span>
<span class="fc bfc" id="L132" title="All 2 branches covered.">			if (c.isArray())</span>
<span class="fc" id="L133">				return printType(c.componentType()) + &quot;[]&quot;;</span>
			else
<span class="fc" id="L135">				return c.getSimpleName();</span>
<span class="fc bfc" id="L136" title="All 2 branches covered.">		} else if (type instanceof GenericArrayType) {</span>
<span class="fc" id="L137">			var genericArrayType = (GenericArrayType) type;</span>
<span class="fc" id="L138">			var genericComponentType = genericArrayType.getGenericComponentType();</span>
<span class="fc" id="L139">			return printType(genericComponentType) + &quot;[]&quot;;</span>
<span class="fc bfc" id="L140" title="All 2 branches covered.">		} else if (type instanceof ParameterizedType) {</span>
<span class="fc" id="L141">			var parameterizedType = (ParameterizedType) type;</span>
<span class="fc" id="L142">			StringBuilder sb = new StringBuilder(printType(parameterizedType.getRawType()));</span>
<span class="fc" id="L143">			sb.append('&lt;');</span>
<span class="fc" id="L144">			var l = sb.length();</span>
<span class="fc bfc" id="L145" title="All 2 branches covered.">			for (var actualTypeArgument : parameterizedType.getActualTypeArguments()) {</span>
<span class="fc bfc" id="L146" title="All 2 branches covered.">				if (sb.length() &gt; l)</span>
<span class="fc" id="L147">					sb.append(',');</span>
<span class="fc" id="L148">				sb.append(printType(actualTypeArgument));</span>
			}
<span class="fc" id="L150">			sb.append('&gt;');</span>
<span class="fc" id="L151">			return sb.toString();</span>
		} else
<span class="fc" id="L153">			return type.toString();</span>
	}

	/**
	 * Refers to a type in a hierarchy, for internal use by {@link TypeTemplate} and
	 * {@link TypeFacade}.
	 * 
	 * @param &lt;T&gt;          referrer type
	 * @param referrerType referrer type facade
	 * @param hierarchy    referrer's type hierarchy
	 * @param referentType generic referent type to match
	 * 
	 * @return inherited type facade with same erasure as the {@code referentType}
	 */
	static &lt;T&gt; IuType&lt;?, ? super T&gt; referTo(IuType&lt;?, T&gt; referrerType, Iterable&lt;TypeFacade&lt;?, ? super T&gt;&gt; hierarchy,
			Type referentType) {
<span class="fc" id="L169">		var erasedClass = TypeFactory.getErasedClass(referentType);</span>
<span class="fc bfc" id="L170" title="All 2 branches covered.">		if (erasedClass == referrerType.erasedClass())</span>
<span class="fc" id="L171">			return referrerType;</span>

<span class="fc bfc" id="L173" title="All 2 branches covered.">		for (var superType : hierarchy)</span>
<span class="fc bfc" id="L174" title="All 2 branches covered.">			if (superType.erasedClass() == erasedClass)</span>
<span class="fc" id="L175">				return superType;</span>

<span class="fc" id="L177">		throw new IllegalArgumentException(</span>
<span class="fc" id="L178">				printType(referentType) + &quot; not present in type hierarchy for &quot; + referrerType + &quot;; &quot; + hierarchy);</span>
	}

	private TypeUtils() {
	}

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.10.202304240956</span></div></body></html>