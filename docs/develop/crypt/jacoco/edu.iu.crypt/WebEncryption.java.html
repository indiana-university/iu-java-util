<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>WebEncryption.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">IU Web Cryptography Utilities</a> &gt; <a href="index.source.html" class="el_package">edu.iu.crypt</a> &gt; <span class="el_source">WebEncryption.java</span></div><h1>WebEncryption.java</h1><pre class="source lang-java linenums">/*
 * Copyright Â© 2024 Indiana University
 * All rights reserved.
 *
 * BSD 3-Clause License
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 
 * - Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 * 
 * - Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 * 
 * - Neither the name of the copyright holder nor the names of its
 *   contributors may be used to endorse or promote products derived from
 *   this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package edu.iu.crypt;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.InputStream;
import java.io.OutputStream;
import java.util.stream.Stream;

import edu.iu.IuText;
import edu.iu.client.IuJsonAdapter;
import edu.iu.crypt.WebCryptoHeader.Param;
import edu.iu.crypt.WebKey.Algorithm;
import iu.crypt.Jwe;
import iu.crypt.JweBuilder;

/**
 * Unifies algorithm support and maps from JCE encryption to JSON Web Encryption
 * (JWE).
 * 
 * @see &lt;a href=&quot;https://datatracker.ietf.org/doc/html/rfc7516&quot;&gt;RFC 7516&lt;/a&gt;
 */
public interface WebEncryption {

	/**
	 * Enumerates content encryption algorithms.
	 */
<span class="fc" id="L58">	enum Encryption {</span>

		/**
		 * AES_128_CBC_HMAC_SHA_256 authenticated encryption algorithm.
		 * 
		 * @see &lt;a href=
		 *      &quot;https://datatracker.ietf.org/doc/html/rfc7518#section-5.2.3&quot;&gt;RFC-7518
		 *      Section 5.2.3&lt;/a&gt;
		 */
<span class="fc" id="L67">		AES_128_CBC_HMAC_SHA_256(&quot;A128CBC-HS256&quot;, 256, &quot;AES/CBC/PKCS5Padding&quot;, &quot;HmacSHA256&quot;),</span>

		/**
		 * AES_192_CBC_HMAC_SHA_384 authenticated encryption algorithm.
		 * 
		 * @see &lt;a href=
		 *      &quot;https://datatracker.ietf.org/doc/html/rfc7518#section-5.2.3&quot;&gt;RFC-7518
		 *      Section 5.2.3&lt;/a&gt;
		 */
<span class="fc" id="L76">		AES_192_CBC_HMAC_SHA_384(&quot;A192CBC-HS384&quot;, 384, &quot;AES/CBC/PKCS5Padding&quot;, &quot;HmacSHA384&quot;),</span>

		/**
		 * AES_256_CBC_HMAC_SHA_512 authenticated encryption algorithm.
		 * 
		 * @see &lt;a href=
		 *      &quot;https://datatracker.ietf.org/doc/html/rfc7518#section-5.2.3&quot;&gt;RFC-7518
		 *      Section 5.2.3&lt;/a&gt;
		 */
<span class="fc" id="L85">		AES_256_CBC_HMAC_SHA_512(&quot;A256CBC-HS512&quot;, 512, &quot;AES/CBC/PKCS5Padding&quot;, &quot;HmacSHA512&quot;),</span>

		/**
		 * AES-128 GCM.
		 */
<span class="fc" id="L90">		A128GCM(&quot;A128GCM&quot;, 128, &quot;AES/GCM/NoPadding&quot;, null),</span>

		/**
		 * AES-192 GCM.
		 */
<span class="fc" id="L95">		A192GCM(&quot;A192GCM&quot;, 192, &quot;AES/GCM/NoPadding&quot;, null),</span>

		/**
		 * AES-256 GCM.
		 */
<span class="fc" id="L100">		A256GCM(&quot;A256GCM&quot;, 256, &quot;AES/GCM/NoPadding&quot;, null);</span>

		/**
		 * JSON type adapter
		 */
<span class="fc" id="L105">		public static final IuJsonAdapter&lt;Encryption&gt; JSON = IuJsonAdapter.text(Encryption::from, e -&gt; e.enc);</span>

		/**
		 * Selects encryption by JOSE enc parameter value.
		 * 
		 * @param enc JOSE parameter value
		 * @return encryption
		 */
		public static Encryption from(String enc) {
<span class="fc" id="L114">			return Stream.of(Encryption.values()).filter(a -&gt; a.enc.equals(enc)).findFirst().get();</span>
		}

		/**
		 * JOSE enc attribute value.
		 */
		public final String enc;

		/**
		 * CEK size, in bits.
		 */
		public final int size;

		/**
		 * JCE Cipher algorithm.
		 */
		public final String algorithm;

		/**
		 * JCE MAC algorithm.
		 */
		public final String mac;

<span class="fc" id="L137">		private Encryption(String enc, int size, String algorithm, String mac) {</span>
<span class="fc" id="L138">			this.enc = enc;</span>
<span class="fc" id="L139">			this.size = size;</span>
<span class="fc" id="L140">			this.algorithm = algorithm;</span>
<span class="fc" id="L141">			this.mac = mac;</span>
<span class="fc" id="L142">		}</span>
	}

	/**
	 * Prepares a new encrypted message.
	 */
	interface Builder {
		/**
		 * Protects all header parameters except jwk and verifies inputs are valid for
		 * JWE compact serialization.
		 * 
		 * @return this
		 */
		Builder compact();

		/**
		 * Defines standard protected header parameters.
		 * 
		 * @param params protected header parameters
		 * @return this
		 */
		Builder protect(Param... params);

		/**
		 * Defines extended protected header parameters.
		 * 
		 * @param params protected header parameter names
		 * @return this
		 */
		Builder protect(String... params);

		/**
		 * Provides additional authentication data for protecting the encrypted content.
		 * 
		 * @param additionalData additional authentication data
		 * @return this
		 */
		Builder aad(byte[] additionalData);

		/**
		 * Adds a new recipient.
		 * 
		 * @param algorithm key encryption algorithm
		 * @return {@link WebEncryptionRecipient.Builder}
		 */
		WebEncryptionRecipient.Builder&lt;?&gt; addRecipient(Algorithm algorithm);

		/**
		 * Encrypts data for sending to all recipients.
		 * 
		 * @param text data to encrypt
		 * @return encrypted message
		 */
		default WebEncryption encrypt(String text) {
<span class="fc" id="L196">			return encrypt(IuText.utf8(text));</span>
		}

		/**
		 * Encrypts data for sending to all recipients.
		 * 
		 * @param data data to encrypt
		 * @return encrypted message
		 */
		default WebEncryption encrypt(byte[] data) {
<span class="fc" id="L206">			return encrypt(new ByteArrayInputStream(data));</span>
		}

		/**
		 * Encrypts data for sending to all recipients.
		 * 
		 * @param in stream of data to encrypt
		 * @return encrypted message
		 */
		WebEncryption encrypt(InputStream in);
	}

	/**
	 * Starts a new encrypted message for a single recipient with
	 * {@link Builder#compact() compact semantics} and compression enabled.
	 * 
	 * @param encryption {@link Encryption content encryption algorithm}
	 * @param algorithm  {@link Algorithm key encryption algorithm}
	 * 
	 * @return {@link WebEncryptionRecipient.Builder}
	 */
	static WebEncryptionRecipient.Builder&lt;?&gt; to(Encryption encryption, Algorithm algorithm) {
<span class="fc" id="L228">		return builder(encryption, true).compact().addRecipient(algorithm);</span>
	}

	/**
	 * Starts a new encrypted message with compression enabled.
	 * 
	 * @param encryption {@link Encryption encryption algorithm}
	 * 
	 * @return {@link Builder}
	 */
	static Builder builder(Encryption encryption) {
<span class="fc" id="L239">		return builder(encryption, true);</span>
	}

	/**
	 * Starts a new encrypted message.
	 * 
	 * @param encryption {@link Encryption encryption algorithm}
	 * @param deflate    true to compress content; false to encrypt without
	 *                   compression
	 * 
	 * @return {@link Builder}
	 */
	static Builder builder(Encryption encryption, boolean deflate) {
<span class="fc" id="L252">		return new JweBuilder(encryption, deflate);</span>
	}

	/**
	 * Parses a compact or serialized JWE.
	 * 
	 * @param jwe compact or serialized JWE
	 * @return {@link WebEncryption}
	 */
	static WebEncryption parse(String jwe) {
<span class="fc" id="L262">		return new Jwe(jwe);</span>
	}

	/**
	 * Gets the encryption algorithm.
	 * 
	 * @return encryption algorithm
	 */
	Encryption getEncryption();

	/**
	 * Determines whether or not to compress content before encryption.
	 * 
	 * @return true to compress content before encrypting; false to encrypt as-is
	 */
	boolean isDeflate();

	/**
	 * Gets the recipients.
	 * 
	 * @return recipients
	 */
	Stream&lt;? extends WebEncryptionRecipient&gt; getRecipients();
	
	/**
	 * Gets the iv JWE attribute
	 * 
	 * @return iv JWE attribute
	 */
	byte[] getInitializationVector();

	/**
	 * Gets the ciphertext JWE attribute
	 * 
	 * @return ciphertext JWE attribute
	 */
	byte[] getCipherText();

	/**
	 * Gets the tag JWE attribute
	 * 
	 * @return tag JWE attribute
	 */
	byte[] getAuthenticationTag();

	/**
	 * Gets the aad JWE attribute
	 * 
	 * @return aad JWE attribute
	 */
	byte[] getAdditionalData();

	/**
	 * Decrypts UTF-8 encoded encrypted content.
	 * 
	 * @param key private or secret key; &lt;em&gt;should&lt;/em&gt; be verified by the
	 *            application as correct for the recipient before calling.
	 * @return decrypted content
	 */
	default String decryptText(WebKey key) {
<span class="fc" id="L322">		return IuText.utf8(decrypt(key));</span>
	}

	/**
	 * Decrypts the encrypted content.
	 * 
	 * @param key private or secret key; &lt;em&gt;should&lt;/em&gt; be verified by the
	 *            application as correct for the recipient before calling.
	 * @return decrypted content
	 */
	default byte[] decrypt(WebKey key) {
<span class="fc" id="L333">		final var out = new ByteArrayOutputStream();</span>
<span class="fc" id="L334">		decrypt(key, out);</span>
<span class="fc" id="L335">		return out.toByteArray();</span>
	}

	/**
	 * Decrypts the encrypted content.
	 * 
	 * @param key private or secret key; &lt;em&gt;should&lt;/em&gt; be verified by the
	 *            application as correct for the recipient before calling.
	 * @param out {@link OutputStream} to write the decrypted content to
	 */
	void decrypt(WebKey key, OutputStream out);

	/**
	 * Gets the message encrypted for only this recipient in compact JWE format.
	 * 
	 * @return compact JWE
	 */
	String compact();

	/**
	 * Gets the encrypted message in serialized JWE format.
	 * 
	 * @return serialized JWE
	 */
	@Override
	String toString();

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.10.202304240956</span></div></body></html>