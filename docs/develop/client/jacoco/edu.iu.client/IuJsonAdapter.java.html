<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>IuJsonAdapter.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">IU HTTP Client Utilities</a> &gt; <a href="index.source.html" class="el_package">edu.iu.client</a> &gt; <span class="el_source">IuJsonAdapter.java</span></div><h1>IuJsonAdapter.java</h1><pre class="source lang-java linenums">/*
 * Copyright Â© 2024 Indiana University
 * All rights reserved.
 *
 * BSD 3-Clause License
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 
 * - Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 * 
 * - Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 * 
 * - Neither the name of the copyright holder nor the names of its
 *   contributors may be used to endorse or promote products derived from
 *   this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package edu.iu.client;

import java.lang.reflect.GenericArrayType;
import java.lang.reflect.ParameterizedType;
import java.lang.reflect.Type;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.net.URI;
import java.net.URL;
import java.time.Duration;
import java.time.Instant;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.LocalTime;
import java.time.OffsetDateTime;
import java.time.OffsetTime;
import java.time.Period;
import java.time.ZoneId;
import java.time.ZoneOffset;
import java.time.ZonedDateTime;
import java.time.temporal.Temporal;
import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Collection;
import java.util.Date;
import java.util.Deque;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.NavigableSet;
import java.util.Optional;
import java.util.Properties;
import java.util.Queue;
import java.util.Set;
import java.util.SimpleTimeZone;
import java.util.SortedMap;
import java.util.SortedSet;
import java.util.TimeZone;
import java.util.TreeMap;
import java.util.TreeSet;
import java.util.function.Function;
import java.util.regex.Pattern;
import java.util.stream.Stream;

import edu.iu.IuText;
import iu.client.JsonAdapters;
import iu.client.JsonSerializer;
import iu.client.ParsingJsonAdapter;
import jakarta.json.JsonArray;
import jakarta.json.JsonArrayBuilder;
import jakarta.json.JsonNumber;
import jakarta.json.JsonObject;
import jakarta.json.JsonObjectBuilder;
import jakarta.json.JsonString;
import jakarta.json.JsonStructure;
import jakarta.json.JsonValue;

/**
 * Adapts JSON values to equivalent Java types.
 * 
 * @param &lt;T&gt; target type, &lt;em&gt;may&lt;/em&gt; be unchecked
 */
public interface IuJsonAdapter&lt;T&gt; {

	/**
	 * Creates a functional JSON type adapter.
	 * 
	 * @param fromJson function that converts from JSON to the target type
	 * @param &lt;T&gt;      target type
	 * @return functional adapter
	 */
	static &lt;T&gt; IuJsonAdapter&lt;T&gt; from(Function&lt;JsonValue, T&gt; fromJson) {
<span class="fc" id="L110">		return new IuJsonAdapter&lt;T&gt;() {</span>
			@Override
			public T fromJson(JsonValue jsonValue) {
<span class="fc" id="L113">				return fromJson.apply(jsonValue);</span>
			}

			@Override
			public JsonValue toJson(T javaValue) {
<span class="fc" id="L118">				throw new UnsupportedOperationException();</span>
			}
		};
	}

	/**
	 * Creates a functional JSON type adapter for text conversion.
	 * 
	 * @param parser parsing function
	 * @param &lt;T&gt;    target type
	 * @return functional adapter
	 */
	static &lt;T&gt; IuJsonAdapter&lt;T&gt; text(Function&lt;String, T&gt; parser) {
<span class="fc" id="L131">		return text(parser, T::toString);</span>
	}

	/**
	 * Creates a functional JSON type adapter.
	 * 
	 * @param parser parsing function
	 * @param print  printing function
	 * @param &lt;T&gt;    target type
	 * @return functional adapter
	 */
	static &lt;T&gt; IuJsonAdapter&lt;T&gt; text(Function&lt;String, T&gt; parser, Function&lt;T, String&gt; print) {
<span class="fc" id="L143">		return new ParsingJsonAdapter&lt;&gt;(parser, print);</span>
	}

	/**
	 * Creates a functional JSON type adapter.
	 * 
	 * @param toJson function that converts from the target type to JSON
	 * @param &lt;T&gt;    target type
	 * @return functional adapter
	 */
	static &lt;T&gt; IuJsonAdapter&lt;T&gt; to(Function&lt;T, JsonValue&gt; toJson) {
<span class="fc" id="L154">		return new IuJsonAdapter&lt;T&gt;() {</span>
			@Override
			public T fromJson(JsonValue jsonValue) {
<span class="fc" id="L157">				throw new UnsupportedOperationException();</span>
			}

			@Override
			public JsonValue toJson(T javaValue) {
<span class="fc" id="L162">				return toJson.apply(javaValue);</span>
			}
		};
	}

	/**
	 * Creates a functional JSON type adapter.
	 * 
	 * @param fromJson function that converts from JSON to the target type
	 * @param toJson   function that converts from the target type to JSON
	 * @param &lt;T&gt;      target type
	 * @return functional adapter
	 */
	static &lt;T&gt; IuJsonAdapter&lt;T&gt; from(Function&lt;JsonValue, T&gt; fromJson, Function&lt;T, JsonValue&gt; toJson) {
<span class="fc" id="L176">		return new IuJsonAdapter&lt;T&gt;() {</span>
			@Override
			public T fromJson(JsonValue jsonValue) {
<span class="fc" id="L179">				return fromJson.apply(jsonValue);</span>
			}

			@Override
			public JsonValue toJson(T javaValue) {
<span class="fc" id="L184">				return toJson.apply(javaValue);</span>
			}
		};
	}

	/**
	 * Creates a JSON type adapter that converts from a JavaBeans business object
	 * type to and from JSON.
	 * 
	 * @param &lt;T&gt;                business object type
	 * @param type               business object class; &lt;em&gt;must&lt;/em&gt; be an
	 *                           interface to convert from JSON, an interface is
	 *                           &lt;em&gt;not required&lt;/em&gt; to convert from JSON.
	 * @param propertyNameFormat property name format to use for converting to JSON
	 * @param valueAdapter       value adapter function
	 * @return {@link IuJsonAdapter}
	 */
	static &lt;T&gt; IuJsonAdapter&lt;T&gt; from(Class&lt;T&gt; type, IuJsonPropertyNameFormat propertyNameFormat,
			Function&lt;Type, IuJsonAdapter&lt;?&gt;&gt; valueAdapter) {
<span class="fc" id="L203">		return from(v -&gt; IuJson.wrap(v.asJsonObject(), type, valueAdapter),</span>
<span class="fc" id="L204">				v -&gt; JsonSerializer.serialize(type, v, propertyNameFormat, valueAdapter));</span>
	}

	/**
	 * Provides a basic JSON type adapter.
	 * 
	 * &lt;p&gt;
	 * Returns an adapter that:
	 * &lt;/p&gt;
	 * &lt;ul&gt;
	 * &lt;li&gt;Handles undefined (null) JSON values as null&lt;/li&gt;
	 * &lt;li&gt;Returns {@link JsonValue} as-is&lt;/li&gt;
	 * &lt;li&gt;Builds {@link JsonObjectBuilder} and {@link JsonArrayBuilder} if provided
	 * to {@link #toJson(Object)} as Java values&lt;/li&gt;
	 * &lt;li&gt;Converts between null and {@link JsonValue#NULL}&lt;/li&gt;
	 * &lt;li&gt;Converts between {@link Boolean} and
	 * {@link JsonValue#TRUE}/{@link JsonValue#FALSE}&lt;/li&gt;
	 * &lt;li&gt;Converts between {@link String} and {@link JsonString}&lt;/li&gt;
	 * &lt;li&gt;Converts between {@link Number} and {@link JsonNumber},
	 * {@link #fromJson(JsonValue)} returns {@link BigDecimal}&lt;/li&gt;
	 * &lt;li&gt;Converts between {@link List List&amp;lt;?&amp;gt;} and {@link JsonArray}, with
	 * recursive item conversion&lt;/li&gt;
	 * &lt;li&gt;Converts between {@link Map Map&amp;lt;String, ?&amp;gt;} and {@link JsonObject},
	 * with recursive conversion&lt;/li&gt;
	 * &lt;li&gt;Converts irreversibly to {@link JsonValue} for other types listed in
	 * {@link #of(Class)}.&lt;/li&gt;
	 * &lt;/ul&gt;
	 * 
	 * &lt;p&gt;
	 * Equivalent to {@link #of(Class) of(Object.class)}
	 * &lt;/p&gt;
	 * 
	 * @param &lt;T&gt; target type, &lt;em&gt;may&lt;/em&gt; be used for unchecked cast to a one of
	 *            the types listed above. For full generic type support and two-way
	 *            conversion use {@link #of(Class)}
	 * @return {@link IuJsonAdapter}
	 * @throws ClassCastException (potentially upstream) If the target type doesn't
	 *                            match the return type
	 */
	@SuppressWarnings(&quot;unchecked&quot;)
	static &lt;T&gt; IuJsonAdapter&lt;T&gt; basic() {
<span class="fc" id="L245">		return JsonAdapters.adapt(Object.class, null);</span>
	}

	/**
	 * Provides a JSON type adapter for the erasure of a generic type.
	 * 
	 * &lt;p&gt;
	 * The adapter returned is aware of {@link ParameterizedType} and
	 * {@link GenericArrayType} arguments indicating item, component, and value
	 * types. All types referenced by generic type arguments must be included in the
	 * list below.
	 * &lt;/p&gt;
	 * 
	 * &lt;p&gt;
	 * Supports:
	 * &lt;/p&gt;
	 * &lt;ul&gt;
	 * &lt;li&gt;{@link Boolean} and {@link Boolean#TYPE boolean}&lt;/li&gt;
	 * &lt;li&gt;{@link Object}, see {@link #basic()} for Object conversion rules&lt;/li&gt;
	 * &lt;li&gt;{@link Void} and {@link Void#TYPE void}, supporting only null values&lt;/li&gt;
	 * &lt;li&gt;{@link #toJson(Object)} as {@link JsonNumber}
	 * &lt;ul&gt;
	 * &lt;li&gt;{@link BigDecimal}&lt;/li&gt;
	 * &lt;li&gt;{@link Byte} and {@link Byte#TYPE byte}&lt;/li&gt;
	 * &lt;li&gt;{@link Double} and {@link Double#TYPE byte}&lt;/li&gt;
	 * &lt;li&gt;{@link Float} and {@link Float#TYPE byte}&lt;/li&gt;
	 * &lt;li&gt;{@link Integer} and {@link Integer#TYPE int}&lt;/li&gt;
	 * &lt;li&gt;{@link Long} and {@link Long#TYPE long}&lt;/li&gt;
	 * &lt;li&gt;{@link Number}, as {@link BigDecimal}&lt;/li&gt;
	 * &lt;li&gt;{@link Short} and {@link Short#TYPE short}&lt;/li&gt;
	 * &lt;/ul&gt;
	 * &lt;/li&gt;
	 * &lt;li&gt;{@link #toJson(Object)} returns {@link JsonString}
	 * &lt;ul&gt;
	 * &lt;li&gt;byte[], via {@link IuText#base64(String)} and
	 * {@link IuText#base64(byte[])}&lt;/li&gt;
	 * &lt;li&gt;{@link BigInteger}&lt;/li&gt;
	 * &lt;li&gt;{@link CharSequence}&lt;/li&gt;
	 * &lt;li&gt;{@link Calendar}, as {@link Date}&lt;/li&gt;
	 * &lt;li&gt;{@link CharSequence}, as {@link String}&lt;/li&gt;
	 * &lt;li&gt;{@link Date}, as {@link Temporal}&lt;/li&gt;
	 * &lt;li&gt;{@link Duration}&lt;/li&gt;
	 * &lt;li&gt;{@link Enum} subtypes&lt;/li&gt;
	 * &lt;li&gt;{@link Instant}&lt;/li&gt;
	 * &lt;li&gt;{@link LocalDate}&lt;/li&gt;
	 * &lt;li&gt;{@link LocalTime}&lt;/li&gt;
	 * &lt;li&gt;{@link LocalDateTime}&lt;/li&gt;
	 * &lt;li&gt;{@link OffsetDateTime}&lt;/li&gt;
	 * &lt;li&gt;{@link OffsetTime}&lt;/li&gt;
	 * &lt;li&gt;{@link Optional}&lt;/li&gt;
	 * &lt;li&gt;{@link Period}&lt;/li&gt;
	 * &lt;li&gt;{@link SimpleTimeZone}&lt;/li&gt;
	 * &lt;li&gt;{@link String}&lt;/li&gt;
	 * &lt;li&gt;{@link Pattern}&lt;/li&gt;
	 * &lt;li&gt;{@link TimeZone}&lt;/li&gt;
	 * &lt;li&gt;{@link URI}&lt;/li&gt;
	 * &lt;li&gt;{@link URL}&lt;/li&gt;
	 * &lt;li&gt;{@link ZonedDateTime}&lt;/li&gt;
	 * &lt;li&gt;{@link ZoneId}&lt;/li&gt;
	 * &lt;li&gt;{@link ZoneOffset}&lt;/li&gt;
	 * &lt;/ul&gt;
	 * &lt;/li&gt;
	 * &lt;li&gt;{@link #toJson(Object)} as {@link JsonArray}
	 * &lt;ul&gt;
	 * &lt;li&gt;{@link Class#isArray() Array} type&lt;/li&gt;
	 * &lt;li&gt;{@link ArrayList}&lt;/li&gt;
	 * &lt;li&gt;{@link Collection}, as {@link Queue}&lt;/li&gt;
	 * &lt;li&gt;{@link Deque}, as {@link ArrayDeque}&lt;/li&gt;
	 * &lt;li&gt;{@link Enumeration}&lt;/li&gt;
	 * &lt;li&gt;{@link HashSet}&lt;/li&gt;
	 * &lt;li&gt;{@link Iterable}, as {@link Collection}&lt;/li&gt;
	 * &lt;li&gt;{@link Iterator}&lt;/li&gt;
	 * &lt;li&gt;{@link LinkedHashSet}&lt;/li&gt;
	 * &lt;li&gt;{@link List}, as {@link ArrayList}&lt;/li&gt;
	 * &lt;li&gt;{@link NavigableSet}, as {@link TreeSet}&lt;/li&gt;
	 * &lt;li&gt;{@link Queue}, as {@link Deque}&lt;/li&gt;
	 * &lt;li&gt;{@link Set}, as {@link LinkedHashSet}&lt;/li&gt;
	 * &lt;li&gt;{@link SortedSet}, as {@link NavigableSet}&lt;/li&gt;
	 * &lt;li&gt;{@link Properties}, enforces values as {@link String}&lt;/li&gt;
	 * &lt;li&gt;{@link TreeSet}&lt;/li&gt;
	 * &lt;li&gt;{@link Stream}&lt;/li&gt;
	 * &lt;/ul&gt;
	 * &lt;/li&gt;
	 * &lt;li&gt;{@link #toJson(Object)} as {@link JsonObject}:
	 * &lt;ul&gt;
	 * &lt;li&gt;{@link LinkedHashMap}&lt;/li&gt;
	 * &lt;li&gt;{@link HashMap}&lt;/li&gt;
	 * &lt;li&gt;{@link Map}, as {@link LinkedHashMap}&lt;/li&gt;
	 * &lt;li&gt;{@link SortedMap}, as {@link TreeMap}&lt;/li&gt;
	 * &lt;li&gt;{@link Properties}&lt;/li&gt;
	 * &lt;li&gt;{@link TreeMap}&lt;/li&gt;
	 * &lt;/ul&gt;
	 * &lt;/li&gt;
	 * &lt;/ul&gt;
	 * 
	 * @param &lt;T&gt;  target type
	 * @param type target type
	 * @return {@link IuJsonAdapter}
	 */
	@SuppressWarnings(&quot;unchecked&quot;)
	static &lt;T&gt; IuJsonAdapter&lt;T&gt; of(Type type) {
<span class="fc" id="L346">		return JsonAdapters.adapt(type, null);</span>
	}

	/**
	 * Provides a standard JSON type adapter for a Java value.
	 * 
	 * @param &lt;T&gt;  target type
	 * @param type target type
	 * @return {@link IuJsonAdapter}
	 * @see #of(Type)
	 */
	@SuppressWarnings(&quot;unchecked&quot;)
	static &lt;T&gt; IuJsonAdapter&lt;T&gt; of(Class&lt;T&gt; type) {
<span class="fc" id="L359">		return JsonAdapters.adapt((Type) type, null);</span>
	}

	/**
	 * Provides a JSON type adapter that delegates to another adapter for
	 * parameterized values.
	 * 
	 * @param &lt;T&gt;          target type
	 * @param type         target type
	 * @param valueAdapter Value type adapter for {@link JsonStructure} conversion,
	 *                     may be null if the Java type doesn't declare parameters,
	 *                     or to use a standard value adapter
	 * @return {@link IuJsonAdapter}
	 * @see #of(Type)
	 */
	static &lt;T&gt; IuJsonAdapter&lt;T&gt; of(Class&lt;? super T&gt; type, IuJsonAdapter&lt;?&gt; valueAdapter) {
<span class="fc" id="L375">		return of(type, a -&gt; valueAdapter);</span>
	}

	/**
	 * Provides a JSON type adapter that delegates to another adapter for
	 * parameterized values.
	 * 
	 * @param &lt;T&gt;          target type
	 * @param type         target type
	 * @param valueAdapter Factory function for supplying a value type adapter for
	 *                     {@link JsonStructure} conversion based on the item type.
	 * @return {@link IuJsonAdapter}
	 * @see #of(Type)
	 */
	@SuppressWarnings(&quot;unchecked&quot;)
	static &lt;T&gt; IuJsonAdapter&lt;T&gt; of(Type type, Function&lt;Class&lt;?&gt;, IuJsonAdapter&lt;?&gt;&gt; valueAdapter) {
<span class="fc" id="L391">		return JsonAdapters.adapt(type, valueAdapter);</span>
	}

	/**
	 * Converts a JSON parameter value to its Java equivalent.
	 * 
	 * @param jsonValue JSON value
	 * @return Java equivalent
	 */
	T fromJson(JsonValue jsonValue);

	/**
	 * Converts a value to its JSON equivalent.
	 * 
	 * @param value value
	 * @return JSON equivalent
	 */
	JsonValue toJson(T value);

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.10.202304240956</span></div></body></html>