<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>WebCryptoHeader.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">IU Java Utilities API Reference</a> &gt; <a href="../index.html" class="el_bundle">iu-java-crypt</a> &gt; <a href="index.source.html" class="el_package">edu.iu.crypt</a> &gt; <span class="el_source">WebCryptoHeader.java</span></div><h1>WebCryptoHeader.java</h1><pre class="source lang-java linenums">/*
 * Copyright Â© 2024 Indiana University
 * All rights reserved.
 *
 * BSD 3-Clause License
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 
 * - Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 * 
 * - Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 * 
 * - Neither the name of the copyright holder nor the names of its
 *   contributors may be used to endorse or promote products derived from
 *   this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package edu.iu.crypt;

import java.net.URI;
import java.util.Collections;
import java.util.EnumSet;
import java.util.Objects;
import java.util.Set;
import java.util.function.Function;

import edu.iu.IuIterable;
import edu.iu.IuObject;
import edu.iu.crypt.WebKey.Algorithm;
import edu.iu.crypt.WebKey.Use;

/**
 * Unifies algorithm support and maps cryptographic header data from JCE to JSON
 * Object Signing and Encryption (JOSE).
 * 
 * @see &lt;a href=&quot;https://datatracker.ietf.org/doc/html/rfc7517&quot;&gt;JSON Web Key
 *      (JWK) RFC-7517&lt;/a&gt;
 */
public interface WebCryptoHeader extends WebCertificateReference {

	/**
	 * Enumerates standard header parameters.
	 */
<span class="fc" id="L58">	enum Param {</span>
		/**
		 * Encryption/signature algorithm.
		 */
<span class="fc" id="L62">		ALGORITHM(&quot;alg&quot;, EnumSet.allOf(Use.class), true, WebCryptoHeader::getAlgorithm),</span>

		/**
		 * Well-known key identifier.
		 */
<span class="fc" id="L67">		KEY_ID(&quot;kid&quot;, EnumSet.allOf(Use.class), false, WebCryptoHeader::getKeyId),</span>

		/**
		 * Well-known key set URI.
		 */
<span class="fc" id="L72">		KEY_SET_URI(&quot;jku&quot;, EnumSet.allOf(Use.class), false, WebCryptoHeader::getKeySetUri),</span>

		/**
		 * Well-known public key.
		 */
<span class="fc" id="L77">		KEY(&quot;jwk&quot;, EnumSet.allOf(Use.class), false, WebCryptoHeader::getKey),</span>

		/**
		 * Certificate chain URI.
		 */
<span class="fc" id="L82">		CERTIFICATE_URI(&quot;x5u&quot;, EnumSet.allOf(Use.class), false, WebCryptoHeader::getCertificateUri),</span>

		/**
		 * Certificate chain.
		 */
<span class="fc" id="L87">		CERTIFICATE_CHAIN(&quot;x5c&quot;, EnumSet.allOf(Use.class), false, WebCryptoHeader::getCertificateChain),</span>

		/**
		 * Certificate SHA-1 thumb print.
		 */
<span class="fc" id="L92">		CERTIFICATE_THUMBPRINT(&quot;x5t&quot;, EnumSet.allOf(Use.class), false, WebCryptoHeader::getCertificateThumbprint),</span>

		/**
		 * Certificate SHA-1 thumb print.
		 */
<span class="fc" id="L97">		CERTIFICATE_SHA256_THUMBPRINT(&quot;x5t#S256&quot;, EnumSet.allOf(Use.class), false,</span>
				WebCryptoHeader::getCertificateSha256Thumbprint),

		/**
		 * Signature/encryption media type.
		 */
<span class="fc" id="L103">		TYPE(&quot;typ&quot;, EnumSet.allOf(Use.class), false, WebCryptoHeader::getType),</span>

		/**
		 * Content media type.
		 */
<span class="fc" id="L108">		CONTENT_TYPE(&quot;cty&quot;, EnumSet.allOf(Use.class), false, WebCryptoHeader::getContentType),</span>

		/**
		 * Extended parameter names that &lt;em&gt;must&lt;/em&gt; be included in the protected
		 * header.
		 */
<span class="fc" id="L114">		CRITICAL_PARAMS(&quot;crit&quot;, EnumSet.allOf(Use.class), false, WebCryptoHeader::getCriticalParameters),</span>

		/**
		 * Content encryption algorithm.
		 */
<span class="fc" id="L119">		ENCRYPTION(&quot;enc&quot;, EnumSet.of(Use.ENCRYPT), true, a -&gt; a.getExtendedParameter(&quot;enc&quot;)),</span>

		/**
		 * Plain-text compression algorithm for encryption.
		 */
<span class="fc" id="L124">		ZIP(&quot;zip&quot;, EnumSet.of(Use.ENCRYPT), false, a -&gt; a.getExtendedParameter(&quot;zip&quot;)),</span>

		/**
		 * Ephemeral public key for key agreement algorithms.
		 * 
		 * @see Algorithm#ECDH_ES
		 * @see Algorithm#ECDH_ES_A128KW
		 * @see Algorithm#ECDH_ES_A192KW
		 * @see Algorithm#ECDH_ES_A256KW
		 */
<span class="fc" id="L134">		EPHEMERAL_PUBLIC_KEY(&quot;epk&quot;, EnumSet.of(Use.ENCRYPT), true, a -&gt; a.getExtendedParameter(&quot;epk&quot;)),</span>

		/**
		 * Public originator identifier (PartyUInfo) for key derivation.
		 * 
		 * @see Algorithm#ECDH_ES
		 * @see Algorithm#ECDH_ES_A128KW
		 * @see Algorithm#ECDH_ES_A192KW
		 * @see Algorithm#ECDH_ES_A256KW
		 */
<span class="fc" id="L144">		PARTY_UINFO(&quot;apu&quot;, EnumSet.of(Use.ENCRYPT), false, a -&gt; a.getExtendedParameter(&quot;apu&quot;)),</span>

		/**
		 * Public recipient identifier (PartyVInfo) for key derivation.
		 * 
		 * @see Algorithm#ECDH_ES
		 * @see Algorithm#ECDH_ES_A128KW
		 * @see Algorithm#ECDH_ES_A192KW
		 * @see Algorithm#ECDH_ES_A256KW
		 */
<span class="fc" id="L154">		PARTY_VINFO(&quot;apv&quot;, EnumSet.of(Use.ENCRYPT), false, a -&gt; a.getExtendedParameter(&quot;apv&quot;)),</span>

		/**
		 * Initialization vector for GCM key wrap.
		 * 
		 * @see Algorithm#A128GCMKW
		 * @see Algorithm#A192GCMKW
		 * @see Algorithm#A256GCMKW
		 */
<span class="fc" id="L163">		INITIALIZATION_VECTOR(&quot;iv&quot;, EnumSet.of(Use.ENCRYPT), true, a -&gt; a.getExtendedParameter(&quot;iv&quot;)),</span>

		/**
		 * Authentication tag for GCM key wrap.
		 * 
		 * @see Algorithm#A128GCMKW
		 * @see Algorithm#A192GCMKW
		 * @see Algorithm#A256GCMKW
		 */
<span class="fc" id="L172">		TAG(&quot;tag&quot;, Set.of(Use.ENCRYPT), true, a -&gt; a.getExtendedParameter(&quot;tag&quot;)),</span>

		/**
		 * Password salt for use with PBES2.
		 * 
		 * @see Algorithm#PBES2_HS256_A128KW
		 * @see Algorithm#PBES2_HS384_A192KW
		 * @see Algorithm#PBES2_HS512_A256KW
		 */
<span class="fc" id="L181">		PASSWORD_SALT(&quot;p2s&quot;, Set.of(Use.ENCRYPT), true, a -&gt; a.getExtendedParameter(&quot;p2s&quot;)),</span>

		/**
		 * PBKDF2 iteration count for use with PBES2.
		 * 
		 * @see Algorithm#PBES2_HS256_A128KW
		 * @see Algorithm#PBES2_HS384_A192KW
		 * @see Algorithm#PBES2_HS512_A256KW
		 */
<span class="fc" id="L190">		PASSWORD_COUNT(&quot;p2c&quot;, Set.of(Use.ENCRYPT), true, a -&gt; a.getExtendedParameter(&quot;p2c&quot;));</span>

		/**
		 * Gets a parameter by JOSE standard parameter name.
		 * 
		 * @param name JOSE standard name
		 * @return {@link Param}
		 */
		public static Param from(String name) {
<span class="fc" id="L199">			return EnumSet.allOf(Param.class).stream().filter(a -&gt; IuObject.equals(name, a.name)).findFirst()</span>
<span class="fc" id="L200">					.orElse(null);</span>
		}

		/**
		 * JOSE standard parameter name.
		 */
		public final String name;

		/**
		 * Indicates if the parameter name is registered for use with &lt;a href=
		 * &quot;https://datatracker.ietf.org/doc/html/rfc7515#section-4.1&quot;&gt;signature&lt;/a&gt;
		 * and/or &lt;a href=
		 * &quot;https://datatracker.ietf.org/doc/html/rfc7515#section-4.1&quot;&gt;encryption&lt;/a&gt;.
		 */
		private final Set&lt;Use&gt; use;

		/**
		 * Indicates if the parameter is required for this algorithm.
		 */
		public final boolean required;

		private final Function&lt;WebCryptoHeader, ?&gt; get;

<span class="fc" id="L223">		private Param(String name, Set&lt;Use&gt; use, boolean required, Function&lt;WebCryptoHeader, ?&gt; get) {</span>
<span class="fc" id="L224">			this.name = name;</span>
<span class="fc" id="L225">			this.use = Collections.unmodifiableSet(use);</span>
<span class="fc" id="L226">			this.required = required;</span>
<span class="fc" id="L227">			this.get = get;</span>
<span class="fc" id="L228">		}</span>

		/**
		 * Verifies that the header contains a non-null value.
		 * 
		 * @param header header
		 * @return true if the value is present; else false
		 */
		public boolean isPresent(WebCryptoHeader header) {
<span class="fc bfc" id="L237" title="All 2 branches covered.">			return get(header) != null;</span>
		}

		/**
		 * Determines if a header applies to a public JWK use case.
		 * 
		 * @param use public key use
		 * @return true if the header parameter is registered for the public JWK use
		 *         case.
		 */
		public boolean isUsedFor(Use use) {
<span class="fc" id="L248">			return this.use.contains(use);</span>
		}

		/**
		 * Gets the header value.
		 * 
		 * @param header header
		 * @return header value
		 */
		public Object get(WebCryptoHeader header) {
<span class="fc" id="L258">			return get.apply(header);</span>
		}
	}

	/**
	 * Builder interface for creating {@link WebCryptoHeader} instances.
	 * 
	 * @param &lt;B&gt; builder type
	 */
	interface Builder&lt;B extends Builder&lt;B&gt;&gt; {
		/**
		 * Sets the key ID relative to {@link #getKeySetUri()} corresponding to a JWKS
		 * key entry.
		 *
		 * @param keyId key ID
		 * @return this
		 */
		B keyId(String keyId);

		/**
		 * Sets the URI where JWKS well-known key data can be retrieved.
		 * 
		 * @param uri JWKS {@link URI}
		 * @return this
		 */
		B wellKnown(URI uri);

		/**
		 * Sets the key to include with the header.
		 * 
		 * @param key &lt;em&gt;may&lt;/em&gt; include private/secret key data to use for
		 *            encryption/signing; only {@link WebKey#wellKnown()} will be
		 *            included in the header.
		 * @return this
		 */
		B wellKnown(WebKey key);

		/**
		 * The key to use for encrypting or signing.
		 * 
		 * @param key key to use for encryption or signing; will not be included in the
		 *            header. Use {@link #wellKnown(WebKey)} to set the key and include
		 *            well-known component in the header.
		 * @return this
		 */
		B key(WebKey key);

		/**
		 * Sets the header type parameter value.
		 * 
		 * @param type header type parameter value.
		 * @return this
		 */
		B type(String type);

		/**
		 * Sets the header content type parameter value.
		 * 
		 * @param contentType header type parameter value.
		 * @return this
		 */
		B contentType(String contentType);

		/**
		 * Sets critical parameter names.
		 * 
		 * @param parameterNames critical parameter names
		 * @return this
		 */
		B crit(String... parameterNames);

		/**
		 * Sets a registered parameter value
		 * 
		 * @param &lt;T&gt;   value type
		 * @param param parameter
		 * @param value parameter value
		 * @return this
		 */
		&lt;T&gt; B param(Param param, T value);

		/**
		 * Sets an extended parameter value
		 * 
		 * @param &lt;T&gt;   value type
		 * @param name  parameter name
		 * @param value parameter value
		 * @return this
		 */
		&lt;T&gt; B param(String name, T value);
	}

	/**
	 * Returns the protected header from a serialized JWS or JWE.
	 * 
	 * &lt;p&gt;
	 * This method is useful for inspecting header parameters before processing the
	 * signed and/or encrypted payload, e.g., to determine content type or to
	 * identify the correct decryption or verification key.
	 * &lt;/p&gt;
	 * 
	 * @param serialized serialized JWS or JWE
	 * @return protected header
	 */
	public static WebCryptoHeader getProtectedHeader(String serialized) {
<span class="fc" id="L363">		return Init.SPI.getProtectedHeader(serialized);</span>
	}

	/**
	 * Verifies all parameters in a {@link WebCryptoHeader}.
	 * 
	 * @param header {@link WebCryptoHeader}
	 * @return Well-known key referred to by the header; null if not known
	 */
	static WebKey verify(WebCryptoHeader header) {
<span class="fc" id="L373">		final var algorithm = Objects.requireNonNull(header.getAlgorithm(),</span>
<span class="fc" id="L374">				() -&gt; &quot;Signature or key protection algorithm is required&quot;);</span>

<span class="fc bfc" id="L376" title="All 2 branches covered.">		if (algorithm.use.equals(Use.ENCRYPT)) {</span>
<span class="fc" id="L377">			Objects.requireNonNull(header.getExtendedParameter(Param.ENCRYPTION.name),</span>
<span class="fc" id="L378">					() -&gt; &quot;Content encryption algorithm is required&quot;);</span>
<span class="fc bfc" id="L379" title="All 2 branches covered.">			for (final var param : algorithm.encryptionParams)</span>
<span class="fc bfc" id="L380" title="All 2 branches covered.">				if (param.required //</span>
<span class="fc bfc" id="L381" title="All 2 branches covered.">						&amp;&amp; !param.isPresent(header))</span>
<span class="fc" id="L382">					throw new NullPointerException(&quot;Missing required encryption parameter &quot; + param.name);</span>
		}

<span class="fc" id="L385">		final var criticalParameters = header.getCriticalParameters();</span>
<span class="fc bfc" id="L386" title="All 2 branches covered.">		if (criticalParameters != null)</span>
<span class="fc bfc" id="L387" title="All 2 branches covered.">			for (final var paramName : criticalParameters) {</span>
<span class="fc" id="L388">				final var param = Param.from(paramName);</span>
<span class="fc bfc" id="L389" title="All 2 branches covered.">				if (param == null) {</span>
<span class="fc bfc" id="L390" title="All 2 branches covered.">					if (header.getExtendedParameter(paramName) == null)</span>
<span class="fc" id="L391">						throw new NullPointerException(&quot;Missing critical extended parameter &quot; + paramName);</span>
<span class="fc bfc" id="L392" title="All 2 branches covered.">				} else if (!param.isPresent(header))</span>
<span class="fc" id="L393">					throw new NullPointerException(&quot;Missing critical registered parameter &quot; + paramName);</span>
<span class="fc" id="L394">			}</span>

<span class="fc" id="L396">		final var key = header.getKey();</span>
<span class="fc" id="L397">		final var keyId = IuObject.first(header.getKeyId(), IuObject.convert(key, WebKey::getKeyId));</span>
<span class="fc" id="L398">		final var certChain = WebCertificateReference.verify(header);</span>

<span class="fc" id="L400">		var wellKnown = IuObject.convert(key, WebKey::wellKnown);</span>
<span class="fc bfc" id="L401" title="All 4 branches covered.">		if (wellKnown == null //</span>
				&amp;&amp; keyId != null)
<span class="fc" id="L403">			wellKnown = IuObject.convert(header.getKeySetUri(), //</span>
<span class="fc" id="L404">					uri -&gt; IuIterable.filter(WebKey.readJwks(uri), //</span>
<span class="fc" id="L405">							k -&gt; keyId.equals(k.getKeyId())).iterator().next());</span>
<span class="fc bfc" id="L406" title="All 4 branches covered.">		if (wellKnown == null //</span>
				&amp;&amp; certChain != null)
<span class="fc" id="L408">			wellKnown = WebKey.builder(algorithm.type[0]).cert(certChain).build().wellKnown();</span>

<span class="fc" id="L410">		IuObject.first( //</span>
<span class="fc" id="L411">				IuObject.convert(wellKnown, WebKey::getPublicKey), //</span>
<span class="fc" id="L412">				IuObject.convert(certChain, c -&gt; c[0].getPublicKey()));</span>

<span class="fc" id="L414">		return wellKnown;</span>
	}

	/**
	 * Gets the cryptographic algorithm.
	 * 
	 * @return {@link Algorithm}
	 */
	Algorithm getAlgorithm();

	/**
	 * Gets the key ID relative to {@link #getKeySetUri()} corresponding to a JWKS
	 * key entry.
	 * 
	 * @return key ID
	 */
	String getKeyId();

	/**
	 * Gets the URI where JWKS well-known key data can be retrieved.
	 * 
	 * @return {@link URI}
	 */
	URI getKeySetUri();

	/**
	 * Gets the well-known key data.
	 * 
	 * @return {@link WebKey}
	 */
	WebKey getKey();

	/**
	 * Gets the header type parameter value.
	 * 
	 * @return header type parameter value.
	 */
	String getType();

	/**
	 * Gets the header type parameter value.
	 * 
	 * @return header type parameter value.
	 */
	String getContentType();

	/**
	 * Gets the set of critical parameter names.
	 * 
	 * @return critical parameter names
	 */
	Set&lt;String&gt; getCriticalParameters();

	/**
	 * Gets extended parameters.
	 * 
	 * @param &lt;T&gt;  parameter type
	 * @param name parameter name
	 * @return extended parameters
	 */
	&lt;T&gt; T getExtendedParameter(String name);

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.10.202304240956</span></div></body></html>