<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>IuObject.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">IU Java Utilities API Reference</a> &gt; <a href="../index.html" class="el_bundle">iu-java-base</a> &gt; <a href="index.source.html" class="el_package">edu.iu</a> &gt; <span class="el_source">IuObject.java</span></div><h1>IuObject.java</h1><pre class="source lang-java linenums">/*
 * Copyright Â© 2024 Indiana University
 * All rights reserved.
 *
 * BSD 3-Clause License
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 
 * - Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 * 
 * - Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 * 
 * - Neither the name of the copyright holder nor the names of its
 *   contributors may be used to endorse or promote products derived from
 *   this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package edu.iu;

import java.lang.reflect.Array;
import java.time.Duration;
import java.time.Instant;
import java.util.Arrays;
import java.util.Comparator;
import java.util.Iterator;
import java.util.Map;
import java.util.Set;
import java.util.SortedSet;
import java.util.concurrent.TimeoutException;
import java.util.function.BooleanSupplier;
import java.util.function.Supplier;

/**
 * Simplifies building efficient {@link Object#equals(Object)},
 * {@link Object#hashCode()}, and {@link Comparable#compareTo(Object)} methods
 * on plain Java objects.
 * 
 * &lt;p&gt;
 * The use of this utility is preferred, following the examples below, over
 * other methods of generating these methods. When following these examples, the
 * implements can be expected to follow the expected contracts in a null-safe
 * and type-safe manner without undue object creation.
 * &lt;/p&gt;
 * 
 * &lt;dl&gt;
 * &lt;dt&gt;Top level object:&lt;/dt&gt;
 * &lt;dd&gt;
 * 
 * &lt;pre&gt;
 * &amp;#064;Override
 * public int hashCode() {
 * 	return ObjectUtil.hashCode(val1, val2);
 * }
 * 
 * &amp;#064;Override
 * public boolean equals(Object obj) {
 * 	if (!ObjectUtil.typeCheck(this, obj))
 * 		return false;
 * 	MyClass other = (MyClass) obj;
 * 	return ObjectUtil.equals(this.val1, other.val1) &amp;amp;&amp;amp; ObjectUtil.equals(this.val2, other.val2);
 * }
 * 
 * &amp;#064;Override
 * public int compareTo(T o) {
 * 	Integer rv = ObjectUtil.compareNullCheck(this, o);
 * 	if (rv != null)
 * 		return rv;
 * 
 * 	rv = ObjectUtil.compareTo(this.val1, o.val1);
 * 	if (rv != 0)
 * 		return rv;
 * 
 * 	return ObjectUtil.compareTo(this.val2, o.val2);
 * }
 * &lt;/pre&gt;
 * 
 * &lt;/dd&gt;
 * 
 * &lt;dt&gt;Subclass object:&lt;/dt&gt;
 * &lt;dd&gt;
 * 
 * &lt;pre&gt;
 * &amp;#064;Override
 * public int hashCode() {
 * 	return ObjectUtil.hashCodeSuper(super.hashCode(), val1, val2);
 * }
 * 
 * &amp;#064;Override
 * public boolean equals(Object obj) {
 * 	if (!ObjectUtil.typeCheck(this, obj))
 * 		return false;
 * 	MyClass other = (MyClass) obj;
 * 	return super.equals(obj) &amp;amp;&amp;amp; ObjectUtil.equals(this.val1, other.val1) &amp;amp;&amp;amp; ObjectUtil.equals(this.val2, other.val2);
 * }
 * 
 * &amp;#064;Override
 * public int compareTo(T o) {
 * 	Integer rv = ObjectUtil.compareNullCheck(this, o);
 * 	if (rv != null)
 * 		return rv;
 * 
 * 	rv = ObjectUtil.compareTo(this.val1, o.val1);
 * 	if (rv != 0)
 * 		return rv;
 * 
 * 	rv = ObjectUtil.compareTo(this.val2, o.val2);
 * 	if (rv != 0)
 * 		return rv;
 * 
 * 	return super.compareTo(o);
 * }
 * &lt;/pre&gt;
 * 
 * &lt;/dd&gt;
 * &lt;/dl&gt;
 * 
 * @since 4.0
 */
public final class IuObject {

	/**
	 * Determines if a name is relative to a package provided by the JDK or JEE
	 * platform.
	 * 
	 * @param name type name
	 * @return {@code true} if a platform type; else false
	 */
	public static boolean isPlatformName(String name) {
<span class="fc bfc" id="L143" title="All 2 branches covered.">		return name.startsWith(&quot;jakarta.&quot;) // JEE and related</span>
				// JDK packages:
<span class="fc bfc" id="L145" title="All 2 branches covered.">				|| name.startsWith(&quot;sun.&quot;) //</span>
<span class="fc bfc" id="L146" title="All 2 branches covered.">				|| name.startsWith(&quot;com.sun.&quot;) //</span>
<span class="fc bfc" id="L147" title="All 2 branches covered.">				|| name.startsWith(&quot;java.&quot;) //</span>
<span class="fc bfc" id="L148" title="All 2 branches covered.">				|| name.startsWith(&quot;javax.&quot;) //</span>
<span class="fc bfc" id="L149" title="All 2 branches covered.">				|| name.startsWith(&quot;jdk.&quot;) //</span>
<span class="fc bfc" id="L150" title="All 2 branches covered.">				|| name.startsWith(&quot;netscape.javascript.&quot;) //</span>
<span class="fc bfc" id="L151" title="All 2 branches covered.">				|| name.startsWith(&quot;org.ietf.jgss.&quot;) //</span>
<span class="fc bfc" id="L152" title="All 2 branches covered.">				|| name.startsWith(&quot;org.w3c.dom.&quot;) //</span>
<span class="fc bfc" id="L153" title="All 2 branches covered.">				|| name.startsWith(&quot;org.xml.sax.&quot;);</span>
	}

	/**
	 * Perform identity and and null check on two objects, returning a valid value
	 * for {@link Comparable#compareTo(Object)} if any of the checks result in a
	 * conclusive result.
	 * 
	 * @param o1 any object
	 * @param o2 any object
	 * @return 0 if o1 == o2, -1 if o1 is null, 1 if o2 is null; otherwise, return
	 *         null indicating that compareTo should continue to inspect each
	 *         object's specific data.
	 */
	public static Integer compareNullCheck(Object o1, Object o2) {
<span class="fc bfc" id="L168" title="All 2 branches covered.">		if (o1 == o2)</span>
<span class="fc" id="L169">			return 0;</span>
<span class="fc bfc" id="L170" title="All 2 branches covered.">		if (o1 == null)</span>
<span class="fc" id="L171">			return -1;</span>
<span class="fc bfc" id="L172" title="All 2 branches covered.">		if (o2 == null)</span>
<span class="fc" id="L173">			return 1;</span>
<span class="fc" id="L174">		return null;</span>
	}

	/**
	 * Compares two objects with null checks (see
	 * {@link #compareNullCheck(Object, Object)}) and also consistent sort order
	 * based for objects that don't implement {@link Comparable}.
	 * 
	 * @param o1 any object
	 * @param o2 any object
	 * @return Valid {@link Comparator} return value enforcing consistent sort order
	 *         within the same JVM instance.
	 */
	@SuppressWarnings({ &quot;rawtypes&quot;, &quot;unchecked&quot; })
	public static int compareTo(Object o1, Object o2) {
<span class="fc" id="L189">		Integer rv = compareNullCheck(o1, o2);</span>
<span class="fc bfc" id="L190" title="All 2 branches covered.">		if (rv != null)</span>
<span class="fc" id="L191">			return rv;</span>

		Comparable v1;
		Comparable v2;
<span class="fc bfc" id="L195" title="All 4 branches covered.">		if ((o1.getClass() != o2.getClass()) || !(o1 instanceof Comparable)) {</span>
<span class="fc" id="L196">			v1 = (Comparable) Integer.valueOf(o1.hashCode());</span>
<span class="fc" id="L197">			v2 = (Comparable) Integer.valueOf(o2.hashCode());</span>
		} else {
<span class="fc" id="L199">			v1 = (Comparable) o1;</span>
<span class="fc" id="L200">			v2 = (Comparable) o2;</span>
		}

<span class="fc" id="L203">		return v1.compareTo(v2);</span>
	}

	/**
	 * Generates a hash code for a top-level object based on related values (i.e.
	 * field, bean property values, etc).
	 * 
	 * @param oa related values
	 * @return hash code
	 */
	public static int hashCode(Object... oa) {
<span class="fc" id="L214">		return hashCodeSuper(1, oa);</span>
	}

	/**
	 * Generate a hash code for a subclass object based on its parent class' hash
	 * code and related values.
	 * 
	 * @param superHashCode parent class hash code
	 * @param oa            related values
	 * @return hash code
	 */
	public static int hashCodeSuper(int superHashCode, Object... oa) {
<span class="fc" id="L226">		final int prime = 31;</span>
<span class="fc" id="L227">		int result = superHashCode;</span>
<span class="fc bfc" id="L228" title="All 2 branches covered.">		for (Object o : oa) {</span>
			int hash;
<span class="fc bfc" id="L230" title="All 2 branches covered.">			if (o == null)</span>
<span class="fc" id="L231">				hash = 0;</span>
<span class="fc bfc" id="L232" title="All 2 branches covered.">			else if (o instanceof boolean[])</span>
<span class="fc" id="L233">				hash = Arrays.hashCode((boolean[]) o);</span>
<span class="fc bfc" id="L234" title="All 2 branches covered.">			else if (o instanceof byte[])</span>
<span class="fc" id="L235">				hash = Arrays.hashCode((byte[]) o);</span>
<span class="fc bfc" id="L236" title="All 2 branches covered.">			else if (o instanceof char[])</span>
<span class="fc" id="L237">				hash = Arrays.hashCode((char[]) o);</span>
<span class="fc bfc" id="L238" title="All 2 branches covered.">			else if (o instanceof double[])</span>
<span class="fc" id="L239">				hash = Arrays.hashCode((double[]) o);</span>
<span class="fc bfc" id="L240" title="All 2 branches covered.">			else if (o instanceof float[])</span>
<span class="fc" id="L241">				hash = Arrays.hashCode((float[]) o);</span>
<span class="fc bfc" id="L242" title="All 2 branches covered.">			else if (o instanceof int[])</span>
<span class="fc" id="L243">				hash = Arrays.hashCode((int[]) o);</span>
<span class="fc bfc" id="L244" title="All 2 branches covered.">			else if (o instanceof long[])</span>
<span class="fc" id="L245">				hash = Arrays.hashCode((long[]) o);</span>
<span class="fc bfc" id="L246" title="All 2 branches covered.">			else if (o instanceof short[])</span>
<span class="fc" id="L247">				hash = Arrays.hashCode((short[]) o);</span>
<span class="fc bfc" id="L248" title="All 2 branches covered.">			else if (o.getClass().isArray()) {</span>
<span class="fc" id="L249">				int l = Array.getLength(o);</span>
<span class="fc" id="L250">				int h = o.getClass().getComponentType().hashCode();</span>
<span class="fc bfc" id="L251" title="All 2 branches covered.">				for (int i = 0; i &lt; l; i++)</span>
<span class="fc" id="L252">					h = prime * h + hashCode(Array.get(o, i));</span>
<span class="fc" id="L253">				hash = h;</span>
<span class="fc" id="L254">			} else</span>
<span class="fc" id="L255">				hash = o.hashCode();</span>
<span class="fc" id="L256">			result = prime * result + hash;</span>
		}
<span class="fc" id="L258">		return result;</span>
	}

	/**
	 * Determine if two objects are both non-null instances of the same class. This
	 * method is useful as a null and type safety check when implementing equals. If
	 * this returns true, and the type of one of the objects is known, then it is
	 * safe to cast the other object to the same type.
	 * 
	 * @param &lt;T&gt; object type
	 * @param o1  any object
	 * @param o2  any object
	 * @return True if both objects are not null and instances of the same class.
	 */
	public static &lt;T&gt; boolean typeCheck(T o1, T o2) {
<span class="fc" id="L273">		return typeCheck(o1, o2, null);</span>
	}

	/**
	 * Determine if two objects are both instances of a specific class, or
	 * subclasses of that class. This method is useful as a null and type safety
	 * check when implementing equals. If this returns true, then it is safe to cast
	 * the both objects to the type provided.
	 * 
	 * @param &lt;T&gt;  object type
	 * 
	 * @param o1   any object
	 * @param o2   any object
	 * @param type the type to check, may be null for the behavior outlined in
	 *             {@link #typeCheck(Object, Object)}.
	 * @return True if both objects are not null and instances of the given type, or
	 *         are the same class if type is null.
	 */
	public static &lt;T&gt; boolean typeCheck(T o1, T o2, Class&lt;?&gt; type) {
<span class="fc bfc" id="L292" title="All 2 branches covered.">		if (type != null)</span>
<span class="fc bfc" id="L293" title="All 4 branches covered.">			return type.isInstance(o1) &amp;&amp; type.isInstance(o2);</span>
<span class="fc bfc" id="L294" title="All 2 branches covered.">		if (o1 == o2)</span>
<span class="fc" id="L295">			return true;</span>
<span class="fc bfc" id="L296" title="All 4 branches covered.">		if (o1 == null || o2 == null)</span>
<span class="fc" id="L297">			return false;</span>
<span class="fc bfc" id="L298" title="All 2 branches covered.">		return o1.getClass() == o2.getClass();</span>
	}

	/**
	 * Determine if two objects are equal, checking first for identity and null.
	 * 
	 * @param o1 any object
	 * @param o2 any object
	 * @return true if o1 and o2 refer to the same object, are both null, or if
	 *         o1.equals(o2) returns true. Otherwise, return false.
	 */
	public static boolean equals(Object o1, Object o2) {
<span class="fc bfc" id="L310" title="All 2 branches covered.">		if (o1 == o2)</span>
<span class="fc" id="L311">			return true;</span>
<span class="fc bfc" id="L312" title="All 4 branches covered.">		if (o1 == null || o2 == null)</span>
<span class="fc" id="L313">			return false;</span>

<span class="fc bfc" id="L315" title="All 2 branches covered.">		if (o1.getClass() != o2.getClass())</span>
<span class="fc bfc" id="L316" title="All 8 branches covered.">			if (o1 instanceof Set &amp;&amp; o2 instanceof Set &amp;&amp; !(o1 instanceof SortedSet) &amp;&amp; !(o2 instanceof SortedSet)) {</span>
<span class="fc" id="L317">				Set&lt;?&gt; s1 = (Set&lt;?&gt;) o1;</span>
<span class="fc" id="L318">				Set&lt;?&gt; s2 = (Set&lt;?&gt;) o2;</span>
<span class="fc bfc" id="L319" title="All 2 branches covered.">				if (s1.size() != s2.size())</span>
<span class="fc" id="L320">					return false;</span>
<span class="fc" id="L321">				return s1.containsAll(s2);</span>
<span class="fc bfc" id="L322" title="All 4 branches covered.">			} else if (o1 instanceof Iterable &amp;&amp; o2 instanceof Iterable) {</span>
<span class="fc" id="L323">				Iterator&lt;?&gt; i1 = ((Iterable&lt;?&gt;) o1).iterator();</span>
<span class="fc" id="L324">				Iterator&lt;?&gt; i2 = ((Iterable&lt;?&gt;) o2).iterator();</span>
<span class="fc bfc" id="L325" title="All 2 branches covered.">				while (i1.hasNext()) {</span>
<span class="fc bfc" id="L326" title="All 2 branches covered.">					if (!i2.hasNext())</span>
<span class="fc" id="L327">						return false;</span>
<span class="fc bfc" id="L328" title="All 2 branches covered.">					if (!equals(i1.next(), i2.next()))</span>
<span class="fc" id="L329">						return false;</span>
				}
<span class="fc bfc" id="L331" title="All 2 branches covered.">				if (i2.hasNext())</span>
<span class="fc" id="L332">					return false;</span>
<span class="fc" id="L333">				return true;</span>
<span class="fc bfc" id="L334" title="All 4 branches covered.">			} else if ((o1 instanceof Map &amp;&amp; o2 instanceof Map)) {</span>
<span class="fc" id="L335">				Map&lt;?, ?&gt; m1 = (Map&lt;?, ?&gt;) o1;</span>
<span class="fc" id="L336">				Map&lt;?, ?&gt; m2 = (Map&lt;?, ?&gt;) o2;</span>
<span class="fc bfc" id="L337" title="All 2 branches covered.">				if (!equals(m1.keySet(), m2.keySet()))</span>
<span class="fc" id="L338">					return false;</span>
<span class="fc bfc" id="L339" title="All 2 branches covered.">				for (Object k : m1.keySet())</span>
<span class="fc bfc" id="L340" title="All 2 branches covered.">					if (!equals(m1.get(k), m2.get(k)))</span>
<span class="fc" id="L341">						return false;</span>
<span class="fc" id="L342">				return true;</span>
			} else
<span class="fc" id="L344">				return false;</span>

<span class="fc bfc" id="L346" title="All 2 branches covered.">		if (o1 instanceof boolean[])</span>
<span class="fc" id="L347">			return Arrays.equals((boolean[]) o1, (boolean[]) o2);</span>
<span class="fc bfc" id="L348" title="All 2 branches covered.">		if (o1 instanceof byte[])</span>
<span class="fc" id="L349">			return Arrays.equals((byte[]) o1, (byte[]) o2);</span>
<span class="fc bfc" id="L350" title="All 2 branches covered.">		if (o1 instanceof char[])</span>
<span class="fc" id="L351">			return Arrays.equals((char[]) o1, (char[]) o2);</span>
<span class="fc bfc" id="L352" title="All 2 branches covered.">		if (o1 instanceof double[])</span>
<span class="fc" id="L353">			return Arrays.equals((double[]) o1, (double[]) o2);</span>
<span class="fc bfc" id="L354" title="All 2 branches covered.">		if (o1 instanceof float[])</span>
<span class="fc" id="L355">			return Arrays.equals((float[]) o1, (float[]) o2);</span>
<span class="fc bfc" id="L356" title="All 2 branches covered.">		if (o1 instanceof int[])</span>
<span class="fc" id="L357">			return Arrays.equals((int[]) o1, (int[]) o2);</span>
<span class="fc bfc" id="L358" title="All 2 branches covered.">		if (o1 instanceof long[])</span>
<span class="fc" id="L359">			return Arrays.equals((long[]) o1, (long[]) o2);</span>
<span class="fc bfc" id="L360" title="All 2 branches covered.">		if (o1 instanceof short[])</span>
<span class="fc" id="L361">			return Arrays.equals((short[]) o1, (short[]) o2);</span>
<span class="fc bfc" id="L362" title="All 2 branches covered.">		if (o1.getClass().isArray()) {</span>
<span class="fc" id="L363">			int l1 = Array.getLength(o1);</span>
<span class="fc" id="L364">			int l2 = Array.getLength(o2);</span>
<span class="fc bfc" id="L365" title="All 2 branches covered.">			if (l1 != l2)</span>
<span class="fc" id="L366">				return false;</span>
<span class="fc bfc" id="L367" title="All 2 branches covered.">			for (int i = 0; i &lt; l1; i++)</span>
<span class="fc bfc" id="L368" title="All 2 branches covered.">				if (!equals(Array.get(o1, i), Array.get(o2, i)))</span>
<span class="fc" id="L369">					return false;</span>
<span class="fc" id="L370">			return true;</span>
		}

<span class="fc" id="L373">		return o1.equals(o2);</span>
	}

	/**
	 * Waits until a condition is met or a timeout interval expires.
	 * 
	 * @param lock      object to synchronize on
	 * @param condition condition to wait for
	 * @param timeout   timeout interval
	 * 
	 * @throws InterruptedException if the current thread is interrupted while
	 *                              waiting for the condition to be met
	 * @throws TimeoutException     if the timeout interval expires before the
	 *                              condition is met
	 * 
	 */
	public static void waitFor(Object lock, BooleanSupplier condition, Duration timeout)
			throws InterruptedException, TimeoutException {
<span class="fc" id="L391">		waitFor(lock, condition, Instant.now().plus(timeout));</span>
<span class="fc" id="L392">	}</span>

	/**
	 * Waits until a condition is met or a timeout interval expires.
	 * 
	 * @param lock           object to synchronize on
	 * @param condition      condition to wait for
	 * @param timeout        timeout interval
	 * @param timeoutFactory creates a timeout exception to be thrown if the
	 *                       condition is not met before the expiration time
	 * 
	 * @throws InterruptedException if the current thread is interrupted while
	 *                              waiting for the condition to be met
	 * @throws TimeoutException     if the timeout interval expires before the
	 *                              condition is met
	 * 
	 */
	public static void waitFor(Object lock, BooleanSupplier condition, Duration timeout,
			Supplier&lt;TimeoutException&gt; timeoutFactory) throws InterruptedException, TimeoutException {
<span class="fc" id="L411">		waitFor(lock, condition, Instant.now().plus(timeout), timeoutFactory);</span>
<span class="fc" id="L412">	}</span>

	/**
	 * Waits until a condition is met or a timeout interval expires.
	 * 
	 * @param lock      object to synchronize on to receive status change
	 *                  notifications
	 * @param condition condition to wait for
	 * @param expires   timeout interval expiration time
	 * 
	 * @throws InterruptedException if the current thread is interrupted while
	 *                              waiting for the condition to be met
	 * @throws TimeoutException     if the timeout interval expires before the
	 *                              condition is met
	 */
	public static void waitFor(Object lock, BooleanSupplier condition, Instant expires)
			throws InterruptedException, TimeoutException {
<span class="fc" id="L429">		final var init = Instant.now();</span>
<span class="fc" id="L430">		waitFor(lock, condition, expires, () -&gt; {</span>
<span class="fc" id="L431">			StringBuilder sb = new StringBuilder(&quot;Timed out in &quot;);</span>
<span class="fc" id="L432">			sb.append(Duration.between(init, expires));</span>
<span class="fc" id="L433">			return new TimeoutException(sb.toString());</span>
		});
<span class="fc" id="L435">	}</span>

	/**
	 * Waits until a condition is met or a timeout interval expires.
	 * 
	 * @param lock           object to synchronize on to receive status change
	 *                       notifications
	 * @param condition      condition to wait for
	 * @param expires        timeout interval expiration time
	 * @param timeoutFactory creates a timeout exception to be thrown if the
	 *                       condition is not met before the expiration time
	 * 
	 * @throws InterruptedException if the current thread is interrupted while
	 *                              waiting for the condition to be met
	 * @throws TimeoutException     if the timeout interval expires before the
	 *                              condition is met
	 */
	public static void waitFor(Object lock, BooleanSupplier condition, Instant expires,
			Supplier&lt;TimeoutException&gt; timeoutFactory) throws InterruptedException, TimeoutException {
<span class="fc" id="L454">		synchronized (lock) {</span>
<span class="fc bfc" id="L455" title="All 2 branches covered.">			while (!condition.getAsBoolean()) {</span>
<span class="fc" id="L456">				final var now = Instant.now();</span>
<span class="fc bfc" id="L457" title="All 2 branches covered.">				if (now.isBefore(expires)) {</span>
<span class="fc" id="L458">					final var waitFor = Duration.between(now, expires);</span>
<span class="fc" id="L459">					lock.wait(waitFor.toMillis(), waitFor.toNanosPart() % 1_000_000);</span>
<span class="fc" id="L460">				} else</span>
<span class="fc" id="L461">					throw timeoutFactory.get();</span>
<span class="fc" id="L462">			}</span>
<span class="fc" id="L463">		}</span>
<span class="fc" id="L464">	}</span>

	private IuObject() {
	};

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.10.202304240956</span></div></body></html>