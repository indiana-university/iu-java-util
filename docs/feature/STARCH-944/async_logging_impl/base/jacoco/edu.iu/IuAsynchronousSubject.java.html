<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>IuAsynchronousSubject.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">IU Base Utilities Module</a> &gt; <a href="index.source.html" class="el_package">edu.iu</a> &gt; <span class="el_source">IuAsynchronousSubject.java</span></div><h1>IuAsynchronousSubject.java</h1><pre class="source lang-java linenums">/*
 * Copyright Â© 2024 Indiana University
 * All rights reserved.
 *
 * BSD 3-Clause License
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 
 * - Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 * 
 * - Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 * 
 * - Neither the name of the copyright holder nor the names of its
 *   contributors may be used to endorse or promote products derived from
 *   this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package edu.iu;

import java.time.Duration;
import java.time.Instant;
import java.util.ArrayDeque;
import java.util.Queue;
import java.util.Spliterator;
import java.util.concurrent.ConcurrentLinkedDeque;
import java.util.concurrent.ConcurrentLinkedQueue;
import java.util.concurrent.TimeoutException;
import java.util.function.Consumer;
import java.util.function.Supplier;
import java.util.stream.Stream;
import java.util.stream.StreamSupport;

/**
 * Provides &lt;strong&gt;subscriber&lt;/strong&gt; {@link Stream} instances over a shared
 * source &lt;strong&gt;subject&lt;/strong&gt;.
 * 
 * &lt;p&gt;
 * Each &lt;strong&gt;subject&lt;/strong&gt; is backed externally by a &lt;strong&gt;controlling
 * component&lt;/strong&gt; that:
 * &lt;/p&gt;
 * &lt;ul&gt;
 * &lt;li&gt;Provides an &lt;strong&gt;initial {@link Spliterator split}&lt;/strong&gt; of
 * available values at the point in time a new {@link #subscribe() subscription}
 * is created.&lt;/li&gt;
 * &lt;li&gt;{@link #accept(Object) Accepts} new values to be distributed to active
 * &lt;strong&gt;subscribers&lt;/strong&gt;.&lt;/li&gt;
 * &lt;/ul&gt;
 * 
 * &lt;p&gt;
 * After the &lt;strong&gt;initial {@link Spliterator split}&lt;/strong&gt; is created, but
 * before the values available at {@link #subscribe() subscription} time have
 * all been {@link Spliterator#tryAdvance(Consumer) advanced}, newly
 * {@link #accept(Object) accepted} values are offered to a queue. Values
 * &lt;em&gt;may&lt;/em&gt; be removed from the queue if also advanced from the initial
 * split. Queued values will be polled and advanced after the last split of the
 * initial split advances its last value.
 * &lt;/p&gt;
 * 
 * &lt;p&gt;
 * After all queued values have been advanced, the &lt;strong&gt;subscriber&lt;/strong&gt;
 * transitions to a dedicated {@link IuAsynchronousPipe} and passes new values
 * through to {@link IuAsynchronousPipe#accept(Object)}.
 * &lt;/p&gt;
 * 
 * &lt;p&gt;
 * The &lt;strong&gt;subject&lt;/strong&gt; makes no guarantee to the &lt;strong&gt;controlling
 * component&lt;/strong&gt; when or if a &lt;strong&gt;subscriber&lt;/strong&gt; will transition
 * from non-blocking access to available values, to potentially blocking access
 * via {@link IuAsynchronousPipe}. It is, however, guaranteed that all values
 * available from the point in time the &lt;strong&gt;subscriber&lt;/strong&gt; begins
 * processing the {@link Stream} until &lt;strong&gt;unsubscribing&lt;/strong&gt; will be
 * supplied exactly once regardless of how the value is actually delivered.
 * &lt;/p&gt;
 * 
 * &lt;img src=&quot;doc-files/IuAsynchronousSubject.svg&quot; alt=&quot;UML Sequence Diagram&quot;&gt;
 * 
 * &lt;p&gt;
 * New values &lt;em&gt;should&lt;/em&gt; be {@link #accept(Object) accepted} before
 * appending the external source, to gracefully avoid a potential race condition
 * between the initial split and an internal appended values queue. For example:
 * &lt;/p&gt;
 * 
 * &lt;pre&gt;
 * class MyControllingComponent&amp;lt;T&amp;gt; implements Consumer&amp;lt;T&amp;gt; {
 * 	private final Queue&amp;lt;T&amp;gt; queue = new ConcurrentLinkedQueue&amp;lt;&amp;gt;();
 * 	private final IuAsynchronousSubject&amp;lt;T&amp;gt; subject =
 * 		new IuAsynchronousSubject&amp;lt;&amp;gt;(queue::spliterator);
 * 
 * 	{@literal @}Override
 * 	public void accept(T t) {
 * 		subject.accept(t);
 * 		queue.offer(t);
 * 	}
 * }
 * &lt;/pre&gt;
 * 
 * &lt;p&gt;
 * When the &lt;strong&gt;source&lt;/strong&gt; is sequential, &lt;strong&gt;subscribers&lt;/strong&gt;
 * &lt;em&gt;may&lt;/em&gt; expect to receive values in the order supplied.
 * &lt;/p&gt;
 * 
 * &lt;p&gt;
 * Each &lt;strong&gt;subscriber&lt;/strong&gt; {@link Stream} provides all values that may
 * be retrieved without blocking, then transitions to an
 * {@link IuAsynchronousPipe} managed by the &lt;strong&gt;subject&lt;/strong&gt; to block
 * until new values become available.
 * &lt;/p&gt;
 * 
 * &lt;p&gt;
 * A &lt;strong&gt;subscriber's&lt;/strong&gt; {@link Stream} may be {@link Stream#close()
 * closed} without affecting the status of the &lt;strong&gt;controlling
 * component&lt;/strong&gt;, or of any other &lt;strong&gt;subscriber&lt;/strong&gt; {@link Stream
 * streams}.
 * &lt;/p&gt;
 * 
 * &lt;p&gt;
 * This class is thread-safe and intended for use by high-volume
 * parallel-processing workloads.
 * &lt;/p&gt;
 * 
 * @param &lt;T&gt; value type
 * @see IuAsynchronousPipe
 */
public class IuAsynchronousSubject&lt;T&gt; implements Consumer&lt;T&gt;, AutoCloseable {

	private class SourceSplit implements Spliterator&lt;T&gt; {
		private final Subscriber subscriber;
		private volatile Spliterator&lt;T&gt; delegate;

<span class="fc" id="L144">		private SourceSplit(Spliterator&lt;T&gt; delegate, Subscriber subscriber) {</span>
<span class="fc" id="L145">			this.subscriber = subscriber;</span>
<span class="fc" id="L146">			this.delegate = delegate;</span>
<span class="fc" id="L147">			subscriber.children.offer(this);</span>
<span class="fc" id="L148">		}</span>

		@Override
		public boolean tryAdvance(Consumer&lt;? super T&gt; action) {
<span class="fc bfc" id="L152" title="All 2 branches covered.">			if (delegate != null //</span>
<span class="fc bfc" id="L153" title="All 2 branches covered.">					&amp;&amp; delegate.tryAdvance(subscriber.cancelAcceptedValueAfterAction(action))) {</span>

<span class="fc bfc" id="L155" title="All 2 branches covered.">				if (delegate.estimateSize() == 0)</span>
<span class="fc" id="L156">					delegate = null;</span>

<span class="fc" id="L158">				return true;</span>
			} else
<span class="fc" id="L160">				delegate = null;</span>

<span class="fc" id="L162">			return subscriber.continueAdvance(action);</span>
		}

		@Override
		public void forEachRemaining(Consumer&lt;? super T&gt; action) {
<span class="fc bfc" id="L167" title="All 2 branches covered.">			if (delegate != null) {</span>
<span class="fc" id="L168">				delegate.forEachRemaining(subscriber.cancelAcceptedValueAfterAction(action));</span>
<span class="fc" id="L169">				delegate = null;</span>
			}

<span class="fc" id="L172">			subscriber.continueForEach(action);</span>
<span class="fc" id="L173">		}</span>

		@Override
		public Spliterator&lt;T&gt; trySplit() {
<span class="fc bfc" id="L177" title="All 2 branches covered.">			if (delegate == null)</span>
<span class="fc" id="L178">				return null;</span>

<span class="fc" id="L180">			final var split = delegate.trySplit();</span>
<span class="fc bfc" id="L181" title="All 2 branches covered.">			if (split == null)</span>
<span class="fc" id="L182">				return null;</span>
			else
<span class="fc" id="L184">				return new SourceSplit(split, subscriber);</span>
		}

		@Override
		public long estimateSize() {
<span class="fc" id="L189">			var count = 0L;</span>

<span class="fc" id="L191">			final var delegate = this.delegate;</span>
<span class="fc bfc" id="L192" title="All 2 branches covered.">			if (delegate != null)</span>
<span class="fc" id="L193">				count += delegate.estimateSize();</span>

<span class="fc bfc" id="L195" title="All 2 branches covered.">			if (subscriber.isExhausted() //</span>
<span class="fc bfc" id="L196" title="All 2 branches covered.">					|| (subscriber.children.size() == 1 //</span>
<span class="fc bfc" id="L197" title="All 2 branches covered.">							&amp;&amp; subscriber.children.contains(this)))</span>
<span class="fc" id="L198">				count += subscriber.acceptedSize();</span>

<span class="fc" id="L200">			return count;</span>
		}

		@Override
		public int characteristics() {
<span class="fc" id="L205">			final var delegate = this.delegate;</span>
<span class="fc bfc" id="L206" title="All 2 branches covered.">			if (delegate != null)</span>
<span class="fc" id="L207">				return delegate.characteristics();</span>
			else
<span class="fc" id="L209">				return SIZED;</span>
		}

	}

	private class Subscriber implements Spliterator&lt;T&gt;, IuAsynchronousSubscription&lt;T&gt; {
		private final Stream&lt;T&gt; stream;
<span class="fc" id="L216">		private final Queue&lt;SourceSplit&gt; children = new ConcurrentLinkedDeque&lt;&gt;();</span>
<span class="fc" id="L217">		private final Queue&lt;T&gt; accepted = new ConcurrentLinkedQueue&lt;&gt;();</span>
		private volatile Spliterator&lt;T&gt; delegate;
		private volatile long acceptedCount;
		private volatile Throwable error;
		private volatile boolean closed;
		private volatile IuAsynchronousPipe&lt;T&gt; pipe;
		private volatile Spliterator&lt;T&gt; pipedSplit;

<span class="fc" id="L225">		private Subscriber() {</span>
<span class="fc" id="L226">			final var delegate = initialSplitSupplier.get();</span>
<span class="fc bfc" id="L227" title="All 2 branches covered.">			if (delegate.estimateSize() &gt; 0)</span>
<span class="fc" id="L228">				this.delegate = delegate;</span>

<span class="fc" id="L230">			subscribers.offer(this);</span>
<span class="fc" id="L231">			stream = StreamSupport.stream(this, false).onClose(this::close);</span>
<span class="fc" id="L232">		}</span>

		@Override
		public Spliterator&lt;T&gt; trySplit() {
<span class="fc" id="L236">			final var delegate = this.delegate;</span>
<span class="fc bfc" id="L237" title="All 2 branches covered.">			if (delegate != null) {</span>
<span class="fc" id="L238">				final var split = delegate.trySplit();</span>
<span class="fc bfc" id="L239" title="All 2 branches covered.">				if (split != null)</span>
<span class="fc" id="L240">					return new SourceSplit(split, this);</span>
				else {
<span class="fc" id="L242">					final Queue&lt;T&gt; queue = new ArrayDeque&lt;&gt;();</span>
<span class="fc bfc" id="L243" title="All 2 branches covered.">					if (delegate.tryAdvance(queue::offer)) {</span>
<span class="fc" id="L244">						delegate.forEachRemaining(queue::offer);</span>
<span class="fc" id="L245">						return new SourceSplit(queue.spliterator(), this);</span>
					}
				}
			}

<span class="fc bfc" id="L250" title="All 2 branches covered.">			if (error != null)</span>
<span class="fc" id="L251">				throw IuException.unchecked(error);</span>
<span class="fc bfc" id="L252" title="All 2 branches covered.">			else if (pipedSplit != null)</span>
<span class="fc" id="L253">				return pipedSplit.trySplit();</span>
			else
<span class="fc" id="L255">				return null;</span>
		}

		@Override
		public boolean tryAdvance(Consumer&lt;? super T&gt; action) {
<span class="fc" id="L260">			final var delegate = this.delegate;</span>
<span class="fc bfc" id="L261" title="All 2 branches covered.">			if (delegate != null //</span>
<span class="fc bfc" id="L262" title="All 2 branches covered.">					&amp;&amp; delegate.tryAdvance(cancelAcceptedValueAfterAction(action))) {</span>

<span class="fc bfc" id="L264" title="All 2 branches covered.">				if (delegate.estimateSize() == 0)</span>
<span class="fc" id="L265">					this.delegate = null;</span>

<span class="fc" id="L267">				return true;</span>
			} else
<span class="fc" id="L269">				this.delegate = null;</span>

<span class="fc bfc" id="L271" title="All 2 branches covered.">			if (continueAdvance(action)) {</span>
<span class="fc bfc" id="L272" title="All 2 branches covered.">				if (!canAdvance())</span>
<span class="fc" id="L273">					bootstrapPipe();</span>

<span class="fc" id="L275">				return true;</span>
			}

<span class="fc" id="L278">			bootstrapPipe();</span>

<span class="fc bfc" id="L280" title="All 2 branches covered.">			if (error != null)</span>
<span class="fc" id="L281">				throw IuException.unchecked(error);</span>
<span class="fc bfc" id="L282" title="All 2 branches covered.">			else if (pipedSplit != null)</span>
<span class="fc" id="L283">				return pipedSplit.tryAdvance(action);</span>
			else
<span class="fc" id="L285">				return false;</span>
		}

		@Override
		public void forEachRemaining(Consumer&lt;? super T&gt; action) {
<span class="fc bfc" id="L290" title="All 2 branches covered.">			if (delegate != null) {</span>
<span class="fc" id="L291">				delegate.forEachRemaining(cancelAcceptedValueAfterAction(action));</span>
<span class="fc" id="L292">				delegate = null;</span>
			}

<span class="fc" id="L295">			continueForEach(action);</span>

<span class="fc" id="L297">			bootstrapPipe();</span>

<span class="fc bfc" id="L299" title="All 2 branches covered.">			if (error != null)</span>
<span class="fc" id="L300">				throw IuException.unchecked(error);</span>
<span class="fc bfc" id="L301" title="All 2 branches covered.">			else if (pipedSplit != null)</span>
<span class="fc" id="L302">				pipedSplit.forEachRemaining(action);</span>
<span class="fc" id="L303">		}</span>

		@Override
		public synchronized long available() {
<span class="fc" id="L307">			var count = 0;</span>

<span class="fc bfc" id="L309" title="All 2 branches covered.">			if (delegate != null //</span>
<span class="fc bfc" id="L310" title="All 2 branches covered.">					&amp;&amp; delegate.hasCharacteristics(SIZED))</span>
<span class="fc" id="L311">				count += delegate.estimateSize();</span>

<span class="fc bfc" id="L313" title="All 2 branches covered.">			if (areChildrenExhausted())</span>
<span class="fc" id="L314">				count += acceptedSize();</span>

<span class="fc bfc" id="L316" title="All 2 branches covered.">			if (pipe != null)</span>
<span class="fc" id="L317">				count += pipe.getPendingCount();</span>

<span class="fc" id="L319">			return count;</span>
		}

		@Override
		public synchronized long estimateSize() {
<span class="fc bfc" id="L324" title="All 2 branches covered.">			if (pipedSplit == null) {</span>
<span class="fc bfc" id="L325" title="All 4 branches covered.">				if (!closed &amp;&amp; error == null)</span>
<span class="fc" id="L326">					return Long.MAX_VALUE;</span>
				else
<span class="fc" id="L328">					return available();</span>
			} else
<span class="fc" id="L330">				return pipedSplit.estimateSize();</span>
		}

		@Override
		public int characteristics() {
<span class="fc bfc" id="L335" title="All 2 branches covered.">			if (pipedSplit == null)</span>
<span class="fc bfc" id="L336" title="All 2 branches covered.">				if (!isClosed())</span>
<span class="fc" id="L337">					return CONCURRENT;</span>
				else
<span class="fc" id="L339">					return IMMUTABLE | SIZED;</span>
			else
<span class="fc" id="L341">				return pipedSplit.characteristics();</span>
		}

		@Override
		public Stream&lt;T&gt; stream() {
<span class="fc" id="L346">			return stream;</span>
		}

		@Override
		public long pause(long acceptedCount, Duration timeout) throws TimeoutException, InterruptedException {
<span class="fc bfc" id="L351" title="All 2 branches covered.">			if (acceptedCount &lt;= 0L)</span>
<span class="fc" id="L352">				return 0L;</span>

<span class="fc" id="L354">			final var now = Instant.now();</span>
<span class="fc" id="L355">			final var expires = now.plus(timeout);</span>

<span class="fc" id="L357">			final var initCount = this.acceptedCount;</span>
<span class="fc" id="L358">			final var targetCount = initCount + acceptedCount;</span>
<span class="fc" id="L359">			IuObject.waitFor(this, //</span>
<span class="fc bfc" id="L360" title="All 4 branches covered.">					() -&gt; isClosed() //</span>
							|| this.acceptedCount &gt;= targetCount //
					, expires);

<span class="fc" id="L364">			return this.acceptedCount - initCount;</span>
		}

		@Override
		public long pause(Instant expires) throws InterruptedException {
<span class="fc" id="L369">			final var initCount = acceptedCount;</span>

<span class="fc" id="L371">			synchronized (this) {</span>
<span class="fc bfc" id="L372" title="All 2 branches covered.">				while (!isClosed()) {</span>
<span class="fc" id="L373">					final var now = Instant.now();</span>
<span class="fc bfc" id="L374" title="All 2 branches covered.">					if (now.isBefore(expires)) {</span>
<span class="fc" id="L375">						final var waitFor = Duration.between(now, expires);</span>
<span class="fc" id="L376">						this.wait(waitFor.toMillis(), waitFor.toNanosPart() % 1_000_000);</span>
					} else
						break;
<span class="fc" id="L379">				}</span>
<span class="fc" id="L380">			}</span>

<span class="fc" id="L382">			return acceptedCount - initCount;</span>
		}

		@Override
		public synchronized boolean isClosed() {
<span class="fc bfc" id="L387" title="All 2 branches covered.">			if (pipe == null)</span>
<span class="fc bfc" id="L388" title="All 4 branches covered.">				return closed || error != null;</span>
			else
<span class="fc" id="L390">				return pipe.isClosed();</span>
		}

		@Override
		public synchronized void error(Throwable e) {
<span class="fc bfc" id="L395" title="All 2 branches covered.">			if (pipe != null)</span>
<span class="fc" id="L396">				pipe.error(e);</span>
			else
<span class="fc" id="L398">				error = e;</span>

<span class="fc" id="L400">			this.notifyAll();</span>
<span class="fc" id="L401">		}</span>

		@Override
		public synchronized void close() {
<span class="fc" id="L405">			subscribers.remove(this);</span>

<span class="fc bfc" id="L407" title="All 2 branches covered.">			if (pipe != null)</span>
<span class="fc" id="L408">				pipe.close();</span>
			else
<span class="fc" id="L410">				closed = true;</span>

<span class="fc" id="L412">			this.notifyAll();</span>
<span class="fc" id="L413">		}</span>

		private boolean isExhausted() {
<span class="fc bfc" id="L416" title="All 2 branches covered.">			if (delegate != null)</span>
<span class="fc" id="L417">				return false;</span>

<span class="fc" id="L419">			return areChildrenExhausted();</span>
		}

		private boolean canAdvance() {
<span class="fc bfc" id="L423" title="All 4 branches covered.">			return !isExhausted() || !accepted.isEmpty();</span>
		}

		private boolean canAccept() {
<span class="fc bfc" id="L427" title="All 4 branches covered.">			return delegate != null || !accepted.isEmpty();</span>
		}

		private boolean areChildrenExhausted() {
<span class="fc" id="L431">			final var i = children.iterator();</span>
<span class="fc bfc" id="L432" title="All 2 branches covered.">			while (i.hasNext())</span>
<span class="fc bfc" id="L433" title="All 2 branches covered.">				if (i.next().delegate == null)</span>
<span class="fc" id="L434">					i.remove();</span>
				else
<span class="fc" id="L436">					return false;</span>

<span class="fc" id="L438">			return true;</span>
		}

		private int acceptedSize() {
<span class="fc" id="L442">			return accepted.size();</span>
		}

		private Consumer&lt;? super T&gt; cancelAcceptedValueAfterAction(Consumer&lt;? super T&gt; action) {
<span class="fc" id="L446">			return value -&gt; {</span>
<span class="fc" id="L447">				action.accept(value);</span>

<span class="fc" id="L449">				synchronized (this) {</span>
<span class="fc" id="L450">					accepted.remove(value);</span>
<span class="fc" id="L451">					this.notifyAll();</span>
<span class="fc" id="L452">				}</span>
<span class="fc" id="L453">			};</span>
		}

		private boolean continueAdvance(Consumer&lt;? super T&gt; action) {
<span class="fc bfc" id="L457" title="All 2 branches covered.">			if (isExhausted()) {</span>
<span class="fc" id="L458">				final var value = accepted.poll();</span>
<span class="fc bfc" id="L459" title="All 2 branches covered.">				if (value != null) {</span>
<span class="fc" id="L460">					action.accept(value);</span>
<span class="fc" id="L461">					synchronized (this) {</span>
<span class="fc" id="L462">						this.notifyAll();</span>
<span class="fc" id="L463">					}</span>
<span class="fc" id="L464">					return true;</span>
				}
			}
<span class="fc" id="L467">			return false;</span>
		}

		private void continueForEach(Consumer&lt;? super T&gt; action) {
<span class="fc bfc" id="L471" title="All 2 branches covered.">			if (isExhausted()) {</span>
<span class="fc bfc" id="L472" title="All 2 branches covered.">				while (!accepted.isEmpty()) {</span>
<span class="fc" id="L473">					action.accept(accepted.poll());</span>
<span class="fc" id="L474">					synchronized (this) {</span>
<span class="fc" id="L475">						this.notifyAll();</span>
<span class="fc" id="L476">					}</span>
				}
			}
<span class="fc" id="L479">		}</span>

		private synchronized void bootstrapPipe() {
<span class="fc bfc" id="L482" title="All 6 branches covered.">			if (pipe == null //</span>
					&amp;&amp; error == null //
					&amp;&amp; !closed) {
<span class="fc" id="L485">				pipe = new IuAsynchronousPipe&lt;&gt;();</span>
<span class="fc" id="L486">				pipedSplit = pipe.stream().spliterator();</span>
			}
<span class="fc" id="L488">		}</span>

		private void accept(T t) {
<span class="fc" id="L491">			synchronized (this) {</span>
<span class="fc bfc" id="L492" title="All 2 branches covered.">				if (canAccept())</span>
<span class="fc" id="L493">					accepted.offer(t);</span>
				else {
<span class="fc" id="L495">					bootstrapPipe();</span>
<span class="fc" id="L496">					pipe.accept(t);</span>
				}
<span class="fc" id="L498">				acceptedCount++;</span>
<span class="fc" id="L499">				this.notifyAll();</span>
<span class="fc" id="L500">			}</span>

<span class="fc" id="L502">		}</span>

	}

	private final Supplier&lt;Spliterator&lt;T&gt;&gt; initialSplitSupplier;
<span class="fc" id="L507">	private final Queue&lt;Subscriber&gt; subscribers = new ConcurrentLinkedQueue&lt;&gt;();</span>
	private boolean closed;

	/**
	 * Creates a new &lt;strong&gt;subject&lt;/strong&gt;.
	 * 
	 * @param initialSplitSupplier supplies the initial split backing new
	 *                             &lt;strong&gt;subscriber&lt;/strong&gt; streams.
	 */
<span class="fc" id="L516">	public IuAsynchronousSubject(Supplier&lt;Spliterator&lt;T&gt;&gt; initialSplitSupplier) {</span>
<span class="fc" id="L517">		this.initialSplitSupplier = initialSplitSupplier;</span>
<span class="fc" id="L518">	}</span>

	/**
	 * &lt;strong&gt;Subscribes&lt;/strong&gt; to a {@link Stream} that supplies all values
	 * available without blocking then blocks until new values are available or the
	 * &lt;strong&gt;subject&lt;/strong&gt; is {@link #close() closed}.
	 * 
	 * @return {@link IuAsynchronousSubscription}
	 */
	public IuAsynchronousSubscription&lt;T&gt; subscribe() {
<span class="fc bfc" id="L528" title="All 2 branches covered.">		if (closed)</span>
<span class="fc" id="L529">			throw new IllegalStateException(&quot;closed&quot;);</span>

<span class="fc" id="L531">		return new Subscriber();</span>
	}

	/**
	 * Distributes a value to all potentially blocking &lt;strong&gt;subscribers&lt;/strong&gt;
	 * that have completed the transition to an {@link IuAsynchronousPipe}.
	 * 
	 * &lt;p&gt;
	 * This method does not supply values to &lt;strong&gt;subscribers&lt;/strong&gt; that
	 * haven't yet completed the transition. The &lt;strong&gt;controlling
	 * component&lt;/strong&gt; is responsible for independently supplying those values to
	 * it's {@link Spliterator}-supplying backing &lt;strong&gt;source&lt;/strong&gt;.
	 * &lt;/p&gt;
	 * 
	 * @param value value to supply to all &lt;strong&gt;subscribers&lt;/strong&gt;
	 */
	@Override
	public synchronized void accept(T value) {
<span class="fc bfc" id="L549" title="All 2 branches covered.">		if (closed)</span>
<span class="fc" id="L550">			throw new IllegalStateException(&quot;closed&quot;);</span>

<span class="fc" id="L552">		subscribers.forEach(subscriber -&gt; subscriber.accept(value));</span>
<span class="fc" id="L553">	}</span>

	/**
	 * Closes the &lt;strong&gt;subject&lt;/strong&gt;.
	 * 
	 * &lt;p&gt;
	 * Once closed:
	 * &lt;/p&gt;
	 * &lt;ul&gt;
	 * &lt;li&gt;Existing &lt;strong&gt;subscribers&lt;/strong&gt; may finish retrieving all values
	 * already supplied&lt;/li&gt;
	 * &lt;li&gt;Blocking &lt;strong&gt;subscriber&lt;/strong&gt; {@link Stream}s will be terminated
	 * gracefully&lt;/li&gt;
	 * &lt;li&gt;No new &lt;strong&gt;subscribers&lt;/strong&gt; may be created&lt;/li&gt;
	 * &lt;li&gt;No new &lt;strong&gt;values&lt;/strong&gt; may be supplied&lt;/li&gt;
	 * &lt;/ul&gt;
	 */
	@Override
	public synchronized void close() {
<span class="fc bfc" id="L572" title="All 2 branches covered.">		if (closed)</span>
<span class="fc" id="L573">			return;</span>

<span class="fc" id="L575">		closed = true;</span>

<span class="fc" id="L577">		Throwable e = null;</span>
<span class="fc bfc" id="L578" title="All 2 branches covered.">		while (!subscribers.isEmpty())</span>
<span class="fc" id="L579">			e = IuException.suppress(e, () -&gt; subscribers.poll().close());</span>

<span class="fc bfc" id="L581" title="All 2 branches covered.">		if (e != null)</span>
<span class="fc" id="L582">			throw IuException.unchecked(e);</span>
<span class="fc" id="L583">	}</span>

	/**
	 * Reports a fatal error to all &lt;strong&gt;subscribers&lt;/strong&gt; and {@link #close()
	 * closes} the &lt;strong&gt;subject&lt;/strong&gt;.
	 * 
	 * @param e fatal error
	 */
	public synchronized void error(Throwable e) {
<span class="fc bfc" id="L592" title="All 2 branches covered.">		while (!subscribers.isEmpty())</span>
<span class="fc" id="L593">			IuException.suppress(e, () -&gt; subscribers.poll().error(e));</span>

<span class="fc" id="L595">		closed = true;</span>
<span class="fc" id="L596">	}</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.10.202304240956</span></div></body></html>