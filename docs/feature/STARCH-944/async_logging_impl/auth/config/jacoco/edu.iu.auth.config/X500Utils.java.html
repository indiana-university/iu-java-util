<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>X500Utils.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">IU Authentication and Authorization Configuration</a> &gt; <a href="index.source.html" class="el_package">edu.iu.auth.config</a> &gt; <span class="el_source">X500Utils.java</span></div><h1>X500Utils.java</h1><pre class="source lang-java linenums">/*
 * Copyright Â© 2024 Indiana University
 * All rights reserved.
 *
 * BSD 3-Clause License
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 
 * - Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 * 
 * - Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 * 
 * - Neither the name of the copyright holder nor the names of its
 *   contributors may be used to endorse or promote products derived from
 *   this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package edu.iu.auth.config;

import java.io.ByteArrayOutputStream;
import java.nio.CharBuffer;
import java.security.Principal;
import java.util.ArrayDeque;
import java.util.Arrays;
import java.util.LinkedHashMap;
import java.util.Map;
import java.util.Queue;
import java.util.function.Consumer;
import java.util.function.Supplier;

import javax.security.auth.x500.X500Principal;

import edu.iu.IuIterable;
import edu.iu.IuObject;
import edu.iu.IuText;

/**
 * Provides basic metadata inspection utilities for {@link X500Principal}.
 */
public final class X500Utils {

	/**
	 * Maps required X500 OID values to standard short names
	 */
<span class="fc" id="L59">	static Map&lt;String, String&gt; X500_OIDMAP = Map.of( //</span>
			&quot;2.5.4.3&quot;, &quot;CN&quot;, //
			&quot;2.5.4.7&quot;, &quot;L&quot;, //
			&quot;2.5.4.8&quot;, &quot;ST&quot;, //
			&quot;2.5.4.10&quot;, &quot;O&quot;, //
			&quot;2.5.4.11&quot;, &quot;OU&quot;, //
			&quot;2.5.4.6&quot;, &quot;C&quot;, //
			&quot;2.5.4.9&quot;, &quot;STREET&quot;, //
			&quot;0.9.2342.19200300.100.1.25&quot;, &quot;DC&quot;, //
			&quot;0.9.2342.19200300.100.1.1&quot;, &quot;UID&quot;);

	/**
	 * Determines the common name of a principal.
	 * 
	 * @param principal principal
	 * @return parsed CN value from {@link X500Principal}; else
	 *         {@link Principal#getName()}
	 */
	public static String getCommonName(X500Principal principal) {
<span class="fc" id="L78">		final var name = principal.getName();</span>

<span class="fc" id="L80">		String cn = null;</span>
<span class="fc" id="L81">		final var nameBuilder = new StringBuilder();</span>
<span class="fc bfc" id="L82" title="All 2 branches covered.">		for (final var rdn : parse(name)) {</span>
<span class="fc" id="L83">			cn = IuObject.first(cn, rdn.get(&quot;cn&quot;), rdn.get(&quot;CN&quot;), rdn.get(&quot;uid&quot;), rdn.get(&quot;UID&quot;));</span>
<span class="fc" id="L84">			final var dc = IuObject.first(rdn.get(&quot;dc&quot;), rdn.get(&quot;DC&quot;));</span>
<span class="fc bfc" id="L85" title="All 2 branches covered.">			if (dc != null) {</span>
<span class="fc bfc" id="L86" title="All 2 branches covered.">				if (nameBuilder.length() == 0)</span>
<span class="fc" id="L87">					nameBuilder.append('@');</span>
				else
<span class="fc" id="L89">					nameBuilder.append('.');</span>
<span class="fc" id="L90">				nameBuilder.append(dc);</span>
			}
<span class="fc" id="L92">		}</span>
<span class="fc" id="L93">		IuObject.convert(cn, a -&gt; nameBuilder.insert(0, a));</span>
<span class="fc bfc" id="L94" title="All 2 branches covered.">		return nameBuilder.length() == 0 ? null : nameBuilder.toString();</span>
	}

	/**
	 * Parses an X.500 Distinguished Name (DN)
	 * 
	 * &lt;p&gt;
	 * The purpose of this method is to facilitate inspection of specific standard
	 * attributes used with principal system and user identifying certificates.
	 * Certificates that provide {@link X500Principal} instances &lt;em&gt;should&lt;/em&gt; be
	 * verified as trusted using the delivered JCE provider prior to passing a raw
	 * DN to this method. Use {@link X500Principal#getName()} to validate the input
	 * value for this method if retrieved from a user-provided certificate.
	 * &lt;/p&gt;
	 * 
	 * &lt;p&gt;
	 * The response iterates Relative Distinguished Names mappings as defined for
	 * X.500 by &lt;a href=&quot;https://datatracker.ietf.org/doc/html/rfc4514&quot;&gt;RFC-4514
	 * LDAP&lt;/a&gt;.
	 * &lt;/p&gt;
	 * 
	 * &lt;p&gt;
	 * This utility method only implements a simple parser of the ABNF grammar
	 * defined in
	 * &lt;a href=&quot;https://datatracker.ietf.org/doc/html/rfc4514#section-4&quot;&gt;RFC-4514
	 * Section 4&lt;/a&gt;; it is not intended as part of larger implementation. Since JCE
	 * X500 functionality is implemented in non-exported packages of java.base,
	 * access to the security layer's parser is not allowed in a modular
	 * environment. The LDAP parser in javax.naming is not appropriate for this use.
	 * &lt;/p&gt;
	 * 
	 * @param name serialized X.500 DN
	 * @return parsed DN
	 * @see #getCommonName(X500Principal)
	 */
	public static Iterable&lt;Map&lt;String, String&gt;&gt; parse(String name) {
<span class="fc bfc" id="L130" title="All 2 branches covered.">		if (name.isEmpty())</span>
<span class="fc" id="L131">			return IuIterable.empty();</span>

<span class="fc" id="L133">		final Queue&lt;Map&lt;String, String&gt;&gt; parsedDN = new ArrayDeque&lt;&gt;();</span>
<span class="fc" id="L134">		Map&lt;String, String&gt; rdn = new LinkedHashMap&lt;&gt;();</span>
<span class="fc" id="L135">		parsedDN.offer(rdn);</span>

<span class="fc" id="L137">		var buf = CharBuffer.wrap(name);</span>
<span class="fc bfc" id="L138" title="All 2 branches covered.">		final Supplier&lt;Character&gt; next = () -&gt; buf.hasRemaining() ? buf.get() : '\0';</span>
<span class="fc bfc" id="L139" title="All 2 branches covered.">		while (buf.hasRemaining()) {</span>
			// type = keystring / numericoid
<span class="fc" id="L141">			final var startOfAttributeType = buf.position();</span>
<span class="fc" id="L142">			var c = next.get();</span>
<span class="fc bfc" id="L143" title="All 2 branches covered.">			if (digit(c))</span>
				do { // numericoid = number 1*( DOT number )
<span class="fc bfc" id="L145" title="All 2 branches covered.">					if (c == '.') {</span>
<span class="fc" id="L146">						c = next.get();</span>
<span class="fc bfc" id="L147" title="All 2 branches covered.">						if (!digit(c))</span>
<span class="fc" id="L148">							throw new IllegalArgumentException(&quot;expected DIGIT at &quot; + buf.position());</span>
					}

					// number = DIGIT / ( LDIGIT 1*DIGIT )
<span class="fc" id="L152">					final var startOfNumber = buf.position();</span>
<span class="fc" id="L153">					final var ldigit = ldigit(c);</span>
					do {
<span class="fc bfc" id="L155" title="All 4 branches covered.">						if (buf.position() &gt; startOfNumber &amp;&amp; !ldigit)</span>
<span class="fc" id="L156">							throw new IllegalArgumentException(&quot;unexpected at &quot; + buf.position());</span>

<span class="fc" id="L158">						c = next.get();</span>
<span class="fc bfc" id="L159" title="All 2 branches covered.">					} while (digit(c));</span>

<span class="fc bfc" id="L161" title="All 2 branches covered.">				} while (c == '.');</span>
<span class="fc bfc" id="L162" title="All 2 branches covered.">			else if (alpha(c))</span>
				do // keystring = ALPHA *keychar
<span class="fc" id="L164">					c = next.get();</span>
<span class="fc bfc" id="L165" title="All 2 branches covered.">				while (keychar(c));</span>
			else
<span class="fc" id="L167">				throw new IllegalArgumentException(&quot;expected ALPHA or DIGIT at &quot; + buf.position());</span>

			// typedValue = type EQUALS value
<span class="fc" id="L170">			final var attributeType = name.substring(startOfAttributeType, buf.position() - 1);</span>
<span class="fc bfc" id="L171" title="All 2 branches covered.">			if (c != '=')</span>
<span class="fc" id="L172">				throw new IllegalArgumentException(&quot;expected EQUALS at &quot; + buf.position());</span>

			// value = string / hexstring
			final String value;
<span class="fc" id="L176">			c = next.get();</span>
			// string = [ ( leadchar / pair )
			// [ *( stringchar / pair ) ( trailchar / pair ) ] ]
<span class="fc bfc" id="L179" title="All 2 branches covered.">			if (leadchar(c) //</span>
<span class="fc bfc" id="L180" title="All 2 branches covered.">					|| c == '\\') {</span>
<span class="fc" id="L181">				final var valueBuilder = new StringBuilder();</span>
<span class="fc" id="L182">				final var pendingBytes = new ByteArrayOutputStream();</span>
<span class="fc" id="L183">				final Consumer&lt;Object&gt; append = a -&gt; {</span>
<span class="fc bfc" id="L184" title="All 2 branches covered.">					if (pendingBytes.size() &gt; 0) {</span>
<span class="fc" id="L185">						valueBuilder.append(IuText.utf8(pendingBytes.toByteArray()));</span>
<span class="fc" id="L186">						pendingBytes.reset();</span>
					}
<span class="fc bfc" id="L188" title="All 2 branches covered.">					if (a != null)</span>
<span class="fc" id="L189">						valueBuilder.append(a);</span>
<span class="fc" id="L190">				};</span>

				do {
<span class="fc bfc" id="L193" title="All 2 branches covered.">					if (c == '\\') {</span>
						// pair = ESC ( ESC / special / hexpair )
<span class="fc" id="L195">						c = next.get();</span>
<span class="fc bfc" id="L196" title="All 4 branches covered.">						if (c == '\\' || special(c)) {</span>
							// replace &lt;ESC&gt;&lt;ESC&gt; with &lt;ESC&gt;;
							// replace &lt;ESC&gt;&lt;special&gt; with &lt;special&gt;;
<span class="fc" id="L199">							append.accept(c);</span>
<span class="fc" id="L200">							c = next.get();</span>
<span class="fc bfc" id="L201" title="All 2 branches covered.">						} else if (hexchar(c)) {</span>
							// hexpair = HEX HEX
<span class="fc" id="L203">							var hexval = Integer.parseInt(Character.toString(c), 0x10) * 0x10;</span>
<span class="fc" id="L204">							c = next.get();</span>
<span class="fc bfc" id="L205" title="All 2 branches covered.">							if (!hexchar(c))</span>
<span class="fc" id="L206">								throw new IllegalArgumentException(&quot;expected HEX at &quot; + buf.position());</span>
							else
<span class="fc" id="L208">								hexval += Integer.parseInt(Character.toString(c), 0x10);</span>
<span class="fc" id="L209">							pendingBytes.write(hexval);</span>

<span class="fc" id="L211">							c = next.get();</span>
<span class="fc" id="L212">						} else</span>
<span class="fc" id="L213">							throw new IllegalArgumentException(&quot;unexpected at &quot; + buf.position());</span>
					} else {
<span class="fc" id="L215">						final var l = c;</span>
<span class="fc" id="L216">						c = next.get();</span>
<span class="fc bfc" id="L217" title="All 2 branches covered.">						if (!stringchar(c) //</span>
<span class="fc bfc" id="L218" title="All 2 branches covered.">								&amp;&amp; c != '\\' //</span>
<span class="fc bfc" id="L219" title="All 2 branches covered.">								&amp;&amp; !trailchar(l))</span>
<span class="fc" id="L220">							throw new IllegalArgumentException(&quot;unexpected SP at &quot; + buf.position());</span>
<span class="fc" id="L221">						append.accept(l);</span>
					}
<span class="fc bfc" id="L223" title="All 4 branches covered.">				} while (stringchar(c) || c == '\\');</span>

<span class="fc" id="L225">				append.accept(null);</span>
<span class="fc" id="L226">				value = valueBuilder.toString();</span>

<span class="fc bfc" id="L228" title="All 2 branches covered.">			} else if (c == '#') {</span>
				// hexstring = SHARP 1*hexpair
<span class="fc" id="L230">				c = next.get();</span>
<span class="fc bfc" id="L231" title="All 2 branches covered.">				if (!hexchar(c))</span>
<span class="fc" id="L232">					throw new IllegalArgumentException(&quot;expected HEX at &quot; + buf.position());</span>

<span class="fc" id="L234">				ByteArrayOutputStream hexString = new ByteArrayOutputStream();</span>
				do {
<span class="fc" id="L236">					var hexval = Integer.parseInt(Character.toString(c), 0x10) * 0x10;</span>
<span class="fc" id="L237">					c = next.get();</span>
<span class="fc bfc" id="L238" title="All 2 branches covered.">					if (!hexchar(c))</span>
<span class="fc" id="L239">						throw new IllegalArgumentException(&quot;expected HEX at &quot; + buf.position());</span>
<span class="fc" id="L240">					hexval += Integer.parseInt(Character.toString(c), 0x10);</span>
<span class="fc" id="L241">					hexString.write(hexval);</span>

<span class="fc" id="L243">					c = next.get();</span>
<span class="fc bfc" id="L244" title="All 2 branches covered.">				} while (hexchar(c));</span>

<span class="fc" id="L246">				final var ber = hexString.toByteArray();</span>
<span class="fc bfc" id="L247" title="All 6 branches covered.">				if (ber.length &lt;= 2 //</span>
						|| ber[0] != 0x16 //
						|| ber[1] &lt;= 0)
<span class="fc" id="L250">					value = &quot;data:;base64,&quot; + IuText.base64(ber);</span>
				else
					// IA5String: BER-encoded type 0x16 ASCII string
					// used to represent CANONICAL DC attribute
<span class="fc" id="L254">					value = IuText.ascii(Arrays.copyOfRange(ber, 2, ber[1] + 2));</span>

<span class="fc" id="L256">			} else</span>
<span class="fc" id="L257">				throw new IllegalArgumentException(&quot;expected &lt;stringchar&gt; or SHARP at &quot; + buf.position());</span>

<span class="fc" id="L259">			rdn.put(attributeType, value);</span>

<span class="fc bfc" id="L261" title="All 2 branches covered.">			if (c == ',') {</span>
				// dn = [ rdn *( COMMA rdn ) ]
<span class="fc" id="L263">				rdn = new LinkedHashMap&lt;&gt;();</span>
<span class="fc" id="L264">				parsedDN.offer(rdn);</span>
<span class="fc bfc" id="L265" title="All 2 branches covered.">			} else if (c != '+' //</span>
<span class="fc bfc" id="L266" title="All 2 branches covered.">					&amp;&amp; (c != '\0' //</span>
<span class="fc bfc" id="L267" title="All 2 branches covered.">							|| buf.hasRemaining()))</span>
<span class="fc" id="L268">				throw new IllegalArgumentException(&quot;expected PLUS or COMMA at &quot; + buf.position());</span>
			// rdn = typedValue *( PLUS typedValue )
<span class="fc" id="L270">		}</span>

<span class="fc" id="L272">		return parsedDN;</span>
	}

	private static boolean alpha(char c) {
		// ALPHA = %x41-5A / %x61-7A ; &quot;A&quot;-&quot;Z&quot; / &quot;a&quot;-&quot;z&quot;
		// ALPHA = &lt;any ASCII alphabetic character&gt;
		// ; (decimal 65-90 and 97-122)
<span class="fc bfc" id="L279" title="All 8 branches covered.">		return (c &gt;= 'A' &amp;&amp; c &lt;= 'Z') || (c &gt;= 'a' &amp;&amp; c &lt; 'z');</span>
	}

	private static boolean digit(char c) {
		// DIGIT = %x30 / LDIGIT ; &quot;0&quot;-&quot;9&quot;
		// DIGIT = &lt;any ASCII decimal digit&gt;
		// ; (decimal 48-57)
<span class="fc bfc" id="L286" title="All 4 branches covered.">		return c == '0' || ldigit(c);</span>
	}

	private static boolean ldigit(char c) {
		// LDIGIT = %x31-39 ; &quot;1&quot;-&quot;9&quot;
<span class="fc bfc" id="L291" title="All 4 branches covered.">		return c &gt;= '1' &amp;&amp; c &lt;= '9';</span>
	}

	private static boolean hexchar(char c) {
		// HEX = DIGIT / %x41-46 / %x61-66 ; &quot;0&quot;-&quot;9&quot; / &quot;A&quot;-&quot;F&quot; / &quot;a&quot;-&quot;f&quot;
		// hexchar = DIGIT / &quot;A&quot; / &quot;B&quot; / &quot;C&quot; / &quot;D&quot; / &quot;E&quot; / &quot;F&quot;
		// / &quot;a&quot; / &quot;b&quot; / &quot;c&quot; / &quot;d&quot; / &quot;e&quot; / &quot;f&quot;
<span class="fc bfc" id="L298" title="All 10 branches covered.">		return digit(c) //</span>
				|| (c &gt;= 'A' &amp;&amp; c &lt;= 'F') //
				|| (c &gt;= 'a' &amp;&amp; c &lt;= 'f');
	}

	private static boolean keychar(char c) {
		// keychar = ALPHA / DIGIT / HYPHEN
<span class="fc bfc" id="L305" title="All 6 branches covered.">		return alpha(c) || digit(c) || c == '-';</span>
	}

	private static boolean leadchar(char c) {
		// leadchar = LUTF1 / UTFMB
		// LUTF1 = %x01-1F / %x21 / %x24-2A / %x2D-3A /
		// %x3D / %x3F-5B / %x5D-7F
<span class="fc bfc" id="L312" title="All 4 branches covered.">		return trailchar(c) &amp;&amp; c != '#';</span>
	}

	private static boolean trailchar(char c) {
		// trailchar = TUTF1 / UTFMB
		// TUTF1 = %x01-1F / %x21 / %x23-2A / %x2D-3A /
		// %x3D / %x3F-5B / %x5D-7F
<span class="fc bfc" id="L319" title="All 4 branches covered.">		return stringchar(c) &amp;&amp; c != ' ';</span>
	}

	private static boolean stringchar(char c) {
		// stringchar = SUTF1 / UTFMB
		// SUTF1 = %x01-21 / %x23-2A / %x2D-3A /
		// %x3D / %x3F-5B / %x5D-7F
<span class="fc bfc" id="L326" title="All 6 branches covered.">		return !escaped(c) &amp;&amp; c != '\0' &amp;&amp; c != '\\';</span>
	}

	private static boolean escaped(char c) {
		// escaped = DQUOTE / PLUS / COMMA / SEMI / LANGLE / RANGLE
<span class="fc bfc" id="L331" title="All 2 branches covered.">		return &quot;\&quot;+,;&lt;&gt;&quot;.indexOf(c) != -1;</span>
	}

	private static boolean special(char c) {
		// special = escaped / SPACE / SHARP / EQUALS
<span class="fc bfc" id="L336" title="All 2 branches covered.">		return escaped(c) //</span>
<span class="fc bfc" id="L337" title="All 2 branches covered.">				|| &quot; #=&quot;.indexOf(c) != -1;</span>
	}

	private X500Utils() {
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.10.202304240956</span></div></body></html>