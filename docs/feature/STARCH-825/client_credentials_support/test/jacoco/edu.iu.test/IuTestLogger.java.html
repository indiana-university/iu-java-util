<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>IuTestLogger.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">IU Unit Test Support Module</a> &gt; <a href="index.source.html" class="el_package">edu.iu.test</a> &gt; <span class="el_source">IuTestLogger.java</span></div><h1>IuTestLogger.java</h1><pre class="source lang-java linenums">/*
 * Copyright Â© 2024 Indiana University
 * All rights reserved.
 *
 * BSD 3-Clause License
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 
 * - Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 * 
 * - Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 * 
 * - Neither the name of the copyright holder nor the names of its
 *   contributors may be used to endorse or promote products derived from
 *   this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package edu.iu.test;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertNotNull;

import java.util.ArrayDeque;
import java.util.Collections;
import java.util.HashSet;
import java.util.List;
import java.util.Objects;
import java.util.Queue;
import java.util.Set;
import java.util.concurrent.ConcurrentLinkedQueue;
import java.util.function.Predicate;
import java.util.logging.Handler;
import java.util.logging.Level;
import java.util.logging.LogManager;
import java.util.logging.LogRecord;
import java.util.logging.Logger;
import java.util.regex.Pattern;
import java.util.regex.PatternSyntaxException;

import org.opentest4j.AssertionFailedError;

import edu.iu.IuObject;

/**
 * Asserts that calls to {@link Logger#log(LogRecord)} must be expected by the
 * test case being evaluated, and that all expected log events &lt;em&gt;must&lt;/em&gt;
 * occur in order.
 * 
 * &lt;p&gt;
 * This mechanism is tied in automatically when depending on
 * {@code iu-java-test} for unit testing. Any use of
 * {@link Logger#log(LogRecord)} will cause the test to fail unless the log
 * event is explicitly expected to be the next log event. Log event expectations
 * &lt;em&gt;require&lt;/em&gt;:
 * &lt;/p&gt;
 * &lt;ul&gt;
 * &lt;li&gt;Logger name to match exactly&lt;/li&gt;
 * &lt;li&gt;Log level to match exactly&lt;/li&gt;
 * &lt;li&gt;Log message to match a {@link Pattern regular expression}&lt;/li&gt;
 * &lt;li&gt;Thrown exception class to match exactly, or for an exception to not be
 * thrown&lt;/li&gt;
 * &lt;li&gt;Thrown exception to meet additional criteria if defined by
 * {@link Predicate}&lt;/li&gt;
 * &lt;/ul&gt;
 * 
 * &lt;p&gt;
 * &lt;strong&gt;Platform-level&lt;/strong&gt; loggers are exempt, and will be logged
 * normally as configured by {@link java.logging} before the test framework is
 * configured, i.e., INFO level and higher logged to console. The following
 * logger names are considered platform loggers.
 * &lt;/p&gt;
 * &lt;ul&gt;
 * &lt;li&gt;org.junit&lt;/li&gt;
 * &lt;li&gt;org.mockito&lt;/li&gt;
 * &lt;li&gt;org.apiguardian&lt;/li&gt;
 * &lt;li&gt;net.bytebuddy&lt;/li&gt;
 * &lt;li&gt;org.objenesis&lt;/li&gt;
 * &lt;li&gt;org.opentest4j&lt;/li&gt;
 * &lt;li&gt;Any logger name for which {@link IuObject#isPlatformName(String)} returns
 * true&lt;/li&gt;
 * &lt;li&gt;Any logger name prefixed by the comma-separated
 * {@link IuTest#getProperty(String) test property value}
 * {@code iu.util.test.platformLoggers}&lt;/li&gt;
 * &lt;/ul&gt;
 */
public final class IuTestLogger {

	private static class LogRecordMatcher&lt;T extends Throwable&gt; {
		private final String loggerName;
		private final Level level;
		private final Class&lt;T&gt; thrownClass;
		private final Predicate&lt;T&gt; thrownTest;
		private final String pattern;

		private LogRecordMatcher(String loggerName, Level level, Class&lt;T&gt; thrownClass, Predicate&lt;T&gt; thrownTest,
<span class="fc" id="L110">				String pattern) {</span>
<span class="fc" id="L111">			this.loggerName = loggerName;</span>
<span class="fc" id="L112">			this.level = level;</span>
<span class="fc" id="L113">			this.thrownClass = thrownClass;</span>
<span class="fc" id="L114">			this.thrownTest = thrownTest;</span>
<span class="fc" id="L115">			this.pattern = pattern;</span>
<span class="fc" id="L116">		}</span>

		private boolean isExpected(LogRecord record) {
<span class="fc bfc" id="L119" title="All 2 branches covered.">			if (!loggerName.equals(record.getLoggerName()))</span>
<span class="fc" id="L120">				return false;</span>
<span class="fc bfc" id="L121" title="All 2 branches covered.">			if (level.intValue() != record.getLevel().intValue())</span>
<span class="fc" id="L122">				return false;</span>

<span class="fc" id="L124">			var thrown = record.getThrown();</span>
<span class="fc bfc" id="L125" title="All 2 branches covered.">			if (thrownClass == null) {</span>
<span class="fc bfc" id="L126" title="All 2 branches covered.">				if (thrown != null)</span>
<span class="fc" id="L127">					return false;</span>
<span class="fc bfc" id="L128" title="All 2 branches covered.">			} else if (thrown == null)</span>
<span class="fc" id="L129">				return false;</span>
			else {
<span class="fc bfc" id="L131" title="All 2 branches covered.">				if (thrownClass != thrown.getClass())</span>
<span class="fc" id="L132">					return false;</span>

<span class="fc bfc" id="L134" title="All 4 branches covered.">				if (thrownTest != null &amp;&amp; !thrownTest.test(thrownClass.cast(thrown)))</span>
<span class="fc" id="L135">					return false;</span>
			}

<span class="fc" id="L138">			var message = record.getMessage();</span>
<span class="fc bfc" id="L139" title="All 2 branches covered.">			return pattern.equals(message)</span>
<span class="fc bfc" id="L140" title="All 2 branches covered.">					|| Pattern.compile(pattern, Pattern.MULTILINE | Pattern.DOTALL).matcher(message).matches();</span>
		}

		private boolean isAllowed(LogRecord record) {
<span class="fc bfc" id="L144" title="All 2 branches covered.">			if (!record.getLoggerName().startsWith(loggerName))</span>
<span class="fc" id="L145">				return false;</span>
<span class="fc bfc" id="L146" title="All 2 branches covered.">			if (level.intValue() &lt; record.getLevel().intValue())</span>
<span class="fc" id="L147">				return false;</span>

<span class="fc bfc" id="L149" title="All 2 branches covered.">			if (thrownClass != null) {</span>
<span class="fc" id="L150">				var thrown = record.getThrown();</span>
<span class="fc bfc" id="L151" title="All 2 branches covered.">				if (thrown == null //</span>
<span class="fc bfc" id="L152" title="All 2 branches covered.">						|| thrownClass != thrown.getClass())</span>
<span class="fc" id="L153">					return false;</span>

<span class="fc bfc" id="L155" title="All 4 branches covered.">				if (thrownTest != null &amp;&amp; !thrownTest.test(thrownClass.cast(thrown)))</span>
<span class="fc" id="L156">					return false;</span>
			}

<span class="fc" id="L159">			var message = record.getMessage();</span>
<span class="fc bfc" id="L160" title="All 2 branches covered.">			return pattern.equals(message)</span>
<span class="fc bfc" id="L161" title="All 2 branches covered.">					|| Pattern.compile(pattern, Pattern.MULTILINE | Pattern.DOTALL).matcher(message).matches();</span>
		}

		@Override
		public String toString() {
<span class="fc" id="L166">			return &quot;LogRecordMatcher [loggerName=&quot; + loggerName + &quot;, level=&quot; + level + &quot;, thrownClass=&quot; + thrownClass</span>
					+ &quot;, pattern=&quot; + pattern + &quot;]&quot;;
		}

	}

<span class="fc" id="L172">	private static class IuTestLogHandler extends Handler {</span>
		private String activeTest;
<span class="fc" id="L174">		private Queue&lt;LogRecordMatcher&lt;?&gt;&gt; expectedMessages = new ConcurrentLinkedQueue&lt;&gt;();</span>
<span class="fc" id="L175">		private Queue&lt;LogRecordMatcher&lt;?&gt;&gt; allowedMessages = new ConcurrentLinkedQueue&lt;&gt;();</span>
<span class="fc" id="L176">		private Queue&lt;Throwable&gt; unexpectedMessages = new ConcurrentLinkedQueue&lt;&gt;();</span>

		private void reset(String activeTest) {
<span class="fc" id="L179">			this.activeTest = activeTest;</span>
<span class="fc" id="L180">			expectedMessages.clear();</span>
<span class="fc" id="L181">			allowedMessages.clear();</span>
<span class="fc" id="L182">		}</span>

		private void assertExpectedMessages() {
<span class="fc" id="L185">			StringBuilder sb = new StringBuilder();</span>
<span class="fc" id="L186">			Queue&lt;Throwable&gt; suppressed = new ArrayDeque&lt;&gt;();</span>
<span class="fc bfc" id="L187" title="All 2 branches covered.">			if (!expectedMessages.isEmpty()) {</span>
<span class="fc" id="L188">				sb.append(&quot;Not all expected log messages were logged\n&quot;);</span>
<span class="fc bfc" id="L189" title="All 2 branches covered.">				while (!expectedMessages.isEmpty())</span>
<span class="fc" id="L190">					sb.append(expectedMessages.poll()).append('\n');</span>
			}
<span class="fc bfc" id="L192" title="All 2 branches covered.">			if (!unexpectedMessages.isEmpty()) {</span>
<span class="fc" id="L193">				sb.append(&quot;Unexpected messages were logged&quot;);</span>
<span class="fc bfc" id="L194" title="All 2 branches covered.">				while (!unexpectedMessages.isEmpty())</span>
<span class="fc" id="L195">					suppressed.add(unexpectedMessages.poll());</span>
			}
<span class="fc bfc" id="L197" title="All 2 branches covered.">			if (sb.length() &gt; 0) {</span>
<span class="fc" id="L198">				final var e = new AssertionFailedError(sb.toString());</span>
<span class="fc" id="L199">				suppressed.forEach(e::addSuppressed);</span>
<span class="fc" id="L200">				throw e;</span>
			}
<span class="fc" id="L202">		}</span>

		@Override
		public void publish(LogRecord record) {
<span class="fc" id="L206">			var loggerName = record.getLoggerName();</span>
<span class="fc bfc" id="L207" title="All 2 branches covered.">			if (isPlatformLogger(loggerName)) {</span>
<span class="fc bfc" id="L208" title="All 2 branches covered.">				for (var handler : originalRootHandlers)</span>
<span class="fc" id="L209">					handler.publish(record);</span>
<span class="fc" id="L210">				return;</span>
			}

<span class="fc bfc" id="L213" title="All 2 branches covered.">			if (activeTest == null)</span>
<span class="fc" id="L214">				return;</span>

<span class="fc" id="L216">			final Queue&lt;PatternSyntaxException&gt; regexErrors = new ArrayDeque&lt;&gt;();</span>
<span class="fc bfc" id="L217" title="All 2 branches covered.">			for (var allowedMessage : allowedMessages)</span>
				try {
<span class="fc bfc" id="L219" title="All 2 branches covered.">					if (allowedMessage.isAllowed(record))</span>
<span class="fc" id="L220">						return;</span>
<span class="fc" id="L221">				} catch (PatternSyntaxException e) {</span>
<span class="fc" id="L222">					regexErrors.add(e);</span>
<span class="fc" id="L223">				}</span>

<span class="fc" id="L225">			final var expectedIterator = expectedMessages.iterator();</span>

<span class="fc bfc" id="L227" title="All 2 branches covered.">			while (expectedIterator.hasNext())</span>
				try {
<span class="fc bfc" id="L229" title="All 2 branches covered.">					if (expectedIterator.next().isExpected(record)) {</span>
<span class="fc" id="L230">						expectedIterator.remove();</span>
<span class="fc" id="L231">						return;</span>
					}
<span class="fc" id="L233">				} catch (PatternSyntaxException e) {</span>
<span class="fc" id="L234">					regexErrors.add(e);</span>
<span class="fc" id="L235">				}</span>

<span class="fc" id="L237">			final var unexpected = new AssertionFailedError(&quot;Unexpected log message &quot; + record.getLevel() + &quot; &quot;</span>
<span class="fc" id="L238">					+ record.getLoggerName() + &quot; &quot; + record.getMessage(), record.getThrown());</span>
<span class="fc" id="L239">			regexErrors.forEach(unexpected::addSuppressed);</span>
<span class="fc" id="L240">			unexpectedMessages.add(unexpected);</span>

<span class="fc" id="L242">			throw unexpected;</span>
		}

		@Override
		public void flush() {
<span class="fc" id="L247">		}</span>

		@Override
		public void close() throws SecurityException {
<span class="fc" id="L251">			reset(null);</span>
<span class="fc" id="L252">		}</span>
	}

	private static Handler[] originalRootHandlers;
	private static IuTestLogHandler testHandler;
	private static Level originalLevel;
	private static Logger root;
	private static Set&lt;String&gt; propertyDefinedPlatformLoggers;

	/**
	 * Determines if a logger name is related to a platform logger, and so should
	 * omitted from test expectations.
	 * 
	 * @param loggerName logger name
	 * @return true if name is associated with a platform logger
	 */
	static boolean isPlatformLogger(String loggerName) {
<span class="fc bfc" id="L269" title="All 2 branches covered.">		if (loggerName.startsWith(&quot;org.junit.&quot;) //</span>
<span class="fc bfc" id="L270" title="All 2 branches covered.">				|| loggerName.startsWith(&quot;org.mockito.&quot;) //</span>
<span class="fc bfc" id="L271" title="All 2 branches covered.">				|| loggerName.startsWith(&quot;org.apiguardian.&quot;) //</span>
<span class="fc bfc" id="L272" title="All 2 branches covered.">				|| loggerName.startsWith(&quot;net.bytebuddy.&quot;) //</span>
<span class="fc bfc" id="L273" title="All 2 branches covered.">				|| loggerName.startsWith(&quot;org.objenesis.&quot;) //</span>
<span class="fc bfc" id="L274" title="All 2 branches covered.">				|| loggerName.startsWith(&quot;org.opentest4j.&quot;))</span>
<span class="fc" id="L275">			return true;</span>

<span class="fc bfc" id="L277" title="All 2 branches covered.">		if (IuObject.isPlatformName(loggerName))</span>
<span class="fc" id="L278">			return true;</span>

<span class="fc bfc" id="L280" title="All 2 branches covered.">		if (propertyDefinedPlatformLoggers == null) {</span>
<span class="fc" id="L281">			var propertyDefinedPlatformLoggerNames = IuTest.getProperty(&quot;iu.util.test.platformLoggers&quot;);</span>
<span class="fc bfc" id="L282" title="All 2 branches covered.">			if (propertyDefinedPlatformLoggerNames == null)</span>
<span class="fc" id="L283">				propertyDefinedPlatformLoggers = Collections.emptySet();</span>
			else {
<span class="fc" id="L285">				Set&lt;String&gt; propertyDefinedPlatformLoggers = new HashSet&lt;&gt;();</span>
<span class="fc bfc" id="L286" title="All 2 branches covered.">				for (var propertyDefinedPlatformLogger : List.of(propertyDefinedPlatformLoggerNames.split(&quot;,&quot;))) {</span>
<span class="fc bfc" id="L287" title="All 2 branches covered.">					if (propertyDefinedPlatformLogger.charAt(propertyDefinedPlatformLogger.length() - 1) == '.')</span>
<span class="fc" id="L288">						propertyDefinedPlatformLogger = propertyDefinedPlatformLogger.substring(0,</span>
<span class="fc" id="L289">								propertyDefinedPlatformLogger.length() - 1);</span>
<span class="fc" id="L290">					propertyDefinedPlatformLoggers.add(propertyDefinedPlatformLogger);</span>
<span class="fc" id="L291">				}</span>
<span class="fc" id="L292">				IuTestLogger.propertyDefinedPlatformLoggers = propertyDefinedPlatformLoggers;</span>
			}
		}

<span class="fc bfc" id="L296" title="All 2 branches covered.">		if (propertyDefinedPlatformLoggers.contains(loggerName))</span>
<span class="fc" id="L297">			return true;</span>

<span class="fc bfc" id="L299" title="All 2 branches covered.">		for (var propertyDefinedPlatformLogger : propertyDefinedPlatformLoggers)</span>
<span class="fc bfc" id="L300" title="All 2 branches covered.">			if (loggerName.startsWith(propertyDefinedPlatformLogger + '.'))</span>
<span class="fc" id="L301">				return true;</span>

<span class="fc" id="L303">		return false;</span>
	}

	/**
	 * Initialization hook.
	 */
	static void init() {
<span class="fc" id="L310">		root = LogManager.getLogManager().getLogger(&quot;&quot;);</span>
<span class="fc" id="L311">		originalLevel = root.getLevel();</span>
<span class="fc" id="L312">		originalRootHandlers = root.getHandlers();</span>

<span class="fc bfc" id="L314" title="All 2 branches covered.">		for (var rootHandler : originalRootHandlers)</span>
<span class="fc" id="L315">			root.removeHandler(rootHandler);</span>

<span class="fc" id="L317">		testHandler = new IuTestLogHandler();</span>
<span class="fc" id="L318">		testHandler.setLevel(Level.ALL);</span>
<span class="fc" id="L319">		root.addHandler(testHandler);</span>
<span class="fc" id="L320">		root.setLevel(Level.ALL);</span>
<span class="fc" id="L321">	}</span>

	/**
	 * Test start hook.
	 * 
	 * @param name test name
	 */
	static void startTest(String name) {
<span class="fc" id="L329">		testHandler.activeTest = name;</span>
<span class="fc" id="L330">	}</span>

	/**
	 * Test finish hook.
	 * 
	 * @param name test name
	 */
	static void finishTest(String name) {
		try {
<span class="fc" id="L339">			assertEquals(testHandler.activeTest, name);</span>
<span class="fc" id="L340">			testHandler.assertExpectedMessages();</span>
		} finally {
<span class="fc" id="L342">			testHandler.reset(null);</span>
<span class="fc" id="L343">			propertyDefinedPlatformLoggers = null;</span>
		}
<span class="fc" id="L345">	}</span>

	/**
	 * Test destroy hook.
	 */
	static void destroy() {
<span class="fc" id="L351">		testHandler.flush();</span>
<span class="fc" id="L352">		testHandler.close();</span>
<span class="fc" id="L353">		root.removeHandler(testHandler);</span>

<span class="fc bfc" id="L355" title="All 2 branches covered.">		for (var handler : originalRootHandlers)</span>
<span class="fc" id="L356">			root.addHandler(handler);</span>

<span class="fc" id="L358">		root.setLevel(originalLevel);</span>
<span class="fc" id="L359">	}</span>

	/**
	 * Allows a log messages from a logger.
	 * 
	 * &lt;p&gt;
	 * Messages &lt;em&gt;may&lt;/em&gt; be logged zero or more times, and will be exempt from
	 * expectation checks.
	 * &lt;/p&gt;
	 * 
	 * @param loggerName Logger name prefix
	 * @param level      maximum log level to allow
	 */
	public static void allow(String loggerName, Level level) {
<span class="fc" id="L373">		assertNotNull(testHandler.activeTest);</span>
<span class="fc" id="L374">		testHandler.allowedMessages.offer(new LogRecordMatcher&lt;&gt;(loggerName, level, null, null, &quot;.*&quot;));</span>
<span class="fc" id="L375">	}</span>

	/**
	 * Allows a log message with or without an exception.
	 * 
	 * &lt;p&gt;
	 * The message &lt;em&gt;may&lt;/em&gt; be logged zero or more times, and will be exempt
	 * from expectation checks.
	 * &lt;/p&gt;
	 * 
	 * @param loggerName Logger name prefix
	 * @param level      maximum log level to allow
	 * @param message    regular expression to match against the message
	 */
	public static void allow(String loggerName, Level level, String message) {
<span class="fc" id="L390">		assertNotNull(testHandler.activeTest);</span>
<span class="fc" id="L391">		testHandler.allowedMessages.offer(new LogRecordMatcher&lt;&gt;(loggerName, level, null, null, message));</span>
<span class="fc" id="L392">	}</span>

	/**
	 * Allows a log message with a thrown exception.
	 * 
	 * &lt;p&gt;
	 * The message &lt;em&gt;may&lt;/em&gt; be logged zero or more times, and will be exempt
	 * from expectation checks.
	 * &lt;/p&gt;
	 * 
	 * @param loggerName  Logger name prefix
	 * @param level       maximum log level to allow
	 * @param message     regular expression to match against the message
	 * @param thrownClass Expected exception class, must match exactly
	 */
	public static void allow(String loggerName, Level level, String message, Class&lt;? extends Throwable&gt; thrownClass) {
<span class="fc" id="L408">		assertNotNull(testHandler.activeTest);</span>
<span class="fc" id="L409">		testHandler.allowedMessages</span>
<span class="fc" id="L410">				.offer(new LogRecordMatcher&lt;&gt;(loggerName, level, Objects.requireNonNull(thrownClass), null, message));</span>
<span class="fc" id="L411">	}</span>

	/**
	 * Allows a log message with a thrown exception.
	 * 
	 * &lt;p&gt;
	 * The message &lt;em&gt;may&lt;/em&gt; be logged zero or more times, and will be exempt
	 * from expectation checks.
	 * &lt;/p&gt;
	 * 
	 * @param &lt;T&gt;         Thrown exception type
	 * 
	 * @param loggerName  Logger name prefix
	 * @param level       maximum log level to allow
	 * @param message     regular expression to match against the message
	 * @param thrownClass Expected exception class, must match exactly
	 * @param thrownTest  Expected exception test
	 */
	public static &lt;T extends Throwable&gt; void allow(String loggerName, Level level, String message, Class&lt;T&gt; thrownClass,
			Predicate&lt;T&gt; thrownTest) {
<span class="fc" id="L431">		assertNotNull(testHandler.activeTest);</span>
<span class="fc" id="L432">		testHandler.allowedMessages.offer(</span>
<span class="fc" id="L433">				new LogRecordMatcher&lt;&gt;(loggerName, level, Objects.requireNonNull(thrownClass), thrownTest, message));</span>
<span class="fc" id="L434">	}</span>

	/**
	 * Expects a log message with no thrown exception.
	 * 
	 * @param loggerName Logger name, must match exactly
	 * @param level      level, must match exactly
	 * @param message    regular expression to match against the message
	 */
	public static void expect(String loggerName, Level level, String message) {
<span class="fc" id="L444">		assertNotNull(testHandler.activeTest);</span>
<span class="fc" id="L445">		testHandler.expectedMessages.offer(new LogRecordMatcher&lt;&gt;(loggerName, level, null, null, message));</span>
<span class="fc" id="L446">	}</span>

	/**
	 * Expects a log message with a thrown exception.
	 * 
	 * @param loggerName  Logger name, must match exactly
	 * @param level       level, must match exactly
	 * @param message     regular expression to match against the message
	 * @param thrownClass Expected exception class, must match exactly
	 */
	public static void expect(String loggerName, Level level, String message, Class&lt;? extends Throwable&gt; thrownClass) {
<span class="fc" id="L457">		assertNotNull(testHandler.activeTest);</span>
<span class="fc" id="L458">		testHandler.expectedMessages</span>
<span class="fc" id="L459">				.offer(new LogRecordMatcher&lt;&gt;(loggerName, level, Objects.requireNonNull(thrownClass), null, message));</span>
<span class="fc" id="L460">	}</span>

	/**
	 * Expects a log message with a thrown exception.
	 * 
	 * @param &lt;T&gt;         Thrown exception type
	 * 
	 * @param loggerName  Logger name, must match exactly
	 * @param level       level, must match exactly
	 * @param message     regular expression to match against the message
	 * @param thrownClass Expected exception class, must match exactly
	 * @param thrownTest  Expected exception test
	 */
	public static &lt;T extends Throwable&gt; void expect(String loggerName, Level level, String message,
			Class&lt;T&gt; thrownClass, Predicate&lt;T&gt; thrownTest) {
<span class="fc" id="L475">		assertNotNull(testHandler.activeTest);</span>
<span class="fc" id="L476">		testHandler.expectedMessages.offer(</span>
<span class="fc" id="L477">				new LogRecordMatcher&lt;&gt;(loggerName, level, Objects.requireNonNull(thrownClass), thrownTest, message));</span>
<span class="fc" id="L478">	}</span>

	/**
	 * Asserts that all expected messages declared so far have been logged.
	 */
	public static void assertExpectedMessages() {
<span class="fc" id="L484">		assertNotNull(testHandler.activeTest);</span>
<span class="fc" id="L485">		testHandler.assertExpectedMessages();</span>
<span class="fc" id="L486">	}</span>

	/**
	 * Clears an unexpected log message from the pending queue.
	 * 
	 * @param unexpected error related to an unexpected log message
	 */
	static void clearUnexpected(Throwable unexpected) {
<span class="fc" id="L494">		testHandler.unexpectedMessages.remove(unexpected);</span>
<span class="fc" id="L495">	}</span>

	private IuTestLogger() {
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.10.202304240956</span></div></body></html>