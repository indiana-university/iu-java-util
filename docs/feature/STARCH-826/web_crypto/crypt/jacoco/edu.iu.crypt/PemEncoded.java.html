<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>PemEncoded.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">IU Web Cryptography Utilities</a> &gt; <a href="index.source.html" class="el_package">edu.iu.crypt</a> &gt; <span class="el_source">PemEncoded.java</span></div><h1>PemEncoded.java</h1><pre class="source lang-java linenums">/*
 * Copyright Â© 2024 Indiana University
 * All rights reserved.
 *
 * BSD 3-Clause License
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 
 * - Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 * 
 * - Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 * 
 * - Neither the name of the copyright holder nor the names of its
 *   contributors may be used to endorse or promote products derived from
 *   this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package edu.iu.crypt;

import java.io.ByteArrayInputStream;
import java.io.InputStream;
import java.net.URI;
import java.security.KeyFactory;
import java.security.KeyPair;
import java.security.PrivateKey;
import java.security.PublicKey;
import java.security.cert.CertificateFactory;
import java.security.cert.X509CRL;
import java.security.cert.X509Certificate;
import java.security.interfaces.RSAPrivateCrtKey;
import java.security.interfaces.RSAPublicKey;
import java.security.spec.PKCS8EncodedKeySpec;
import java.security.spec.X509EncodedKeySpec;
import java.time.Duration;
import java.util.ArrayDeque;
import java.util.Base64;
import java.util.Iterator;
import java.util.Map;
import java.util.NoSuchElementException;
import java.util.Queue;

import edu.iu.IuCacheMap;
import edu.iu.IuException;
import edu.iu.IuIterable;
import edu.iu.IuStream;
import edu.iu.IuText;
import edu.iu.client.IuHttp;
import edu.iu.client.IuJson;
import edu.iu.client.IuJsonAdapter;
import jakarta.json.JsonString;

/**
 * Reads PEM-encoded key and/or certificate data.
 */
public final class PemEncoded {

<span class="fc" id="L71">	private static Map&lt;URI, X509Certificate[]&gt; CERT_CACHE = new IuCacheMap&lt;&gt;(Duration.ofMinutes(15L));</span>

	/**
	 * JSON type adapter for {@link X509Certificate}.
	 */
<span class="fc" id="L76">	public static final IuJsonAdapter&lt;X509Certificate&gt; CERT_JSON = IuJsonAdapter.from(</span>
<span class="fc" id="L77">			a -&gt; asCertificate(IuText.base64(((JsonString) a).getString())),</span>
<span class="fc" id="L78">			a -&gt; IuJson.string(IuText.base64(IuException.unchecked(a::getEncoded))));</span>

	/**
	 * Enumerates encoded key type.
	 */
<span class="fc" id="L83">	public enum KeyType {</span>
		/**
		 * Private key.
		 */
<span class="fc" id="L87">		PRIVATE_KEY,</span>

		/**
		 * Public key.
		 */
<span class="fc" id="L92">		PUBLIC_KEY,</span>

		/**
		 * X509 certificate.
		 */
<span class="fc" id="L97">		CERTIFICATE,</span>

		/**
		 * X509 certificate revocation list.
		 */
<span class="fc" id="L102">		X509_CRL;</span>
	}

	/**
	 * Reads PEM-encoded key and/or certificate data.
	 * 
	 * @param in input stream of PEM-encoded key and/or certificate data, multiple
	 *           entries may be concatenated
	 * @return Parsed PEM-encoded data
	 * @see &lt;a href=
	 *      &quot;https://datatracker.ietf.org/doc/html/rfc4945#section-6.1&quot;&gt;RFC-4945
	 *      Section 6.1&lt;/a&gt;
	 */
	public static Iterator&lt;PemEncoded&gt; parse(InputStream in) {
<span class="fc" id="L116">		return IuException.unchecked(() -&gt; parse(IuText.utf8(IuStream.read(in))));</span>
	}

	/**
	 * Parses PEM-encoded key and/or certificate data.
	 * 
	 * @param pemEncoded PEM-encoded key and/or certificate data, may be
	 *                   concatenated
	 * @return Parsed PEM-encoded data
	 * @see &lt;a href=
	 *      &quot;https://datatracker.ietf.org/doc/html/rfc4945#section-6.1&quot;&gt;RFC-4945
	 *      Section 6.1&lt;/a&gt;
	 */
	public static Iterator&lt;PemEncoded&gt; parse(String pemEncoded) {
<span class="fc" id="L130">		final var length = pemEncoded.length();</span>
<span class="fc" id="L131">		return new Iterator&lt;PemEncoded&gt;() {</span>
<span class="fc" id="L132">			private int start = 0;</span>
<span class="fc" id="L133">			private int end = -1;</span>

			@Override
			public boolean hasNext() {
<span class="fc bfc" id="L137" title="All 2 branches covered.">				if (end &lt; start) {</span>
					// * 11 chars: &quot;-----BEGIN &quot;
					// * 10-11 chars: key type
					// * 5 chars: &quot;-----&quot;
					// =&gt; 27 chars
<span class="fc bfc" id="L142" title="All 2 branches covered.">					if (start + 27 &gt; length)</span>
<span class="fc" id="L143">						return false;</span>
<span class="fc bfc" id="L144" title="All 2 branches covered.">					else if (!&quot;-----BEGIN &quot;.equals(pemEncoded.substring(start, start + 11)))</span>
<span class="fc" id="L145">						end = pemEncoded.length();</span>
					else {
<span class="fc" id="L147">						start += 11;</span>
<span class="fc" id="L148">						final var endOfKeyType = pemEncoded.indexOf(&quot;-----&quot;, start);</span>
<span class="fc" id="L149">						final var keyType = pemEncoded.substring(start, endOfKeyType);</span>
<span class="fc" id="L150">						start += keyType.length() + 5;</span>

<span class="fc" id="L152">						int endOfKey = pemEncoded.indexOf(&quot;-----END &quot; + keyType + &quot;-----&quot;, start);</span>
<span class="fc bfc" id="L153" title="All 2 branches covered.">						if (endOfKey == -1)</span>
<span class="fc" id="L154">							end = length;</span>
						else
<span class="fc" id="L156">							end = endOfKey;</span>
					}
				}

<span class="fc" id="L160">				return true;</span>
			}

			@Override
			public PemEncoded next() {
<span class="fc bfc" id="L165" title="All 2 branches covered.">				if (!hasNext())</span>
<span class="fc" id="L166">					throw new NoSuchElementException();</span>

<span class="fc" id="L168">				final var sb = new StringBuilder(pemEncoded.substring(start, end));</span>
<span class="fc bfc" id="L169" title="All 2 branches covered.">				for (var i = 0; i &lt; sb.length(); i++)</span>
<span class="fc bfc" id="L170" title="All 2 branches covered.">					if (Character.isWhitespace(sb.charAt(i)))</span>
<span class="fc" id="L171">						sb.deleteCharAt(i--);</span>

				final KeyType keyType;
				try {
<span class="fc bfc" id="L175" title="All 2 branches covered.">					if (start &lt; 24)</span>
<span class="fc" id="L176">						keyType = KeyType.CERTIFICATE;</span>
					else {
<span class="fc" id="L178">						keyType = KeyType.valueOf(</span>
<span class="fc" id="L179">								pemEncoded.substring(pemEncoded.lastIndexOf(&quot;-----BEGIN &quot;, start) + 11, start - 5)</span>
<span class="fc" id="L180">										.replace(' ', '_'));</span>
<span class="fc bfc" id="L181" title="All 2 branches covered.">						if (end &gt;= length)</span>
<span class="fc" id="L182">							throw new IllegalArgumentException(</span>
<span class="fc" id="L183">									&quot;Missing -----END &quot; + keyType.name().replace('_', ' ') + &quot;-----&quot;);</span>
					}
				} finally {
<span class="fc" id="L186">					final var nextStart = pemEncoded.indexOf(&quot;-----BEGIN &quot;, end);</span>
<span class="fc bfc" id="L187" title="All 2 branches covered.">					if (nextStart == -1)</span>
<span class="fc" id="L188">						start = length + 1;</span>
					else
<span class="fc" id="L190">						start = nextStart;</span>
				}

<span class="fc" id="L193">				return new PemEncoded(keyType, Base64.getDecoder().decode(sb.toString()));</span>
			}
		};
	}

	/**
	 * Serializes an X509 certificate chain as PEM encoded.
	 * 
	 * @param cert certificate chain
	 * @return PEM encoded certificate data
	 */
	public static Iterator&lt;PemEncoded&gt; serialize(X509Certificate... cert) {
<span class="fc" id="L205">		return IuIterable</span>
<span class="fc" id="L206">				.map(IuIterable.iter(cert),</span>
<span class="fc" id="L207">						c -&gt; IuException.unchecked(() -&gt; new PemEncoded(KeyType.CERTIFICATE, c.getEncoded())))</span>
<span class="fc" id="L208">				.iterator();</span>
	}

	/**
	 * Checks that public and private key, and certificate chain, are related and
	 * converts to PEM encoded form.
	 * 
	 * &lt;p&gt;
	 * Public key will be omitted if it matches the first certificate in the chain,
	 * or if it is fully encoded as a subset of the private key.
	 * &lt;/p&gt;
	 * 
	 * @param keyPair public and optional private key to export
	 * @param cert    certificate chain
	 * @return PEM encoded key data
	 */
	public static Iterator&lt;PemEncoded&gt; serialize(KeyPair keyPair, X509Certificate... cert) {
<span class="fc" id="L225">		final Queue&lt;PemEncoded&gt; q = new ArrayDeque&lt;&gt;();</span>
<span class="fc" id="L226">		var pub = keyPair.getPublic();</span>
<span class="fc bfc" id="L227" title="All 2 branches covered.">		if (cert.length &gt; 0)</span>
<span class="fc bfc" id="L228" title="All 2 branches covered.">			if (pub == null)</span>
<span class="fc" id="L229">				pub = cert[0].getPublicKey();</span>
<span class="fc bfc" id="L230" title="All 2 branches covered.">			else if (!pub.equals(cert[0].getPublicKey()))</span>
<span class="fc" id="L231">				throw new IllegalArgumentException(&quot;Public key doesn't match certificate&quot;);</span>

<span class="fc" id="L233">		final var priv = keyPair.getPrivate();</span>
<span class="fc bfc" id="L234" title="All 2 branches covered.">		if (priv != null)</span>
<span class="fc" id="L235">			q.add(new PemEncoded(KeyType.PRIVATE_KEY, priv.getEncoded()));</span>

<span class="fc bfc" id="L237" title="All 2 branches covered.">		if (priv instanceof RSAPrivateCrtKey) {</span>
<span class="fc" id="L238">			final var rsa = (RSAPrivateCrtKey) priv;</span>
<span class="fc" id="L239">			final var rsapub = (RSAPublicKey) pub;</span>
<span class="fc bfc" id="L240" title="All 2 branches covered.">			if (!rsa.getModulus().equals(rsapub.getModulus())</span>
<span class="fc bfc" id="L241" title="All 2 branches covered.">					|| !rsa.getPublicExponent().equals(rsapub.getPublicExponent()))</span>
<span class="fc" id="L242">				throw new IllegalArgumentException(&quot;RSA Public key doesn't match private&quot;);</span>
<span class="fc bfc" id="L243" title="All 2 branches covered.">		} else if (cert.length == 0)</span>
<span class="fc" id="L244">			q.add(new PemEncoded(KeyType.PUBLIC_KEY, pub.getEncoded()));</span>

<span class="fc" id="L246">		return IuIterable.cat(q, IuIterable.of(() -&gt; serialize(cert))).iterator();</span>
	}

	/**
	 * Reads a certificate chain from a URI.
	 * 
	 * @param uri {@link URI}
	 * @return certificate chain
	 * @see &lt;a href=
	 *      &quot;https://datatracker.ietf.org/doc/html/rfc4945#section-6.1&quot;&gt;RFC-4945 PKI
	 *      Section 6.1&lt;/a&gt;
	 */
	public static X509Certificate[] getCertificateChain(URI uri) {
<span class="fc" id="L259">		var chain = CERT_CACHE.get(uri);</span>
<span class="fc bfc" id="L260" title="All 2 branches covered.">		if (chain == null)</span>
<span class="fc" id="L261">			CERT_CACHE.put(uri, chain = getCertificateChain((Iterator&lt;PemEncoded&gt;) IuException</span>
<span class="fc" id="L262">					.unchecked(() -&gt; IuHttp.get(uri, IuHttp.validate(PemEncoded::parse, IuHttp.OK)))));</span>
<span class="fc" id="L263">		return chain;</span>
	}

	/**
	 * Converts parsed PEM data to a certificate chain.
	 * 
	 * @param pem PEM encoded certificate chain
	 * @return certificate chain
	 */
	public static X509Certificate[] getCertificateChain(Iterator&lt;PemEncoded&gt; pem) {
<span class="fc" id="L273">		return IuException.unchecked(() -&gt; {</span>
<span class="fc" id="L274">			final var certFactory = CertificateFactory.getInstance(&quot;X.509&quot;);</span>
<span class="fc" id="L275">			final Queue&lt;X509Certificate&gt; c = new ArrayDeque&lt;&gt;();</span>
<span class="fc bfc" id="L276" title="All 2 branches covered.">			while (pem.hasNext()) {</span>
<span class="fc" id="L277">				final var n = pem.next();</span>
<span class="fc bfc" id="L278" title="All 2 branches covered.">				if (!PemEncoded.KeyType.CERTIFICATE.equals(n.keyType))</span>
<span class="fc" id="L279">					throw new IllegalArgumentException();</span>
<span class="fc" id="L280">				c.offer((X509Certificate) certFactory.generateCertificate(new ByteArrayInputStream(n.encoded)));</span>
<span class="fc" id="L281">			}</span>
<span class="fc" id="L282">			return c.toArray(new X509Certificate[c.size()]);</span>
		});
	}

	private static X509Certificate asCertificate(byte[] encoded) {
<span class="fc" id="L287">		return IuException.unchecked(() -&gt; (X509Certificate) CertificateFactory.getInstance(&quot;X.509&quot;)</span>
<span class="fc" id="L288">				.generateCertificate(new ByteArrayInputStream(encoded)));</span>
	}

	private static X509CRL asCRL(byte[] encoded) {
<span class="fc" id="L292">		return IuException.unchecked(</span>
<span class="fc" id="L293">				() -&gt; (X509CRL) CertificateFactory.getInstance(&quot;X.509&quot;).generateCRL(new ByteArrayInputStream(encoded)));</span>
	}

	private final KeyType keyType;
	private final byte[] encoded;

	/**
	 * Gets the key type.
	 * 
	 * @return {@link KeyType}
	 */
	public KeyType getKeyType() {
<span class="fc" id="L305">		return keyType;</span>
	}

	/**
	 * Gets the key as a public key when {@link #keyType} is
	 * {@link KeyType#PUBLIC_KEY}.
	 * 
	 * @param algorithm {@link KeyFactory} algorithm
	 * @return public key
	 */
	public PublicKey asPublic(String algorithm) {
<span class="fc bfc" id="L316" title="All 2 branches covered.">		if (!keyType.equals(KeyType.PUBLIC_KEY))</span>
<span class="fc" id="L317">			throw new IllegalStateException();</span>
<span class="fc" id="L318">		return IuException</span>
<span class="fc" id="L319">				.unchecked(() -&gt; KeyFactory.getInstance(algorithm).generatePublic(new X509EncodedKeySpec(encoded)));</span>
	}

	/**
	 * Gets the key as a private key when {@link #keyType} is
	 * {@link KeyType#PRIVATE_KEY}.
	 * 
	 * @param algorithm {@link KeyFactory} algorithm
	 * @return private key
	 */
	public PrivateKey asPrivate(String algorithm) {
<span class="fc bfc" id="L330" title="All 2 branches covered.">		if (!keyType.equals(KeyType.PRIVATE_KEY))</span>
<span class="fc" id="L331">			throw new IllegalStateException();</span>
<span class="fc" id="L332">		return IuException</span>
<span class="fc" id="L333">				.unchecked(() -&gt; KeyFactory.getInstance(algorithm).generatePrivate(new PKCS8EncodedKeySpec(encoded)));</span>
	}

	/**
	 * Gets the certificate when {@link #keyType} is {@link KeyType#CERTIFICATE}.
	 * 
	 * @return private key
	 */
	public X509Certificate asCertificate() {
<span class="fc bfc" id="L342" title="All 2 branches covered.">		if (!keyType.equals(KeyType.CERTIFICATE))</span>
<span class="fc" id="L343">			throw new IllegalStateException();</span>
<span class="fc" id="L344">		return asCertificate(encoded);</span>
	}

	/**
	 * Gets the certificate when {@link #keyType} is {@link KeyType#CERTIFICATE}.
	 * 
	 * @return private key
	 */
	public X509CRL asCRL() {
<span class="fc bfc" id="L353" title="All 2 branches covered.">		if (!keyType.equals(KeyType.X509_CRL))</span>
<span class="fc" id="L354">			throw new IllegalStateException();</span>
<span class="fc" id="L355">		return asCRL(encoded);</span>
	}

	@Override
	public String toString() {
<span class="fc" id="L360">		final var headerType = keyType.name().replace('_', ' ');</span>
<span class="fc" id="L361">		final var sb = new StringBuilder();</span>
<span class="fc" id="L362">		sb.append(&quot;-----BEGIN &quot;);</span>
<span class="fc" id="L363">		sb.append(headerType);</span>
<span class="fc" id="L364">		sb.append(&quot;-----&quot;);</span>

<span class="fc" id="L366">		var pos = sb.length();</span>
<span class="fc" id="L367">		sb.append(IuText.base64(encoded));</span>
<span class="fc bfc" id="L368" title="All 2 branches covered.">		for (; pos &lt; sb.length() - 1; pos += 65)</span>
<span class="fc" id="L369">			sb.insert(pos, '\n');</span>

<span class="fc" id="L371">		sb.append(&quot;\n-----END &quot;);</span>
<span class="fc" id="L372">		sb.append(headerType);</span>
<span class="fc" id="L373">		sb.append(&quot;-----\n&quot;);</span>
<span class="fc" id="L374">		return sb.toString();</span>
	}

<span class="fc" id="L377">	private PemEncoded(KeyType keyType, byte[] encoded) {</span>
<span class="fc" id="L378">		this.keyType = keyType;</span>
<span class="fc" id="L379">		this.encoded = encoded;</span>
<span class="fc" id="L380">	}</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.10.202304240956</span></div></body></html>