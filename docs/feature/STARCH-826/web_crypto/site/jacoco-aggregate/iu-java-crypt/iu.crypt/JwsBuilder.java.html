<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>JwsBuilder.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">IU Java Utilities API Reference</a> &gt; <a href="../index.html" class="el_bundle">iu-java-crypt</a> &gt; <a href="index.source.html" class="el_package">iu.crypt</a> &gt; <span class="el_source">JwsBuilder.java</span></div><h1>JwsBuilder.java</h1><pre class="source lang-java linenums">/*
 * Copyright Â© 2024 Indiana University
 * All rights reserved.
 *
 * BSD 3-Clause License
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 
 * - Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 * 
 * - Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 * 
 * - Neither the name of the copyright holder nor the names of its
 *   contributors may be used to endorse or promote products derived from
 *   this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package iu.crypt;

import java.io.InputStream;
import java.net.URI;
import java.security.Signature;
import java.security.spec.MGF1ParameterSpec;
import java.security.spec.PSSParameterSpec;
import java.util.ArrayDeque;
import java.util.Collections;
import java.util.Deque;
import java.util.LinkedHashSet;
import java.util.Objects;
import java.util.Queue;
import java.util.Set;

import javax.crypto.Mac;
import javax.crypto.spec.SecretKeySpec;

import edu.iu.IuException;
import edu.iu.IuIterable;
import edu.iu.IuObject;
import edu.iu.IuStream;
import edu.iu.IuText;
import edu.iu.client.IuJson;
import edu.iu.client.IuJsonAdapter;
import edu.iu.crypt.WebCryptoHeader.Param;
import edu.iu.crypt.WebKey;
import edu.iu.crypt.WebKey.Algorithm;
import edu.iu.crypt.WebKey.Use;
import edu.iu.crypt.WebSignature.Builder;
import edu.iu.crypt.WebSignedPayload;
import jakarta.json.JsonObject;
import jakarta.json.JsonValue;

/**
 * Collects inputs for {@link Jws} encrypted messages.
 */
public class JwsBuilder implements Builder&lt;JwsBuilder&gt; {
	static {
<span class="fc" id="L71">		IuObject.assertNotOpen(JwsBuilder.class);</span>
<span class="fc" id="L72">	}</span>

	/**
	 * Parses JWS signed payload from serialized form
	 * 
	 * @param jws compact or JSON serialized from
	 * @return JWS signed payload
	 */
	public static JwsSignedPayload parse(String jws) {
<span class="fc bfc" id="L81" title="All 2 branches covered.">		if (jws.startsWith(&quot;{&quot;)) {</span>
<span class="fc" id="L82">			final var json = IuJson.parse(jws).asJsonObject();</span>
<span class="fc" id="L83">			final var payload = IuJson.get(json, &quot;payload&quot;, UnpaddedBinary.JSON);</span>

<span class="fc" id="L85">			var signatures = IuJson.get(json, &quot;signatures&quot;,</span>
<span class="fc" id="L86">					IuJsonAdapter.&lt;Iterable&lt;Jws&gt;&gt;of(Iterable.class, IuJsonAdapter.from(Jws::parse)));</span>
<span class="fc bfc" id="L87" title="All 2 branches covered.">			if (signatures == null)</span>
<span class="fc" id="L88">				signatures = Collections.singleton(Jws.parse(json));</span>

<span class="fc" id="L90">			return new JwsSignedPayload(payload, signatures);</span>
		} else {
<span class="fc" id="L92">			final var compact = UnpaddedBinary.compact(jws);</span>
<span class="fc" id="L93">			final var protectedHeader = Objects</span>
<span class="fc" id="L94">					.requireNonNull(UnpaddedBinary.compactJson(compact.next()), &quot;protected header required&quot;)</span>
<span class="fc" id="L95">					.asJsonObject();</span>
<span class="fc" id="L96">			final var payload = UnpaddedBinary.base64Url(compact.next());</span>
<span class="fc" id="L97">			final var signature = UnpaddedBinary.base64Url(compact.next());</span>
<span class="fc bfc" id="L98" title="All 2 branches covered.">			if (compact.hasNext())</span>
<span class="fc" id="L99">				throw new IllegalArgumentException(&quot;Unexpected content after JWS signature&quot;);</span>

<span class="fc" id="L101">			return new JwsSignedPayload(payload,</span>
<span class="fc" id="L102">					IuIterable.iter(new Jws(protectedHeader, new Jose(protectedHeader), signature)));</span>
		}
	}

	private class PendingSignature extends JoseBuilder&lt;PendingSignature&gt; {
<span class="fc" id="L107">		private PendingSignature(Algorithm algorithm) {</span>
<span class="fc" id="L108">			super(algorithm);</span>
<span class="fc bfc" id="L109" title="All 2 branches covered.">			if (!algorithm.use.equals(Use.SIGN))</span>
<span class="fc" id="L110">				throw new IllegalArgumentException(&quot;Not a signature algorithm &quot; + algorithm);</span>
<span class="fc" id="L111">		}</span>

		@Override
		protected JsonValue param(String name) {
<span class="fc" id="L115">			return super.param(name);</span>
		}

		private Jose header() {
<span class="fc" id="L119">			return new Jose(toJson());</span>
		}

		private JsonObject protectedHeader() {
<span class="fc" id="L123">			final var protectedHeaderBuilder = IuJson.object();</span>
<span class="fc bfc" id="L124" title="All 2 branches covered.">			if (compact)</span>
<span class="fc bfc" id="L125" title="All 2 branches covered.">				for (final var paramName : paramNames())</span>
<span class="fc" id="L126">					protectedHeaderBuilder.add(paramName, param(paramName));</span>
<span class="fc bfc" id="L127" title="All 2 branches covered.">			else if (protectedParameters.isEmpty())</span>
<span class="fc" id="L128">				return null;</span>
			else
<span class="fc bfc" id="L130" title="All 2 branches covered.">				for (final var paramName : protectedParameters)</span>
<span class="fc" id="L131">					protectedHeaderBuilder.add(paramName, Objects.requireNonNull(param(paramName), paramName));</span>

<span class="fc" id="L133">			return protectedHeaderBuilder.build();</span>
		}

	}

	private boolean compact;
<span class="fc" id="L139">	private Set&lt;String&gt; protectedParameters = new LinkedHashSet&lt;&gt;();</span>
<span class="fc" id="L140">	private Deque&lt;PendingSignature&gt; pendingSignatures = new ArrayDeque&lt;&gt;();</span>

	/**
	 * Constructor.
	 * 
	 * @param algorithm {@link Algorithm}
	 */
<span class="fc" id="L147">	public JwsBuilder(Algorithm algorithm) {</span>
<span class="fc" id="L148">		next(algorithm);</span>
<span class="fc" id="L149">	}</span>

	@Override
	public JwsBuilder next(Algorithm algorithm) {
<span class="fc" id="L153">		pendingSignatures.offer(new PendingSignature(algorithm));</span>
<span class="fc" id="L154">		return this;</span>
	}

	@Override
	public JwsBuilder compact() {
<span class="fc" id="L159">		compact = true;</span>
<span class="fc" id="L160">		return this;</span>
	}

	@Override
	public JwsBuilder protect(Param... params) {
<span class="fc bfc" id="L165" title="All 2 branches covered.">		for (final var param : params)</span>
<span class="fc" id="L166">			protectedParameters.add(param.name);</span>
<span class="fc" id="L167">		return this;</span>
	}

	@Override
	public JwsBuilder protect(String... params) {
<span class="fc bfc" id="L172" title="All 2 branches covered.">		for (final var param : params)</span>
<span class="fc" id="L173">			protectedParameters.add(param);</span>
<span class="fc" id="L174">		return this;</span>
	}

	@Override
	public JwsBuilder keyId(String keyId) {
<span class="fc" id="L179">		pendingSignatures.peekLast().keyId(keyId);</span>
<span class="fc" id="L180">		return this;</span>
	}

	@Override
	public JwsBuilder wellKnown(URI uri) {
<span class="fc" id="L185">		pendingSignatures.peekLast().wellKnown(uri);</span>
<span class="fc" id="L186">		return this;</span>
	}

	@Override
	public JwsBuilder wellKnown(WebKey key) {
<span class="fc" id="L191">		pendingSignatures.peekLast().wellKnown(key);</span>
<span class="fc" id="L192">		return this;</span>
	}

	@Override
	public JwsBuilder key(WebKey key) {
<span class="fc" id="L197">		pendingSignatures.peekLast().key(key);</span>
<span class="fc" id="L198">		return this;</span>
	}

	@Override
	public JwsBuilder type(String type) {
<span class="fc" id="L203">		pendingSignatures.peekLast().type(type);</span>
<span class="fc" id="L204">		return this;</span>
	}

	@Override
	public JwsBuilder contentType(String contentType) {
<span class="fc" id="L209">		pendingSignatures.peekLast().contentType(contentType);</span>
<span class="fc" id="L210">		return this;</span>
	}

	@Override
	public JwsBuilder crit(String... parameterNames) {
<span class="fc" id="L215">		pendingSignatures.peekLast().crit(parameterNames);</span>
<span class="fc" id="L216">		return this;</span>
	}

	@Override
	public &lt;T&gt; JwsBuilder param(Param param, T value) {
<span class="fc" id="L221">		pendingSignatures.peekLast().param(param, value);</span>
<span class="fc" id="L222">		return this;</span>
	}

	@Override
	public &lt;T&gt; JwsBuilder param(String name, T value) {
<span class="fc" id="L227">		pendingSignatures.peekLast().param(name, value);</span>
<span class="fc" id="L228">		return this;</span>
	}

	@Override
	public WebSignedPayload sign(InputStream in) {
<span class="fc" id="L233">		final var payload = IuException.&lt;InputStream, byte[]&gt;unchecked(in, IuStream::read);</span>

<span class="fc" id="L235">		final Queue&lt;Jws&gt; signatures = new ArrayDeque&lt;&gt;();</span>
<span class="fc bfc" id="L236" title="All 2 branches covered.">		for (final var pendingSignature : pendingSignatures) {</span>
<span class="fc" id="L237">			final var key = pendingSignature.key();</span>
<span class="fc" id="L238">			final var header = pendingSignature.header();</span>
<span class="fc" id="L239">			final var algorithm = header.getAlgorithm();</span>

<span class="fc" id="L241">			final var protectedHeader = pendingSignature.protectedHeader();</span>
<span class="fc" id="L242">			final var encodedHeader = UnpaddedBinary</span>
<span class="fc" id="L243">					.base64Url(IuText.utf8(Objects.requireNonNullElse(protectedHeader, &quot;&quot;).toString()));</span>
<span class="fc" id="L244">			final var encodedPayload = UnpaddedBinary.base64Url(payload);</span>
<span class="fc" id="L245">			final var signingInput = encodedHeader + '.' + encodedPayload;</span>
<span class="fc" id="L246">			final var dataToSign = IuText.utf8(signingInput);</span>

			final byte[] signature;
<span class="fc bfc" id="L249" title="All 2 branches covered.">			if (algorithm.algorithm.startsWith(&quot;Hmac&quot;)) {</span>
<span class="fc" id="L250">				signature = IuException.unchecked(() -&gt; {</span>
<span class="fc" id="L251">					final var mac = Mac.getInstance(algorithm.algorithm);</span>
<span class="fc" id="L252">					mac.init(new SecretKeySpec(key.getKey(), &quot;Hmac&quot;));</span>
<span class="fc" id="L253">					return mac.doFinal(dataToSign);</span>
				});
			} else
<span class="fc" id="L256">				signature = IuException.unchecked(() -&gt; {</span>
<span class="fc" id="L257">					final var sig = Signature.getInstance(algorithm.algorithm);</span>
<span class="fc bfc" id="L258" title="All 4 branches covered.">					switch (algorithm) {</span>
					case PS256:
<span class="fc" id="L260">						sig.setParameter(new PSSParameterSpec(MGF1ParameterSpec.SHA256.getDigestAlgorithm(), &quot;MGF1&quot;,</span>
								MGF1ParameterSpec.SHA256, algorithm.size / 8, 1));
<span class="fc" id="L262">						break;</span>
					case PS384:
<span class="fc" id="L264">						sig.setParameter(new PSSParameterSpec(MGF1ParameterSpec.SHA384.getDigestAlgorithm(), &quot;MGF1&quot;,</span>
								MGF1ParameterSpec.SHA384, algorithm.size / 8, 1));
<span class="fc" id="L266">						break;</span>
					case PS512:
<span class="fc" id="L268">						sig.setParameter(new PSSParameterSpec(MGF1ParameterSpec.SHA512.getDigestAlgorithm(), &quot;MGF1&quot;,</span>
								MGF1ParameterSpec.SHA512, algorithm.size / 8, 1));
<span class="fc" id="L270">						break;</span>
					default:
						break;
					}
<span class="fc" id="L274">					sig.initSign(key.getPrivateKey());</span>
<span class="fc" id="L275">					sig.update(dataToSign);</span>
<span class="fc" id="L276">					return sig.sign();</span>
				});

<span class="fc" id="L279">			signatures.add(new Jws(protectedHeader, header, signature));</span>
<span class="fc" id="L280">		}</span>

<span class="fc" id="L282">		return new JwsSignedPayload(payload, Collections.unmodifiableCollection(signatures));</span>
	}

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.10.202304240956</span></div></body></html>