<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>TypeTemplate.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">IU Type Introspection Implementation Module</a> &gt; <a href="index.source.html" class="el_package">iu.type</a> &gt; <span class="el_source">TypeTemplate.java</span></div><h1>TypeTemplate.java</h1><pre class="source lang-java linenums">/*
 * Copyright Â© 2023 Indiana University
 * All rights reserved.
 *
 * BSD 3-Clause License
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 
 * - Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 * 
 * - Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 * 
 * - Neither the name of the copyright holder nor the names of its
 *   contributors may be used to endorse or promote products derived from
 *   this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package iu.type;

import java.beans.Introspector;
import java.lang.reflect.AnnotatedElement;
import java.lang.reflect.Constructor;
import java.lang.reflect.ParameterizedType;
import java.lang.reflect.Type;
import java.util.ArrayDeque;
import java.util.LinkedHashMap;
import java.util.Map;
import java.util.Objects;
import java.util.Queue;
import java.util.function.Consumer;

import edu.iu.IuException;
import edu.iu.type.IuConstructor;
import edu.iu.type.IuField;
import edu.iu.type.IuMethod;
import edu.iu.type.IuProperty;
import edu.iu.type.IuReferenceKind;
import edu.iu.type.IuType;
import edu.iu.type.IuTypeReference;

/**
 * Represents the internal structure of a {@link TypeFacade}.
 * 
 * &lt;p&gt;
 * Each template is a standalone representation of a single generic type,
 * potentially paired with a raw template representing its erasure.
 * &lt;/p&gt;
 * 
 * &lt;p&gt;
 * Note that {@link TypeTemplate} is not sterotyped as a hash key, but
 * {@link IuType} is. This hash key behavior comes from same-instance identity
 * default {@link #hashCode()} and {@link #equals(Object)} implementations of
 * instances managed by {@link TypeFactory}. Since ClassLoading data is loaded
 * exactly once and remains static once loaded, type introspection instances
 * match that load-once static behavior. It is expected that each raw type
 * (primitive, class, interface, enum, record, etc) has exactly one
 * {@link TypeTemplate} instance, and that each {@link TypeTemplate} instance
 * backed by a generic type contains a {@link TypeFacade} backed by a singleton
 * raw type instances representing its {@link #erase() type erasure}. This
 * behavior mirrors the hash key behavior of {@link Type}, so internal checks
 * for equality (and inequality) may use == (and !=).
 * &lt;/p&gt;
 * 
 * &lt;p&gt;
 * Note also that Java does not constrain the number of {@link Type} instances,
 * and considers those instances other than {@link Class} to be disposable.
 * {@link TypeFactory} does not manage {@link TypeTemplate} instances for
 * generic type markers once returned to the application.
 * &lt;/p&gt;
 * 
 * &lt;h2&gt;Initialization Order&lt;/h2&gt;
 * &lt;p&gt;
 * Type templates are initialized in two phases, managed by {@link TypeFactory}.
 * &lt;/p&gt;
 * &lt;ol&gt;
 * &lt;li&gt;Declared elements&lt;/li&gt;
 * &lt;li&gt;Inherited elements&lt;/li&gt;
 * &lt;/ol&gt;
 * 
 * &lt;h3&gt;Declared Elements&lt;/h3&gt;
 * &lt;p&gt;
 * Resolved in order upon instantiation:
 * &lt;/p&gt;
 * &lt;ol&gt;
 * &lt;li&gt;{@link ElementBase#ElementBase(Consumer)} {@code preInitHook} binds raw
 * {@link Class} instances to {@link TypeFactory}{@code #RAW_TYPES}&lt;/li&gt;
 * &lt;li&gt;{@link AnnotatedElementBase#AnnotatedElementBase(AnnotatedElement, Consumer)}
 * binds {@link #annotatedElement}&lt;/li&gt;
 * &lt;li&gt;{@link DeclaredElementBase#DeclaredElementBase(AnnotatedElement, Consumer, Type, TypeTemplate)}
 * binds:
 * &lt;ul&gt;
 * &lt;li&gt;{@link #type}&lt;/li&gt;
 * &lt;li&gt;{@link #declaringType()}, potentially null or unsealed&lt;/li&gt;
 * &lt;/ul&gt;
 * &lt;/li&gt;
 * &lt;li&gt;Apply actual type arguments from {@link ParameterizedType}&lt;/li&gt;
 * &lt;li&gt;{@link #erase()}&lt;/li&gt;
 * &lt;li&gt;{@link #constructors()}&lt;/li&gt;
 * &lt;/ol&gt;
 * 
 * &lt;h3&gt;Inherited Elements&lt;/h3&gt;
 * &lt;p&gt;
 * Resolved by {@link #sealHierarchy(Iterable)}, order incidental
 * &lt;/p&gt;
 * &lt;ul&gt;
 * &lt;li&gt;{@link #fields()}&lt;/li&gt;
 * &lt;li&gt;{@link #properties()}&lt;/li&gt;
 * &lt;li&gt;{@link #methods()}&lt;/li&gt;
 * &lt;li&gt;{@link #typeParameters()}&lt;/li&gt;
 * &lt;/ul&gt;
 * 
 * @param &lt;D&gt; declaring type
 * @param &lt;T&gt; raw or generic type
 */
<span class="fc" id="L129">final class TypeTemplate&lt;D, T&gt; extends DeclaredElementBase&lt;D, Class&lt;T&gt;&gt; implements IuType&lt;D, T&gt;, ParameterizedFacade {</span>

	@SuppressWarnings(&quot;unchecked&quot;)
	private static &lt;D&gt; TypeTemplate&lt;?, D&gt; resolveDeclaringType(Class&lt;?&gt; enclosed) {
<span class="fc" id="L133">		final var declaringClass = enclosed.getDeclaringClass();</span>
<span class="fc bfc" id="L134" title="All 2 branches covered.">		if (declaringClass == null)</span>
<span class="fc" id="L135">			return null;</span>
<span class="fc" id="L136">		return (TypeTemplate&lt;?, D&gt;) TypeFactory.resolveRawClass(declaringClass);</span>
	}

	// Declared
	private IuType&lt;D, T&gt; erasedType;
	private Iterable&lt;TypeFacade&lt;T, ?&gt;&gt; enclosedTypes;
	private Iterable&lt;ConstructorFacade&lt;T&gt;&gt; constructors;

	// Inherited
	private Iterable&lt;TypeFacade&lt;?, ? super T&gt;&gt; hierarchy;
	private Iterable&lt;FieldFacade&lt;? super T, ?&gt;&gt; fields;
	private Iterable&lt;PropertyFacade&lt;? super T, ?&gt;&gt; properties;
	private Iterable&lt;MethodFacade&lt;? super T, ?&gt;&gt; methods;

	// Parameterized
<span class="fc" id="L151">	private final ParameterizedElement parameterizedElement = new ParameterizedElement();</span>

	private TypeTemplate(Class&lt;T&gt; annotatedElement, Consumer&lt;TypeTemplate&lt;?, ?&gt;&gt; preInitHook, Type type,
			TypeTemplate&lt;D, T&gt; erasedType) {
<span class="fc" id="L155">		super(annotatedElement, preInitHook, type, resolveDeclaringType(annotatedElement));</span>

<span class="fc bfc" id="L157" title="All 2 branches covered.">		if (declaringType == null)</span>
<span class="fc" id="L158">			initializeDeclared(erasedType);</span>
		else
<span class="fc" id="L160">			declaringType.template.postInit(() -&gt; initializeDeclared(erasedType));</span>
<span class="fc" id="L161">	}</span>

	/**
	 * Raw class constructor intended for use only by {@link TypeFactory}.
	 * 
	 * @param rawClass    raw class
	 * @param preInitHook receives a handle to {@code this} after binding the
	 *                    annotated element but before initializing and members
	 */
	TypeTemplate(Class&lt;T&gt; rawClass, Consumer&lt;TypeTemplate&lt;?, ?&gt;&gt; preInitHook) {
<span class="fc" id="L171">		this(rawClass, preInitHook, rawClass, null);</span>
<span class="fc" id="L172">	}</span>

	/**
	 * Generic type constructor intended for use only by {@link TypeFactory}.
	 * 
	 * @param preInitHook receives a handle to {@code this} after binding the
	 *                    annotated element but before initializing and members
	 * @param type        generic type; &lt;em&gt;must not&lt;/em&gt; be a class
	 * @param erasedType  pre-calculated raw type template; a {@link TypeTemplate}
	 *                    cannot be created for a generic type without a
	 *                    fully-formed instance of its type erasure, provided as an
	 *                    argument to this parameter
	 */
	TypeTemplate(Consumer&lt;TypeTemplate&lt;?, ?&gt;&gt; preInitHook, Type type, TypeTemplate&lt;D, T&gt; erasedType) {
<span class="fc" id="L186">		this(erasedType.erasedClass(), preInitHook, type, erasedType);</span>
<span class="fc bfc" id="L187" title="All 2 branches covered.">		assert !(type instanceof Class) : type;</span>
<span class="fc bfc" id="L188" title="All 2 branches covered.">		assert erasedType.erasedClass() == TypeFactory.getErasedClass(type)</span>
<span class="fc" id="L189">				: erasedType + &quot; &quot; + TypeUtils.printType(type);</span>

<span class="fc" id="L191">		sealHierarchy(erasedType.hierarchy);</span>
<span class="fc" id="L192">	}</span>

	private boolean isNative() {
<span class="fc bfc" id="L195" title="All 2 branches covered.">		return TypeUtils.isPlatformType(name()) //</span>
<span class="fc bfc" id="L196" title="All 2 branches covered.">				|| (&quot;iu.type&quot;.equals(annotatedElement.getPackageName()) //</span>
<span class="fc bfc" id="L197" title="All 2 branches covered.">						&amp;&amp; annotatedElement.getEnclosingClass() == null);</span>
	}

	private void initializeDeclared(TypeTemplate&lt;D, T&gt; erasedType) {
<span class="fc bfc" id="L201" title="All 2 branches covered.">		if (declaringType != null)</span>
<span class="fc" id="L202">			parameterizedElement.apply(declaringType.template.typeParameters());</span>

<span class="fc bfc" id="L204" title="All 2 branches covered.">		if (erasedType == null) {</span>
<span class="fc" id="L205">			this.erasedType = this;</span>
<span class="fc" id="L206">			initializeEnclosedTypes();</span>
<span class="fc" id="L207">			initializeConstructors();</span>
		} else {
<span class="fc" id="L209">			this.erasedType = new TypeFacade&lt;D, T&gt;(erasedType, this, IuReferenceKind.ERASURE);</span>
<span class="fc" id="L210">			erasedType.postInit(() -&gt; {</span>
<span class="fc" id="L211">				initializeEnclosedTypes();</span>
<span class="fc" id="L212">				initializeConstructors();</span>
<span class="fc" id="L213">			});</span>
		}
<span class="fc" id="L215">	}</span>

	@SuppressWarnings({ &quot;rawtypes&quot;, &quot;unchecked&quot; })
	private void initializeEnclosedTypes() {
<span class="fc" id="L219">		Queue&lt;TypeFacade&lt;T, ?&gt;&gt; enclosedTypes = new ArrayDeque&lt;&gt;();</span>

<span class="fc bfc" id="L221" title="All 2 branches covered.">		if (!isNative())</span>
<span class="fc bfc" id="L222" title="All 2 branches covered.">			for (var enclosedClass : annotatedElement.getDeclaredClasses())</span>
<span class="fc" id="L223">				enclosedTypes.offer(new TypeFacade(TypeFactory.resolveRawClass(enclosedClass), this,</span>
						IuReferenceKind.ENCLOSING_TYPE));

<span class="fc" id="L226">		this.enclosedTypes = enclosedTypes;</span>
<span class="fc" id="L227">	}</span>

	@SuppressWarnings(&quot;unchecked&quot;)
	private void initializeConstructors() {
<span class="fc" id="L231">		Queue&lt;ConstructorFacade&lt;T&gt;&gt; constructors = new ArrayDeque&lt;&gt;();</span>

<span class="fc bfc" id="L233" title="All 2 branches covered.">		if (!isNative() //</span>
<span class="fc bfc" id="L234" title="All 2 branches covered.">				&amp;&amp; !annotatedElement.isInterface() //</span>
<span class="fc bfc" id="L235" title="All 2 branches covered.">				&amp;&amp; !annotatedElement.isEnum() //</span>
<span class="fc bfc" id="L236" title="All 2 branches covered.">				&amp;&amp; !annotatedElement.isPrimitive())</span>
<span class="fc bfc" id="L237" title="All 2 branches covered.">			for (var constructor : annotatedElement.getDeclaredConstructors())</span>
				// _unchecked warning_: see source for #getDeclaredConstructors()
				// =&gt; This cast is safe as of Java 17
<span class="fc" id="L240">				constructors.offer(new ConstructorFacade&lt;&gt;((Constructor&lt;T&gt;) constructor, this));</span>

<span class="fc" id="L242">		this.constructors = constructors;</span>
<span class="fc" id="L243">	}</span>

	@SuppressWarnings({ &quot;unchecked&quot;, &quot;rawtypes&quot; })
	private Iterable&lt;FieldFacade&lt;? super T, ?&gt;&gt; initializeFields() {
<span class="fc" id="L247">		Queue&lt;FieldFacade&lt;? super T, ?&gt;&gt; rv = new ArrayDeque&lt;&gt;();</span>

<span class="fc bfc" id="L249" title="All 2 branches covered.">		if (!isNative()) //</span>
<span class="fc bfc" id="L250" title="All 2 branches covered.">			for (var field : annotatedElement.getDeclaredFields()) {</span>
				TypeTemplate&lt;?, ?&gt; fieldType;
<span class="fc bfc" id="L252" title="All 2 branches covered.">				if (field.getType() == annotatedElement)</span>
<span class="fc" id="L253">					fieldType = this;</span>
				else
<span class="fc" id="L255">					fieldType = TypeFactory.resolveType(field.getGenericType());</span>

<span class="fc" id="L257">				rv.offer(new FieldFacade(field, fieldType, this));</span>
			}

<span class="fc bfc" id="L260" title="All 2 branches covered.">		for (var superType : hierarchy)</span>
<span class="fc" id="L261">			superType.template.postInit(() -&gt; {</span>
<span class="fc bfc" id="L262" title="All 2 branches covered.">				for (var inheritedField : superType.template.fields)</span>
<span class="fc" id="L263">					rv.offer(inheritedField);</span>
<span class="fc" id="L264">			});</span>

<span class="fc" id="L266">		return rv;</span>
	}

	@SuppressWarnings({ &quot;unchecked&quot;, &quot;rawtypes&quot; })
	private Iterable&lt;PropertyFacade&lt;? super T, ?&gt;&gt; initializeProperties() {
<span class="fc" id="L271">		Queue&lt;PropertyFacade&lt;? super T, ?&gt;&gt; rv = new ArrayDeque&lt;&gt;();</span>

<span class="fc bfc" id="L273" title="All 2 branches covered.">		if (!isNative()) //</span>
<span class="fc bfc" id="L274" title="All 2 branches covered.">			for (var property : IuException.unchecked(() -&gt; Introspector.getBeanInfo(annotatedElement))</span>
<span class="fc" id="L275">					.getPropertyDescriptors()) {</span>
<span class="fc bfc" id="L276" title="All 2 branches covered.">				if (property.getName().equals(&quot;class&quot;))</span>
<span class="fc" id="L277">					continue;</span>

<span class="fc" id="L279">				var readMethod = property.getReadMethod();</span>
<span class="fc" id="L280">				var writeMethod = property.getWriteMethod();</span>

				Type propertyType;
<span class="fc bfc" id="L283" title="All 2 branches covered.">				if (readMethod != null)</span>
<span class="fc" id="L284">					propertyType = readMethod.getGenericReturnType();</span>
				else
<span class="fc" id="L286">					propertyType = writeMethod.getGenericParameterTypes()[0];</span>

				TypeTemplate&lt;?, T&gt; propertyTypeTemplate;
<span class="fc bfc" id="L289" title="All 2 branches covered.">				if (propertyType == annotatedElement)</span>
<span class="fc" id="L290">					propertyTypeTemplate = this;</span>
				else
<span class="fc" id="L292">					propertyTypeTemplate = (TypeTemplate&lt;?, T&gt;) TypeFactory.resolveType(propertyType);</span>

<span class="fc" id="L294">				rv.offer(new PropertyFacade(property, propertyTypeTemplate, this));</span>
			}

<span class="fc bfc" id="L297" title="All 2 branches covered.">		for (var superType : hierarchy)</span>
<span class="fc" id="L298">			superType.template.postInit(() -&gt; {</span>
<span class="fc bfc" id="L299" title="All 2 branches covered.">				for (var inheritedProperty : superType.template.properties)</span>
<span class="fc" id="L300">					rv.offer(inheritedProperty);</span>
<span class="fc" id="L301">			});</span>

<span class="fc" id="L303">		return rv;</span>
	}

	private Iterable&lt;MethodFacade&lt;? super T, ?&gt;&gt; initializeMethods() {
<span class="fc" id="L307">		Queue&lt;MethodFacade&lt;? super T, ?&gt;&gt; rv = new ArrayDeque&lt;&gt;();</span>

<span class="fc bfc" id="L309" title="All 2 branches covered.">		if (!isNative()) //</span>
<span class="fc bfc" id="L310" title="All 2 branches covered.">			for (var method : annotatedElement.getDeclaredMethods()) {</span>
<span class="fc bfc" id="L311" title="All 2 branches covered.">				if (method.isSynthetic())</span>
<span class="fc" id="L312">					continue; // skip lambdas</span>

				TypeTemplate&lt;?, ?&gt; returnType;
<span class="fc bfc" id="L315" title="All 2 branches covered.">				if (method.getReturnType() == annotatedElement)</span>
<span class="fc" id="L316">					returnType = this;</span>
				else
<span class="fc" id="L318">					returnType = TypeFactory.resolveType(method.getGenericReturnType());</span>

<span class="fc" id="L320">				rv.offer(new MethodFacade&lt;&gt;(method, returnType, this));</span>
			}

<span class="fc bfc" id="L323" title="All 2 branches covered.">		for (var superType : hierarchy)</span>
<span class="fc" id="L324">			superType.template.postInit(() -&gt; {</span>
<span class="fc bfc" id="L325" title="All 2 branches covered.">				for (var inheritedMethod : superType.template.methods)</span>
<span class="fc" id="L326">					rv.offer(inheritedMethod);</span>
<span class="fc" id="L327">			});</span>

<span class="fc" id="L329">		return rv;</span>
	}

	private void doSealHierarchy(Iterable&lt;? extends IuType&lt;?, ? super T&gt;&gt; hierarchy) {
<span class="fc" id="L333">		Map&lt;Class&lt;?&gt;, TypeFacade&lt;?, ? super T&gt;&gt; hierarchyByErasure = new LinkedHashMap&lt;&gt;();</span>
<span class="fc bfc" id="L334" title="All 2 branches covered.">		for (var superType : hierarchy) {</span>
<span class="fc" id="L335">			var templateReference = superType.reference();</span>

			TypeTemplate&lt;?, ? super T&gt; superTypeTemplate;
<span class="fc bfc" id="L338" title="All 2 branches covered.">			if (templateReference == null) {</span>
<span class="fc" id="L339">				superTypeTemplate = (TypeTemplate&lt;?, ? super T&gt;) superType;</span>

				// common case: direct generalization of raw class
<span class="fc" id="L342">				hierarchyByErasure.put(superType.erasedClass(),</span>
						new TypeFacade&lt;&gt;(superTypeTemplate, this, IuReferenceKind.SUPER));
<span class="fc" id="L344">				continue;</span>
			}

			else // exception case: inherited generalization ...
<span class="fc" id="L348">				superTypeTemplate = ((TypeFacade&lt;?, ? super T&gt;) superType).template;</span>

			// ... by type erasure, same as direct
<span class="fc" id="L351">			var erasedReferrerClass = ((IuType&lt;?, ?&gt;) templateReference.referrer()).erasedClass();</span>
<span class="fc bfc" id="L352" title="All 2 branches covered.">			if (erasedReferrerClass == annotatedElement) {</span>
<span class="fc" id="L353">				hierarchyByErasure.put(superType.erasedClass(),</span>
						new TypeFacade&lt;&gt;(superTypeTemplate, this, IuReferenceKind.SUPER));
<span class="fc" id="L355">				continue;</span>
			}

			// ... via superclass or interface, look up unsealed reference by erasure
<span class="fc" id="L359">			final var referrer = Objects.requireNonNull(hierarchyByErasure.get(erasedReferrerClass));</span>
<span class="fc" id="L360">			final var superTypeFacade = new TypeFacade&lt;&gt;(superTypeTemplate, referrer, IuReferenceKind.SUPER);</span>
<span class="fc" id="L361">			hierarchyByErasure.put(superTypeFacade.erasedClass(), superTypeFacade);</span>
<span class="fc" id="L362">		}</span>

<span class="fc" id="L364">		this.hierarchy = hierarchyByErasure.values();</span>

<span class="fc bfc" id="L366" title="All 2 branches covered.">		if (type instanceof ParameterizedType parameterizedType) {</span>
<span class="fc" id="L367">			final var actualTypeArguments = parameterizedType.getActualTypeArguments();</span>
<span class="fc" id="L368">			final var typeVariables = annotatedElement.getTypeParameters();</span>
<span class="fc" id="L369">			final var length = actualTypeArguments.length;</span>
<span class="fc bfc" id="L370" title="All 2 branches covered.">			assert typeVariables.length == length; // enforced by javac</span>
<span class="fc bfc" id="L371" title="All 2 branches covered.">			for (var i = 0; i &lt; length; i++)</span>
<span class="fc" id="L372">				parameterizedElement.apply(this, typeVariables[i], actualTypeArguments[i]);</span>
		}

<span class="fc" id="L375">		fields = initializeFields();</span>
<span class="fc" id="L376">		properties = initializeProperties();</span>
<span class="fc" id="L377">		methods = initializeMethods();</span>

<span class="fc" id="L379">		parameterizedElement.seal(annotatedElement, this);</span>
<span class="fc" id="L380">		super.seal();</span>
<span class="fc" id="L381">	}</span>

	/**
	 * Unsupported, use {@link #sealHierarchy(Iterable)} to provide hierarchy when
	 * sealing.
	 * 
	 * @throws UnsupportedOperationException when invoked
	 */
	@Override
	final void seal() throws UnsupportedOperationException {
<span class="fc" id="L391">		throw new UnsupportedOperationException(&quot;use sealHierarchy() only with TypeTemplate&quot;);</span>
	}

	/**
	 * Seals {@link #hierarchy()} and resolves &lt;strong&gt;inherited elements&lt;/strong&gt;.
	 * 
	 * @param hierarchy Resolved type hierarchy
	 */
	void sealHierarchy(Iterable&lt;? extends IuType&lt;?, ? super T&gt;&gt; hierarchy) {
<span class="fc bfc" id="L400" title="All 2 branches covered.">		if (declaringType == null)</span>
<span class="fc" id="L401">			doSealHierarchy(hierarchy);</span>
		else
<span class="fc" id="L403">			declaringType.template.postInit(() -&gt; doSealHierarchy(hierarchy));</span>
<span class="fc" id="L404">	}</span>

	@Override
	public Map&lt;String, TypeFacade&lt;?, ?&gt;&gt; typeParameters() {
<span class="fc" id="L408">		checkSealed();</span>
<span class="fc" id="L409">		return parameterizedElement.typeParameters();</span>
	}

	@Override
	public String name() {
<span class="fc" id="L414">		return annotatedElement.getName();</span>
	}

	@Override
	public IuTypeReference&lt;T, ?&gt; reference() {
<span class="fc" id="L419">		return null;</span>
	}

	@Override
	public Type deref() {
<span class="fc" id="L424">		return type;</span>
	}

	@Override
	public IuType&lt;D, T&gt; erase() {
<span class="fc" id="L429">		return erasedType;</span>
	}

	@Override
	public Class&lt;T&gt; erasedClass() {
<span class="fc" id="L434">		return annotatedElement;</span>
	}

	@Override
	public IuType&lt;?, ? super T&gt; referTo(Type referentType) {
<span class="fc" id="L439">		return TypeUtils.referTo(this, hierarchy(), referentType);</span>
	}

	@Override
	public Iterable&lt;TypeFacade&lt;T, ?&gt;&gt; enclosedTypes() {
<span class="fc" id="L444">		checkSealed();</span>
<span class="fc" id="L445">		return enclosedTypes;</span>
	}

	@Override
	public Iterable&lt;? extends IuConstructor&lt;T&gt;&gt; constructors() {
<span class="fc" id="L450">		return constructors;</span>
	}

	@Override
	public Iterable&lt;TypeFacade&lt;?, ? super T&gt;&gt; hierarchy() {
<span class="fc bfc" id="L455" title="All 2 branches covered.">		if (hierarchy == null)</span>
<span class="fc" id="L456">			throw new IllegalStateException(&quot;hierarchy not sealed&quot;);</span>
<span class="fc" id="L457">		return hierarchy;</span>
	}

	@Override
	public Iterable&lt;? extends IuField&lt;? super T, ?&gt;&gt; fields() {
<span class="fc bfc" id="L462" title="All 2 branches covered.">		if (fields == null)</span>
<span class="fc" id="L463">			throw new IllegalStateException(&quot;fields not sealed&quot;);</span>
<span class="fc" id="L464">		return fields;</span>
	}

	@Override
	public Iterable&lt;? extends IuProperty&lt;? super T, ?&gt;&gt; properties() {
<span class="fc bfc" id="L469" title="All 2 branches covered.">		if (properties == null)</span>
<span class="fc" id="L470">			throw new IllegalStateException(&quot;properties not sealed&quot;);</span>
<span class="fc" id="L471">		return properties;</span>
	}

	@Override
	public Iterable&lt;? extends IuMethod&lt;? super T, ?&gt;&gt; methods() {
<span class="fc bfc" id="L476" title="All 2 branches covered.">		if (methods == null)</span>
<span class="fc" id="L477">			throw new IllegalStateException(&quot;methods not sealed&quot;);</span>
<span class="fc" id="L478">		return methods;</span>
	}

	@Override
	public String toString() {
<span class="fc" id="L483">		return &quot;IuType[&quot; + TypeUtils.printType(deref()) + ']';</span>
	}

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.10.202304240956</span></div></body></html>