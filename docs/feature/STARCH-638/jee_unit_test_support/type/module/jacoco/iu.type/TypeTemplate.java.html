<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>TypeTemplate.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">IU Type Introspection Implementation Module</a> &gt; <a href="index.source.html" class="el_package">iu.type</a> &gt; <span class="el_source">TypeTemplate.java</span></div><h1>TypeTemplate.java</h1><pre class="source lang-java linenums">/*
 * Copyright Â© 2023 Indiana University
 * All rights reserved.
 *
 * BSD 3-Clause License
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 
 * - Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 * 
 * - Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 * 
 * - Neither the name of the copyright holder nor the names of its
 *   contributors may be used to endorse or promote products derived from
 *   this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package iu.type;

import java.beans.Introspector;
import java.lang.reflect.AnnotatedElement;
import java.lang.reflect.Constructor;
import java.lang.reflect.ParameterizedType;
import java.lang.reflect.Type;
import java.util.ArrayDeque;
import java.util.LinkedHashMap;
import java.util.Map;
import java.util.Objects;
import java.util.Queue;
import java.util.function.Consumer;

import edu.iu.IuException;
import edu.iu.IuVisitor;
import edu.iu.type.IuConstructor;
import edu.iu.type.IuReferenceKind;
import edu.iu.type.IuType;
import edu.iu.type.IuTypeReference;

/**
 * Represents the internal structure of a {@link TypeFacade}.
 * 
 * &lt;p&gt;
 * Each template is a standalone representation of a single generic type,
 * potentially paired with a raw template representing its erasure.
 * &lt;/p&gt;
 * 
 * &lt;p&gt;
 * Note that {@link TypeTemplate} is not sterotyped as a hash key, but
 * {@link IuType} is. This hash key behavior comes from same-instance identity
 * default {@link #hashCode()} and {@link #equals(Object)} implementations of
 * instances managed by {@link TypeFactory}. Since ClassLoading data is loaded
 * exactly once and remains static once loaded, type introspection instances
 * match that load-once static behavior. It is expected that each raw type
 * (primitive, class, interface, enum, record, etc) has exactly one
 * {@link TypeTemplate} instance, and that each {@link TypeTemplate} instance
 * backed by a generic type contains a {@link TypeFacade} backed by a singleton
 * raw type instances representing its {@link #erase() type erasure}. This
 * behavior mirrors the hash key behavior of {@link Type}, so internal checks
 * for equality (and inequality) may use == (and !=).
 * &lt;/p&gt;
 * 
 * &lt;p&gt;
 * Note also that Java does not constrain the number of {@link Type} instances,
 * and considers those instances other than {@link Class} to be disposable.
 * {@link TypeFactory} does not manage {@link TypeTemplate} instances for
 * generic type markers once returned to the application.
 * &lt;/p&gt;
 * 
 * &lt;h2&gt;Initialization Order&lt;/h2&gt;
 * &lt;p&gt;
 * Type templates are initialized in two phases, managed by {@link TypeFactory}.
 * &lt;/p&gt;
 * &lt;ol&gt;
 * &lt;li&gt;Declared elements&lt;/li&gt;
 * &lt;li&gt;Inherited elements&lt;/li&gt;
 * &lt;/ol&gt;
 * 
 * &lt;h3&gt;Declared Elements&lt;/h3&gt;
 * &lt;p&gt;
 * Resolved in order upon instantiation:
 * &lt;/p&gt;
 * &lt;ol&gt;
 * &lt;li&gt;{@link ElementBase#ElementBase(Consumer)} {@code preInitHook} binds raw
 * {@link Class} instances to {@link TypeFactory}{@code #RAW_TYPES}&lt;/li&gt;
 * &lt;li&gt;{@link AnnotatedElementBase#AnnotatedElementBase(AnnotatedElement, Consumer)}
 * binds {@link #annotatedElement}&lt;/li&gt;
 * &lt;li&gt;{@link DeclaredElementBase#DeclaredElementBase(AnnotatedElement, Consumer, Type, TypeTemplate)}
 * binds:
 * &lt;ul&gt;
 * &lt;li&gt;{@link #type}&lt;/li&gt;
 * &lt;li&gt;{@link #declaringType()}, potentially null or unsealed&lt;/li&gt;
 * &lt;/ul&gt;
 * &lt;/li&gt;
 * &lt;li&gt;Apply actual type arguments from {@link ParameterizedType}&lt;/li&gt;
 * &lt;li&gt;{@link #erase()}&lt;/li&gt;
 * &lt;li&gt;{@link #constructors()}&lt;/li&gt;
 * &lt;/ol&gt;
 * 
 * &lt;h3&gt;Inherited Elements&lt;/h3&gt;
 * &lt;p&gt;
 * Resolved by {@link #sealHierarchy(Iterable)}, order incidental
 * &lt;/p&gt;
 * &lt;ul&gt;
 * &lt;li&gt;{@link #fields()}&lt;/li&gt;
 * &lt;li&gt;{@link #properties()}&lt;/li&gt;
 * &lt;li&gt;{@link #methods()}&lt;/li&gt;
 * &lt;li&gt;{@link #typeParameters()}&lt;/li&gt;
 * &lt;/ul&gt;
 * 
 * @param &lt;D&gt; declaring type
 * @param &lt;T&gt; raw or generic type
 */
<span class="fc" id="L127">final class TypeTemplate&lt;D, T&gt; extends DeclaredElementBase&lt;D, Class&lt;T&gt;&gt; implements IuType&lt;D, T&gt;, ParameterizedFacade {</span>

	@SuppressWarnings(&quot;unchecked&quot;)
	private static &lt;D&gt; TypeTemplate&lt;?, D&gt; resolveDeclaringType(Class&lt;?&gt; enclosed) {
<span class="fc" id="L131">		final var declaringClass = enclosed.getDeclaringClass();</span>
<span class="fc bfc" id="L132" title="All 2 branches covered.">		if (declaringClass == null)</span>
<span class="fc" id="L133">			return null;</span>
<span class="fc" id="L134">		return (TypeTemplate&lt;?, D&gt;) TypeFactory.resolveRawClass(declaringClass);</span>
	}

	// Declared
	private IuType&lt;D, T&gt; erasedType;
	private Iterable&lt;TypeFacade&lt;T, ?&gt;&gt; enclosedTypes;
	private Iterable&lt;ConstructorFacade&lt;T&gt;&gt; constructors;

	// Inherited
	private Iterable&lt;TypeFacade&lt;?, ? super T&gt;&gt; hierarchy;
	private Iterable&lt;FieldFacade&lt;? super T, ?&gt;&gt; fields;
	private Iterable&lt;PropertyFacade&lt;? super T, ?&gt;&gt; properties;
	private Iterable&lt;MethodFacade&lt;? super T, ?&gt;&gt; methods;

	// Parameterized
<span class="fc" id="L149">	private final ParameterizedElement parameterizedElement = new ParameterizedElement();</span>

	// Instance management
<span class="fc" id="L152">	private final IuVisitor&lt;Consumer&lt;T&gt;&gt; instanceListeners = new IuVisitor&lt;&gt;();</span>

	private TypeTemplate(Class&lt;T&gt; annotatedElement, Consumer&lt;TypeTemplate&lt;?, ?&gt;&gt; preInitHook, Type type,
			TypeTemplate&lt;D, T&gt; erasedType) {
<span class="fc" id="L156">		super(annotatedElement, preInitHook, type, resolveDeclaringType(annotatedElement));</span>

<span class="fc bfc" id="L158" title="All 2 branches covered.">		if (declaringType == null)</span>
<span class="fc" id="L159">			initializeDeclared(erasedType);</span>
		else
<span class="fc" id="L161">			declaringType.template.postInit(() -&gt; initializeDeclared(erasedType));</span>
<span class="fc" id="L162">	}</span>

	/**
	 * Raw class constructor intended for use only by {@link TypeFactory}.
	 * 
	 * @param rawClass    raw class
	 * @param preInitHook receives a handle to {@code this} after binding the
	 *                    annotated element but before initializing and members
	 */
	TypeTemplate(Class&lt;T&gt; rawClass, Consumer&lt;TypeTemplate&lt;?, ?&gt;&gt; preInitHook) {
<span class="fc" id="L172">		this(rawClass, preInitHook, rawClass, null);</span>
<span class="fc" id="L173">	}</span>

	/**
	 * Generic type constructor intended for use only by {@link TypeFactory}.
	 * 
	 * @param preInitHook receives a handle to {@code this} after binding the
	 *                    annotated element but before initializing and members
	 * @param type        generic type; &lt;em&gt;must not&lt;/em&gt; be a class
	 * @param erasedType  pre-calculated raw type template; a {@link TypeTemplate}
	 *                    cannot be created for a generic type without a
	 *                    fully-formed instance of its type erasure, provided as an
	 *                    argument to this parameter
	 */
	TypeTemplate(Consumer&lt;TypeTemplate&lt;?, ?&gt;&gt; preInitHook, Type type, TypeTemplate&lt;D, T&gt; erasedType) {
<span class="fc" id="L187">		this(erasedType.erasedClass(), preInitHook, type, erasedType);</span>
<span class="fc bfc" id="L188" title="All 2 branches covered.">		assert !(type instanceof Class) : type;</span>
<span class="fc bfc" id="L189" title="All 2 branches covered.">		assert erasedType.erasedClass() == TypeFactory.getErasedClass(type)</span>
<span class="fc" id="L190">				: erasedType + &quot; &quot; + TypeUtils.printType(type);</span>

<span class="fc" id="L192">		sealHierarchy(erasedType.hierarchy);</span>
<span class="fc" id="L193">	}</span>

	private boolean isNative() {
<span class="fc bfc" id="L196" title="All 2 branches covered.">		return TypeUtils.isPlatformType(name()) //</span>
<span class="fc bfc" id="L197" title="All 2 branches covered.">				|| (&quot;iu.type&quot;.equals(annotatedElement.getPackageName()) //</span>
<span class="fc bfc" id="L198" title="All 2 branches covered.">						&amp;&amp; annotatedElement.getEnclosingClass() == null);</span>
	}

	private void initializeDeclared(TypeTemplate&lt;D, T&gt; erasedType) {
<span class="fc bfc" id="L202" title="All 2 branches covered.">		if (declaringType != null)</span>
<span class="fc" id="L203">			parameterizedElement.apply(declaringType.template.typeParameters());</span>

<span class="fc bfc" id="L205" title="All 2 branches covered.">		if (erasedType == null) {</span>
<span class="fc" id="L206">			this.erasedType = this;</span>
<span class="fc" id="L207">			initializeEnclosedTypes();</span>
<span class="fc" id="L208">			initializeConstructors();</span>
		} else {
<span class="fc" id="L210">			this.erasedType = new TypeFacade&lt;D, T&gt;(erasedType, this, IuReferenceKind.ERASURE);</span>
<span class="fc" id="L211">			erasedType.postInit(() -&gt; {</span>
<span class="fc" id="L212">				initializeEnclosedTypes();</span>
<span class="fc" id="L213">				initializeConstructors();</span>
<span class="fc" id="L214">			});</span>
		}
<span class="fc" id="L216">	}</span>

	@SuppressWarnings({ &quot;rawtypes&quot;, &quot;unchecked&quot; })
	private void initializeEnclosedTypes() {
<span class="fc" id="L220">		Queue&lt;TypeFacade&lt;T, ?&gt;&gt; enclosedTypes = new ArrayDeque&lt;&gt;();</span>

<span class="fc bfc" id="L222" title="All 2 branches covered.">		if (!isNative())</span>
<span class="fc bfc" id="L223" title="All 2 branches covered.">			for (var enclosedClass : annotatedElement.getDeclaredClasses())</span>
<span class="fc" id="L224">				enclosedTypes.offer(new TypeFacade(TypeFactory.resolveRawClass(enclosedClass), this,</span>
						IuReferenceKind.ENCLOSING_TYPE));

<span class="fc" id="L227">		this.enclosedTypes = enclosedTypes;</span>
<span class="fc" id="L228">	}</span>

	@SuppressWarnings(&quot;unchecked&quot;)
	private void initializeConstructors() {
<span class="fc" id="L232">		Queue&lt;ConstructorFacade&lt;T&gt;&gt; constructors = new ArrayDeque&lt;&gt;();</span>

<span class="fc bfc" id="L234" title="All 2 branches covered.">		if (!isNative() //</span>
<span class="fc bfc" id="L235" title="All 2 branches covered.">				&amp;&amp; !annotatedElement.isInterface() //</span>
<span class="fc bfc" id="L236" title="All 2 branches covered.">				&amp;&amp; !annotatedElement.isEnum() //</span>
<span class="fc bfc" id="L237" title="All 2 branches covered.">				&amp;&amp; !annotatedElement.isPrimitive())</span>
<span class="fc bfc" id="L238" title="All 2 branches covered.">			for (var constructor : annotatedElement.getDeclaredConstructors())</span>
				// _unchecked warning_: see source for #getDeclaredConstructors()
				// =&gt; This cast is safe as of Java 17
<span class="fc" id="L241">				constructors.offer(new ConstructorFacade&lt;&gt;((Constructor&lt;T&gt;) constructor, this));</span>

<span class="fc" id="L243">		this.constructors = constructors;</span>
<span class="fc" id="L244">	}</span>

	@SuppressWarnings({ &quot;unchecked&quot;, &quot;rawtypes&quot; })
	private Iterable&lt;FieldFacade&lt;? super T, ?&gt;&gt; initializeFields() {
<span class="fc" id="L248">		Queue&lt;FieldFacade&lt;? super T, ?&gt;&gt; rv = new ArrayDeque&lt;&gt;();</span>

<span class="fc bfc" id="L250" title="All 2 branches covered.">		if (!isNative()) //</span>
<span class="fc bfc" id="L251" title="All 2 branches covered.">			for (var field : annotatedElement.getDeclaredFields()) {</span>
				TypeTemplate&lt;?, ?&gt; fieldType;
<span class="fc bfc" id="L253" title="All 2 branches covered.">				if (field.getType() == annotatedElement)</span>
<span class="fc" id="L254">					fieldType = this;</span>
				else
<span class="fc" id="L256">					fieldType = TypeFactory.resolveType(field.getGenericType());</span>

<span class="fc" id="L258">				rv.offer(new FieldFacade(field, fieldType, this));</span>
			}

<span class="fc bfc" id="L261" title="All 2 branches covered.">		for (var superType : hierarchy)</span>
<span class="fc" id="L262">			superType.template.postInit(() -&gt; {</span>
<span class="fc bfc" id="L263" title="All 2 branches covered.">				for (var inheritedField : superType.template.fields)</span>
<span class="fc" id="L264">					rv.offer(inheritedField);</span>
<span class="fc" id="L265">			});</span>

<span class="fc" id="L267">		return rv;</span>
	}

	@SuppressWarnings({ &quot;unchecked&quot;, &quot;rawtypes&quot; })
	private Iterable&lt;PropertyFacade&lt;? super T, ?&gt;&gt; initializeProperties() {
<span class="fc" id="L272">		Queue&lt;PropertyFacade&lt;? super T, ?&gt;&gt; rv = new ArrayDeque&lt;&gt;();</span>

<span class="fc bfc" id="L274" title="All 2 branches covered.">		if (!isNative()) //</span>
<span class="fc bfc" id="L275" title="All 2 branches covered.">			for (var property : IuException.unchecked(() -&gt; Introspector.getBeanInfo(annotatedElement))</span>
<span class="fc" id="L276">					.getPropertyDescriptors()) {</span>
<span class="fc bfc" id="L277" title="All 2 branches covered.">				if (property.getName().equals(&quot;class&quot;))</span>
<span class="fc" id="L278">					continue;</span>

<span class="fc" id="L280">				var readMethod = property.getReadMethod();</span>
<span class="fc" id="L281">				var writeMethod = property.getWriteMethod();</span>

				Type propertyType;
<span class="fc bfc" id="L284" title="All 2 branches covered.">				if (readMethod != null)</span>
<span class="fc" id="L285">					propertyType = readMethod.getGenericReturnType();</span>
				else
<span class="fc" id="L287">					propertyType = writeMethod.getGenericParameterTypes()[0];</span>

				TypeTemplate&lt;?, T&gt; propertyTypeTemplate;
<span class="fc bfc" id="L290" title="All 2 branches covered.">				if (propertyType == annotatedElement)</span>
<span class="fc" id="L291">					propertyTypeTemplate = this;</span>
				else
<span class="fc" id="L293">					propertyTypeTemplate = (TypeTemplate&lt;?, T&gt;) TypeFactory.resolveType(propertyType);</span>

<span class="fc" id="L295">				rv.offer(new PropertyFacade(property, propertyTypeTemplate, this));</span>
			}

<span class="fc bfc" id="L298" title="All 2 branches covered.">		for (var superType : hierarchy)</span>
<span class="fc" id="L299">			superType.template.postInit(() -&gt; {</span>
<span class="fc bfc" id="L300" title="All 2 branches covered.">				for (var inheritedProperty : superType.template.properties)</span>
<span class="fc" id="L301">					rv.offer(inheritedProperty);</span>
<span class="fc" id="L302">			});</span>

<span class="fc" id="L304">		return rv;</span>
	}

	private Iterable&lt;MethodFacade&lt;? super T, ?&gt;&gt; initializeMethods() {
<span class="fc" id="L308">		Queue&lt;MethodFacade&lt;? super T, ?&gt;&gt; rv = new ArrayDeque&lt;&gt;();</span>

<span class="fc bfc" id="L310" title="All 2 branches covered.">		if (!isNative()) //</span>
<span class="fc bfc" id="L311" title="All 2 branches covered.">			for (var method : annotatedElement.getDeclaredMethods()) {</span>
<span class="fc bfc" id="L312" title="All 2 branches covered.">				if (method.isSynthetic())</span>
<span class="fc" id="L313">					continue; // skip lambdas</span>

				TypeTemplate&lt;?, ?&gt; returnType;
<span class="fc bfc" id="L316" title="All 2 branches covered.">				if (method.getReturnType() == annotatedElement)</span>
<span class="fc" id="L317">					returnType = this;</span>
				else
<span class="fc" id="L319">					returnType = TypeFactory.resolveType(method.getGenericReturnType());</span>

<span class="fc" id="L321">				rv.offer(new MethodFacade&lt;&gt;(method, returnType, this));</span>
			}

<span class="fc bfc" id="L324" title="All 2 branches covered.">		for (var superType : hierarchy)</span>
<span class="fc" id="L325">			superType.template.postInit(() -&gt; {</span>
<span class="fc bfc" id="L326" title="All 2 branches covered.">				for (var inheritedMethod : superType.template.methods)</span>
<span class="fc" id="L327">					rv.offer(inheritedMethod);</span>
<span class="fc" id="L328">			});</span>

<span class="fc" id="L330">		return rv;</span>
	}

	private void doSealHierarchy(Iterable&lt;? extends IuType&lt;?, ? super T&gt;&gt; hierarchy) {
<span class="fc" id="L334">		Map&lt;Class&lt;?&gt;, TypeFacade&lt;?, ? super T&gt;&gt; hierarchyByErasure = new LinkedHashMap&lt;&gt;();</span>
<span class="fc bfc" id="L335" title="All 2 branches covered.">		for (var superType : hierarchy) {</span>
<span class="fc" id="L336">			var templateReference = superType.reference();</span>

			TypeTemplate&lt;?, ? super T&gt; superTypeTemplate;
<span class="fc bfc" id="L339" title="All 2 branches covered.">			if (templateReference == null) {</span>
<span class="fc" id="L340">				superTypeTemplate = (TypeTemplate&lt;?, ? super T&gt;) superType;</span>

				// common case: direct generalization of raw class
<span class="fc" id="L343">				hierarchyByErasure.put(superType.erasedClass(),</span>
						new TypeFacade&lt;&gt;(superTypeTemplate, this, IuReferenceKind.SUPER));
<span class="fc" id="L345">				continue;</span>
			}

			else // exception case: inherited generalization ...
<span class="fc" id="L349">				superTypeTemplate = ((TypeFacade&lt;?, ? super T&gt;) superType).template;</span>

			// ... by type erasure, same as direct
<span class="fc" id="L352">			var erasedReferrerClass = ((IuType&lt;?, ?&gt;) templateReference.referrer()).erasedClass();</span>
<span class="fc bfc" id="L353" title="All 2 branches covered.">			if (erasedReferrerClass == annotatedElement) {</span>
<span class="fc" id="L354">				hierarchyByErasure.put(superType.erasedClass(),</span>
						new TypeFacade&lt;&gt;(superTypeTemplate, this, IuReferenceKind.SUPER));
<span class="fc" id="L356">				continue;</span>
			}

			// ... via superclass or interface, look up unsealed reference by erasure
<span class="fc" id="L360">			final var referrer = Objects.requireNonNull(hierarchyByErasure.get(erasedReferrerClass));</span>
<span class="fc" id="L361">			final var superTypeFacade = new TypeFacade&lt;&gt;(superTypeTemplate, referrer, IuReferenceKind.SUPER);</span>
<span class="fc" id="L362">			hierarchyByErasure.put(superTypeFacade.erasedClass(), superTypeFacade);</span>
<span class="fc" id="L363">		}</span>

<span class="fc" id="L365">		this.hierarchy = hierarchyByErasure.values();</span>

<span class="fc bfc" id="L367" title="All 2 branches covered.">		if (type instanceof ParameterizedType parameterizedType) {</span>
<span class="fc" id="L368">			final var actualTypeArguments = parameterizedType.getActualTypeArguments();</span>
<span class="fc" id="L369">			final var typeVariables = annotatedElement.getTypeParameters();</span>
<span class="fc" id="L370">			final var length = actualTypeArguments.length;</span>
<span class="fc bfc" id="L371" title="All 2 branches covered.">			assert typeVariables.length == length; // enforced by javac</span>
<span class="fc bfc" id="L372" title="All 2 branches covered.">			for (var i = 0; i &lt; length; i++)</span>
<span class="fc" id="L373">				parameterizedElement.apply(this, typeVariables[i], actualTypeArguments[i]);</span>
		}

<span class="fc" id="L376">		fields = initializeFields();</span>
<span class="fc" id="L377">		properties = initializeProperties();</span>
<span class="fc" id="L378">		methods = initializeMethods();</span>

<span class="fc" id="L380">		parameterizedElement.seal(annotatedElement, this);</span>
<span class="fc" id="L381">		super.seal();</span>
<span class="fc" id="L382">	}</span>

	/**
	 * Unsupported, use {@link #sealHierarchy(Iterable)} to provide hierarchy when
	 * sealing.
	 * 
	 * @throws UnsupportedOperationException when invoked
	 */
	@Override
	final void seal() throws UnsupportedOperationException {
<span class="fc" id="L392">		throw new UnsupportedOperationException(&quot;use sealHierarchy() only with TypeTemplate&quot;);</span>
	}

	/**
	 * Seals {@link #hierarchy()} and resolves &lt;strong&gt;inherited elements&lt;/strong&gt;.
	 * 
	 * @param hierarchy Resolved type hierarchy
	 */
	void sealHierarchy(Iterable&lt;? extends IuType&lt;?, ? super T&gt;&gt; hierarchy) {
<span class="fc bfc" id="L401" title="All 2 branches covered.">		if (declaringType == null)</span>
<span class="fc" id="L402">			doSealHierarchy(hierarchy);</span>
		else
<span class="fc" id="L404">			declaringType.template.postInit(() -&gt; doSealHierarchy(hierarchy));</span>
<span class="fc" id="L405">	}</span>

	/**
	 * Subscribes a new instance listener.
	 * 
	 * @param instanceListener will be provided a reference to each new instance
	 *                         created via {@link IuConstructor#exec(Object...)},
	 *                         directly before return
	 */
	void observeNewInstances(Consumer&lt;T&gt; instanceListener) {
<span class="fc" id="L415">		instanceListeners.accept(instanceListener);</span>
<span class="fc" id="L416">	}</span>

	/**
	 * Observes a new instance.
	 * 
	 * @param instance newly created instance of the decorated type, directly before
	 *                 return from {@link IuConstructor#exec(Object...)},
	 */
	void observeNewInstance(T instance) {
<span class="fc" id="L425">		instanceListeners.visit(listener -&gt; {</span>
<span class="fc bfc" id="L426" title="All 2 branches covered.">			if (listener != null)</span>
<span class="fc" id="L427">				listener.accept(instance);</span>
<span class="fc" id="L428">			return null;</span>
		});
<span class="fc" id="L430">	}</span>

	@Override
	public Map&lt;String, TypeFacade&lt;?, ?&gt;&gt; typeParameters() {
<span class="fc" id="L434">		checkSealed();</span>
<span class="fc" id="L435">		return parameterizedElement.typeParameters();</span>
	}

	@Override
	public String name() {
<span class="fc" id="L440">		return annotatedElement.getName();</span>
	}

	@Override
	public IuTypeReference&lt;T, ?&gt; reference() {
<span class="fc" id="L445">		return null;</span>
	}

	@Override
	public Type deref() {
<span class="fc" id="L450">		return type;</span>
	}

	@Override
	public IuType&lt;D, T&gt; erase() {
<span class="fc" id="L455">		return erasedType;</span>
	}

	@Override
	public Class&lt;T&gt; erasedClass() {
<span class="fc" id="L460">		return annotatedElement;</span>
	}

	@Override
	public IuType&lt;?, ? super T&gt; referTo(Type referentType) {
<span class="fc" id="L465">		return TypeUtils.referTo(this, hierarchy(), referentType);</span>
	}

	@Override
	public Iterable&lt;TypeFacade&lt;T, ?&gt;&gt; enclosedTypes() {
<span class="fc" id="L470">		checkSealed();</span>
<span class="fc" id="L471">		return enclosedTypes;</span>
	}

	@Override
	public Iterable&lt;? extends IuConstructor&lt;T&gt;&gt; constructors() {
<span class="fc" id="L476">		return constructors;</span>
	}

	@Override
	public Iterable&lt;TypeFacade&lt;?, ? super T&gt;&gt; hierarchy() {
<span class="fc bfc" id="L481" title="All 2 branches covered.">		if (hierarchy == null)</span>
<span class="fc" id="L482">			throw new IllegalStateException(&quot;hierarchy not sealed&quot;);</span>
<span class="fc" id="L483">		return hierarchy;</span>
	}

	@Override
	@SuppressWarnings(&quot;unchecked&quot;)
	public &lt;F&gt; FieldFacade&lt;? super T, F&gt; field(String name) {
<span class="fc" id="L489">		return (FieldFacade&lt;? super T, F&gt;) IuType.super.field(name);</span>
	}

	@Override
	public Iterable&lt;FieldFacade&lt;? super T, ?&gt;&gt; fields() {
<span class="fc bfc" id="L494" title="All 2 branches covered.">		if (fields == null)</span>
<span class="fc" id="L495">			throw new IllegalStateException(&quot;fields not sealed&quot;);</span>
<span class="fc" id="L496">		return fields;</span>
	}

	@Override
	public Iterable&lt;PropertyFacade&lt;? super T, ?&gt;&gt; properties() {
<span class="fc bfc" id="L501" title="All 2 branches covered.">		if (properties == null)</span>
<span class="fc" id="L502">			throw new IllegalStateException(&quot;properties not sealed&quot;);</span>
<span class="fc" id="L503">		return properties;</span>
	}

	@Override
	public Iterable&lt;MethodFacade&lt;? super T, ?&gt;&gt; methods() {
<span class="fc bfc" id="L508" title="All 2 branches covered.">		if (methods == null)</span>
<span class="fc" id="L509">			throw new IllegalStateException(&quot;methods not sealed&quot;);</span>
<span class="fc" id="L510">		return methods;</span>
	}

	@Override
	public String toString() {
<span class="fc" id="L515">		return &quot;IuType[&quot; + TypeUtils.printType(deref()) + ']';</span>
	}

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.10.202304240956</span></div></body></html>