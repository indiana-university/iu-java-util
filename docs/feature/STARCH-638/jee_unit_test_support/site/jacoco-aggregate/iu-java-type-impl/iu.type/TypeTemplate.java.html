<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>TypeTemplate.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">IU Java Utilities API Reference</a> &gt; <a href="../index.html" class="el_bundle">iu-java-type-impl</a> &gt; <a href="index.source.html" class="el_package">iu.type</a> &gt; <span class="el_source">TypeTemplate.java</span></div><h1>TypeTemplate.java</h1><pre class="source lang-java linenums">/*
 * Copyright Â© 2023 Indiana University
 * All rights reserved.
 *
 * BSD 3-Clause License
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 
 * - Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 * 
 * - Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 * 
 * - Neither the name of the copyright holder nor the names of its
 *   contributors may be used to endorse or promote products derived from
 *   this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package iu.type;

import java.beans.Introspector;
import java.lang.reflect.AnnotatedElement;
import java.lang.reflect.Constructor;
import java.lang.reflect.Modifier;
import java.lang.reflect.ParameterizedType;
import java.lang.reflect.Type;
import java.util.ArrayDeque;
import java.util.Arrays;
import java.util.LinkedHashMap;
import java.util.Map;
import java.util.Objects;
import java.util.Queue;
import java.util.function.Consumer;

import edu.iu.IuException;
import edu.iu.IuVisitor;
import edu.iu.type.IuConstructor;
import edu.iu.type.IuReferenceKind;
import edu.iu.type.IuType;
import edu.iu.type.IuTypeReference;

/**
 * Represents the internal structure of a {@link TypeFacade}.
 * 
 * &lt;p&gt;
 * Each template is a standalone representation of a single generic type,
 * potentially paired with a raw template representing its erasure.
 * &lt;/p&gt;
 * 
 * &lt;p&gt;
 * Note that {@link TypeTemplate} is not sterotyped as a hash key, but
 * {@link IuType} is. This hash key behavior comes from same-instance identity
 * default {@link #hashCode()} and {@link #equals(Object)} implementations of
 * instances managed by {@link TypeFactory}. Since ClassLoading data is loaded
 * exactly once and remains static once loaded, type introspection instances
 * match that load-once static behavior. It is expected that each raw type
 * (primitive, class, interface, enum, record, etc) has exactly one
 * {@link TypeTemplate} instance, and that each {@link TypeTemplate} instance
 * backed by a generic type contains a {@link TypeFacade} backed by a singleton
 * raw type instances representing its {@link #erase() type erasure}. This
 * behavior mirrors the hash key behavior of {@link Type}, so internal checks
 * for equality (and inequality) may use == (and !=).
 * &lt;/p&gt;
 * 
 * &lt;p&gt;
 * Note also that Java does not constrain the number of {@link Type} instances,
 * and considers those instances other than {@link Class} to be disposable.
 * {@link TypeFactory} does not manage {@link TypeTemplate} instances for
 * generic type markers once returned to the application.
 * &lt;/p&gt;
 * 
 * &lt;h2&gt;Initialization Order&lt;/h2&gt;
 * &lt;p&gt;
 * Type templates are initialized in two phases, managed by {@link TypeFactory}.
 * &lt;/p&gt;
 * &lt;ol&gt;
 * &lt;li&gt;Declared elements&lt;/li&gt;
 * &lt;li&gt;Inherited elements&lt;/li&gt;
 * &lt;/ol&gt;
 * 
 * &lt;h3&gt;Declared Elements&lt;/h3&gt;
 * &lt;p&gt;
 * Resolved in order upon instantiation:
 * &lt;/p&gt;
 * &lt;ol&gt;
 * &lt;li&gt;{@link ElementBase#ElementBase(Consumer)} {@code preInitHook} binds raw
 * {@link Class} instances to {@link TypeFactory}{@code #RAW_TYPES}&lt;/li&gt;
 * &lt;li&gt;{@link AnnotatedElementBase#AnnotatedElementBase(AnnotatedElement, Consumer)}
 * binds {@link #annotatedElement}&lt;/li&gt;
 * &lt;li&gt;{@link DeclaredElementBase#DeclaredElementBase(AnnotatedElement, Consumer, Type, TypeTemplate)}
 * binds:
 * &lt;ul&gt;
 * &lt;li&gt;{@link #type}&lt;/li&gt;
 * &lt;li&gt;{@link #declaringType()}, potentially null or unsealed&lt;/li&gt;
 * &lt;/ul&gt;
 * &lt;/li&gt;
 * &lt;li&gt;Apply actual type arguments from {@link ParameterizedType}&lt;/li&gt;
 * &lt;li&gt;{@link #erase()}&lt;/li&gt;
 * &lt;li&gt;{@link #constructors()}&lt;/li&gt;
 * &lt;/ol&gt;
 * 
 * &lt;h3&gt;Inherited Elements&lt;/h3&gt;
 * &lt;p&gt;
 * Resolved by {@link #sealHierarchy(Iterable)}, order incidental
 * &lt;/p&gt;
 * &lt;ul&gt;
 * &lt;li&gt;{@link #fields()}&lt;/li&gt;
 * &lt;li&gt;{@link #properties()}&lt;/li&gt;
 * &lt;li&gt;{@link #methods()}&lt;/li&gt;
 * &lt;li&gt;{@link #typeParameters()}&lt;/li&gt;
 * &lt;/ul&gt;
 * 
 * @param &lt;D&gt; declaring type
 * @param &lt;T&gt; raw or generic type
 */
<span class="fc" id="L129">final class TypeTemplate&lt;D, T&gt; extends DeclaredElementBase&lt;D, Class&lt;T&gt;&gt; implements IuType&lt;D, T&gt;, ParameterizedFacade {</span>

	@SuppressWarnings(&quot;unchecked&quot;)
	private static &lt;D&gt; TypeTemplate&lt;?, D&gt; resolveDeclaringType(Class&lt;?&gt; enclosed) {
<span class="fc" id="L133">		final var declaringClass = enclosed.getDeclaringClass();</span>
<span class="fc bfc" id="L134" title="All 2 branches covered.">		if (declaringClass == null)</span>
<span class="fc" id="L135">			return null;</span>
<span class="fc" id="L136">		return (TypeTemplate&lt;?, D&gt;) TypeFactory.resolveRawClass(declaringClass);</span>
	}

	// Declared
	private IuType&lt;D, T&gt; erasedType;
	private Iterable&lt;TypeFacade&lt;T, ?&gt;&gt; enclosedTypes;
	private Iterable&lt;ConstructorFacade&lt;T&gt;&gt; constructors;

	// Inherited
	private Iterable&lt;TypeFacade&lt;?, ? super T&gt;&gt; hierarchy;
	private Iterable&lt;FieldFacade&lt;? super T, ?&gt;&gt; fields;
	private Iterable&lt;PropertyFacade&lt;? super T, ?&gt;&gt; properties;
	private Iterable&lt;MethodFacade&lt;? super T, ?&gt;&gt; methods;

	// Parameterized
<span class="fc" id="L151">	private final ParameterizedElement parameterizedElement = new ParameterizedElement();</span>

	// Instance management
<span class="fc" id="L154">	private final IuVisitor&lt;Consumer&lt;T&gt;&gt; instanceListeners = new IuVisitor&lt;&gt;();</span>

	private TypeTemplate(Class&lt;T&gt; annotatedElement, Consumer&lt;TypeTemplate&lt;?, ?&gt;&gt; preInitHook, Type type,
			TypeTemplate&lt;D, T&gt; erasedType) {
<span class="fc" id="L158">		super(annotatedElement, preInitHook, type, resolveDeclaringType(annotatedElement));</span>

<span class="fc bfc" id="L160" title="All 4 branches covered.">		if (declaringType == null || isStatic())</span>
<span class="fc" id="L161">			initializeDeclared(erasedType);</span>
		else
<span class="fc" id="L163">			declaringType.template.postInit(() -&gt; initializeDeclared(erasedType));</span>
<span class="fc" id="L164">	}</span>

	/**
	 * Raw class constructor intended for use only by {@link TypeFactory}.
	 * 
	 * @param rawClass    raw class
	 * @param preInitHook receives a handle to {@code this} after binding the
	 *                    annotated element but before initializing and members
	 */
	TypeTemplate(Class&lt;T&gt; rawClass, Consumer&lt;TypeTemplate&lt;?, ?&gt;&gt; preInitHook) {
<span class="fc" id="L174">		this(rawClass, preInitHook, rawClass, null);</span>
<span class="fc" id="L175">	}</span>

	/**
	 * Generic type constructor intended for use only by {@link TypeFactory}.
	 * 
	 * @param preInitHook receives a handle to {@code this} after binding the
	 *                    annotated element but before initializing and members
	 * @param type        generic type; &lt;em&gt;must not&lt;/em&gt; be a class
	 * @param erasedType  pre-calculated raw type template; a {@link TypeTemplate}
	 *                    cannot be created for a generic type without a
	 *                    fully-formed instance of its type erasure, provided as an
	 *                    argument to this parameter
	 */
	TypeTemplate(Consumer&lt;TypeTemplate&lt;?, ?&gt;&gt; preInitHook, Type type, TypeTemplate&lt;D, T&gt; erasedType) {
<span class="fc" id="L189">		this(erasedType.erasedClass(), preInitHook, type, erasedType);</span>
<span class="fc bfc" id="L190" title="All 2 branches covered.">		assert !(type instanceof Class) : type;</span>
<span class="fc bfc" id="L191" title="All 2 branches covered.">		assert erasedType.erasedClass() == TypeFactory.getErasedClass(type)</span>
<span class="fc" id="L192">				: erasedType + &quot; &quot; + TypeUtils.printType(type);</span>

<span class="fc" id="L194">		erasedType.postInit(() -&gt; sealHierarchy(erasedType.hierarchy));</span>
<span class="fc" id="L195">	}</span>

	private boolean isNative() {
<span class="fc" id="L198">		final var packageName = annotatedElement.getPackageName();</span>
<span class="fc" id="L199">		final var targetModule = annotatedElement.getModule();</span>
<span class="fc" id="L200">		final var typeImplModule = getClass().getModule();</span>
<span class="fc bfc" id="L201" title="All 4 branches covered.">		return IuType.isPlatformType(name()) //</span>
				|| targetModule == typeImplModule //
<span class="fc bfc" id="L203" title="All 2 branches covered.">				|| !targetModule.isOpen(packageName, typeImplModule);</span>
	}

	private void initializeDeclared(TypeTemplate&lt;D, T&gt; erasedType) {
<span class="fc bfc" id="L207" title="All 4 branches covered.">		if (declaringType != null &amp;&amp; !isStatic())</span>
<span class="fc" id="L208">			parameterizedElement.apply(declaringType.template.typeParameters());</span>

<span class="fc bfc" id="L210" title="All 2 branches covered.">		if (erasedType == null) {</span>
<span class="fc" id="L211">			this.erasedType = this;</span>
<span class="fc" id="L212">			initializeConstructors();</span>
		} else {
<span class="fc" id="L214">			this.erasedType = new TypeFacade&lt;D, T&gt;(erasedType, this, IuReferenceKind.ERASURE);</span>
<span class="fc" id="L215">			erasedType.postInit(() -&gt; {</span>
<span class="fc" id="L216">				initializeConstructors();</span>
<span class="fc" id="L217">			});</span>
		}
<span class="fc" id="L219">	}</span>

	@SuppressWarnings({ &quot;rawtypes&quot;, &quot;unchecked&quot; })
	private void initializeEnclosedTypes() {
<span class="fc" id="L223">		Queue&lt;TypeFacade&lt;T, ?&gt;&gt; enclosedTypes = new ArrayDeque&lt;&gt;();</span>

<span class="fc bfc" id="L225" title="All 2 branches covered.">		if (!isNative()) {</span>
<span class="fc" id="L226">			Class&lt;?&gt;[] enclosedClasses = annotatedElement.getDeclaredClasses();</span>
<span class="fc" id="L227">			postInit(() -&gt; {</span>
<span class="fc bfc" id="L228" title="All 2 branches covered.">				for (var enclosedClass : enclosedClasses) {</span>
<span class="fc" id="L229">					final var enclosedType = TypeFactory.resolveRawClass(enclosedClass);</span>
<span class="fc" id="L230">					enclosedTypes.offer(new TypeFacade(enclosedType, this, IuReferenceKind.ENCLOSING_TYPE));</span>
				}
<span class="fc" id="L232">			});</span>
		}

<span class="fc" id="L235">		this.enclosedTypes = enclosedTypes;</span>
<span class="fc" id="L236">	}</span>

	@SuppressWarnings(&quot;unchecked&quot;)
	private void initializeConstructors() {
<span class="fc" id="L240">		Queue&lt;ConstructorFacade&lt;T&gt;&gt; constructors = new ArrayDeque&lt;&gt;();</span>

<span class="fc bfc" id="L242" title="All 2 branches covered.">		if (!isNative() //</span>
<span class="fc bfc" id="L243" title="All 2 branches covered.">				&amp;&amp; !annotatedElement.isInterface() //</span>
<span class="fc bfc" id="L244" title="All 2 branches covered.">				&amp;&amp; !annotatedElement.isEnum())</span>
<span class="fc bfc" id="L245" title="All 2 branches covered.">			for (var constructor : annotatedElement.getDeclaredConstructors())</span>
				// _unchecked warning_: see source for #getDeclaredConstructors()
				// =&gt; This cast is safe as of Java 17
<span class="fc" id="L248">				constructors.offer(new ConstructorFacade&lt;&gt;((Constructor&lt;T&gt;) constructor, this));</span>

<span class="fc" id="L250">		this.constructors = constructors;</span>
<span class="fc" id="L251">	}</span>

	@SuppressWarnings({ &quot;unchecked&quot;, &quot;rawtypes&quot; })
	private Iterable&lt;FieldFacade&lt;? super T, ?&gt;&gt; initializeFields() {
<span class="fc" id="L255">		Queue&lt;FieldFacade&lt;? super T, ?&gt;&gt; rv = new ArrayDeque&lt;&gt;();</span>

<span class="fc bfc" id="L257" title="All 2 branches covered.">		if (!isNative()) //</span>
<span class="fc bfc" id="L258" title="All 2 branches covered.">			for (var field : annotatedElement.getDeclaredFields()) {</span>
				TypeTemplate&lt;?, ?&gt; fieldType;
<span class="fc bfc" id="L260" title="All 2 branches covered.">				if (field.getType() == annotatedElement)</span>
<span class="fc" id="L261">					fieldType = this;</span>
				else
<span class="fc" id="L263">					fieldType = TypeFactory.resolveType(field.getGenericType());</span>

<span class="fc" id="L265">				rv.offer(new FieldFacade(field, fieldType, this));</span>
			}

<span class="fc bfc" id="L268" title="All 2 branches covered.">		for (var superType : hierarchy)</span>
<span class="fc" id="L269">			superType.template.postInit(() -&gt; {</span>
<span class="fc bfc" id="L270" title="All 2 branches covered.">				for (var inheritedField : superType.template.fields)</span>
<span class="fc" id="L271">					rv.offer(inheritedField);</span>
<span class="fc" id="L272">			});</span>

<span class="fc" id="L274">		return rv;</span>
	}

	@SuppressWarnings({ &quot;unchecked&quot;, &quot;rawtypes&quot; })
	private Iterable&lt;PropertyFacade&lt;? super T, ?&gt;&gt; initializeProperties() {
<span class="fc" id="L279">		Queue&lt;PropertyFacade&lt;? super T, ?&gt;&gt; rv = new ArrayDeque&lt;&gt;();</span>

<span class="fc bfc" id="L281" title="All 2 branches covered.">		if (!isNative()) //</span>
<span class="fc bfc" id="L282" title="All 2 branches covered.">			for (var property : IuException.unchecked(() -&gt; Introspector.getBeanInfo(annotatedElement))</span>
<span class="fc" id="L283">					.getPropertyDescriptors()) {</span>
<span class="fc bfc" id="L284" title="All 2 branches covered.">				if (property.getName().equals(&quot;class&quot;))</span>
<span class="fc" id="L285">					continue;</span>

<span class="fc" id="L287">				var readMethod = property.getReadMethod();</span>
<span class="fc" id="L288">				var writeMethod = property.getWriteMethod();</span>

				Type propertyType;
<span class="fc bfc" id="L291" title="All 2 branches covered.">				if (readMethod != null)</span>
<span class="fc" id="L292">					propertyType = readMethod.getGenericReturnType();</span>
<span class="fc bfc" id="L293" title="All 2 branches covered.">				else if (writeMethod != null)</span>
<span class="fc" id="L294">					propertyType = writeMethod.getGenericParameterTypes()[0];</span>
				else
					continue;

				TypeTemplate&lt;?, T&gt; propertyTypeTemplate;
<span class="fc bfc" id="L299" title="All 2 branches covered.">				if (propertyType == annotatedElement)</span>
<span class="fc" id="L300">					propertyTypeTemplate = this;</span>
				else
<span class="fc" id="L302">					propertyTypeTemplate = (TypeTemplate&lt;?, T&gt;) TypeFactory.resolveType(propertyType);</span>

<span class="fc" id="L304">				rv.offer(new PropertyFacade(property, propertyTypeTemplate, this));</span>
			}

<span class="fc bfc" id="L307" title="All 2 branches covered.">		for (var superType : hierarchy)</span>
<span class="fc" id="L308">			superType.template.postInit(() -&gt; {</span>
<span class="fc bfc" id="L309" title="All 2 branches covered.">				for (var inheritedProperty : superType.template.properties)</span>
<span class="fc" id="L310">					rv.offer(inheritedProperty);</span>
<span class="fc" id="L311">			});</span>

<span class="fc" id="L313">		return rv;</span>
	}

	private Iterable&lt;MethodFacade&lt;? super T, ?&gt;&gt; initializeMethods() {
<span class="fc" id="L317">		Queue&lt;MethodFacade&lt;? super T, ?&gt;&gt; rv = new ArrayDeque&lt;&gt;();</span>

<span class="fc bfc" id="L319" title="All 2 branches covered.">		if (!isNative()) //</span>
<span class="fc bfc" id="L320" title="All 2 branches covered.">			for (var method : annotatedElement.getDeclaredMethods()) {</span>
<span class="fc bfc" id="L321" title="All 2 branches covered.">				if (method.isSynthetic())</span>
<span class="fc" id="L322">					continue; // skip lambdas</span>

				TypeTemplate&lt;?, ?&gt; returnType;
<span class="fc bfc" id="L325" title="All 2 branches covered.">				if (method.getReturnType() == annotatedElement)</span>
<span class="fc" id="L326">					returnType = this;</span>
				else
<span class="fc" id="L328">					returnType = TypeFactory.resolveType(method.getGenericReturnType());</span>

<span class="fc" id="L330">				rv.offer(new MethodFacade&lt;&gt;(method, returnType, this));</span>
			}

<span class="fc bfc" id="L333" title="All 2 branches covered.">		for (var superType : hierarchy)</span>
<span class="fc" id="L334">			superType.template.postInit(() -&gt; {</span>
<span class="fc bfc" id="L335" title="All 2 branches covered.">				for (var inheritedMethod : superType.template.methods)</span>
<span class="fc" id="L336">					rv.offer(inheritedMethod);</span>
<span class="fc" id="L337">			});</span>

<span class="fc" id="L339">		return rv;</span>
	}

	private void doSealHierarchy(Iterable&lt;? extends IuType&lt;?, ? super T&gt;&gt; hierarchy) {
<span class="fc" id="L343">		Map&lt;Class&lt;?&gt;, TypeFacade&lt;?, ? super T&gt;&gt; hierarchyByErasure = new LinkedHashMap&lt;&gt;();</span>
<span class="fc bfc" id="L344" title="All 2 branches covered.">		for (var superType : hierarchy) {</span>
<span class="fc" id="L345">			var templateReference = superType.reference();</span>

			TypeTemplate&lt;?, ? super T&gt; superTypeTemplate;
<span class="fc bfc" id="L348" title="All 2 branches covered.">			if (templateReference == null) {</span>
<span class="fc" id="L349">				superTypeTemplate = (TypeTemplate&lt;?, ? super T&gt;) superType;</span>

				// common case: direct generalization of raw class
<span class="fc" id="L352">				hierarchyByErasure.put(superType.erasedClass(),</span>
						new TypeFacade&lt;&gt;(superTypeTemplate, this, IuReferenceKind.SUPER));
<span class="fc" id="L354">				continue;</span>
			}

			else // exception case: inherited generalization ...
<span class="fc" id="L358">				superTypeTemplate = ((TypeFacade&lt;?, ? super T&gt;) superType).template;</span>

			// ... by type erasure, same as direct
<span class="fc" id="L361">			var erasedReferrerClass = ((IuType&lt;?, ?&gt;) templateReference.referrer()).erasedClass();</span>
<span class="fc bfc" id="L362" title="All 2 branches covered.">			if (erasedReferrerClass == annotatedElement) {</span>
<span class="fc" id="L363">				hierarchyByErasure.put(superType.erasedClass(),</span>
						new TypeFacade&lt;&gt;(superTypeTemplate, this, IuReferenceKind.SUPER));
<span class="fc" id="L365">				continue;</span>
			}

			// ... via superclass or interface, look up unsealed reference by erasure
<span class="fc" id="L369">			final var referrer = Objects.requireNonNull(hierarchyByErasure.get(erasedReferrerClass));</span>
<span class="fc" id="L370">			final var superTypeFacade = new TypeFacade&lt;&gt;(superTypeTemplate, referrer, IuReferenceKind.SUPER);</span>
<span class="fc" id="L371">			hierarchyByErasure.put(superTypeFacade.erasedClass(), superTypeFacade);</span>
<span class="fc" id="L372">		}</span>

<span class="fc" id="L374">		this.hierarchy = hierarchyByErasure.values();</span>

<span class="fc bfc" id="L376" title="All 2 branches covered.">		if (type instanceof ParameterizedType parameterizedType) {</span>
<span class="fc" id="L377">			final var actualTypeArguments = parameterizedType.getActualTypeArguments();</span>
<span class="fc" id="L378">			final var typeVariables = annotatedElement.getTypeParameters();</span>
<span class="fc" id="L379">			final var length = actualTypeArguments.length;</span>
<span class="fc bfc" id="L380" title="All 2 branches covered.">			assert typeVariables.length == length; // enforced by javac</span>
<span class="fc bfc" id="L381" title="All 2 branches covered.">			for (var i = 0; i &lt; length; i++)</span>
<span class="fc" id="L382">				parameterizedElement.apply(this, typeVariables[i], actualTypeArguments[i]);</span>
		}

<span class="fc" id="L385">		fields = initializeFields();</span>
<span class="fc" id="L386">		properties = initializeProperties();</span>
<span class="fc" id="L387">		methods = initializeMethods();</span>

<span class="fc" id="L389">		parameterizedElement.seal(annotatedElement, this);</span>
<span class="fc" id="L390">		super.seal();</span>
<span class="fc" id="L391">	}</span>

	/**
	 * Unsupported, use {@link #sealHierarchy(Iterable)} to provide hierarchy when
	 * sealing.
	 * 
	 * @throws UnsupportedOperationException when invoked
	 */
	@Override
	final void seal() throws UnsupportedOperationException {
<span class="fc" id="L401">		throw new UnsupportedOperationException(&quot;use sealHierarchy() only with TypeTemplate&quot;);</span>
	}

	private boolean isStatic() {
<span class="fc" id="L405">		final var erased = erasedClass();</span>
<span class="pc bpc" id="L406" title="1 of 6 branches missed.">		if (erased.isInterface() || erased.isRecord() || erased.isEnum())</span>
<span class="fc" id="L407">			return true;</span>

<span class="fc" id="L409">		final var mod = annotatedElement.getModifiers();</span>
<span class="fc bfc" id="L410" title="All 2 branches covered.">		return (mod | Modifier.STATIC) == mod;</span>
	}

	/**
	 * Seals {@link #hierarchy()} and resolves &lt;strong&gt;inherited elements&lt;/strong&gt;.
	 * 
	 * @param hierarchy Resolved type hierarchy
	 */
	void sealHierarchy(Iterable&lt;? extends IuType&lt;?, ? super T&gt;&gt; hierarchy) {
<span class="fc bfc" id="L419" title="All 4 branches covered.">		if (declaringType == null || isStatic())</span>
<span class="fc" id="L420">			doSealHierarchy(hierarchy);</span>
		else
<span class="fc" id="L422">			declaringType.template.postInit(() -&gt; doSealHierarchy(hierarchy));</span>
<span class="fc" id="L423">	}</span>

	/**
	 * Subscribes a new instance listener.
	 * 
	 * @param instanceListener will be provided a reference to each new instance
	 *                         created via {@link IuConstructor#exec(Object...)},
	 *                         directly before return
	 */
	void observeNewInstances(Consumer&lt;T&gt; instanceListener) {
<span class="fc" id="L433">		instanceListeners.accept(instanceListener);</span>
<span class="fc" id="L434">	}</span>

	/**
	 * Observes a new instance.
	 * 
	 * @param instance newly created instance of the decorated type, directly before
	 *                 return from {@link IuConstructor#exec(Object...)},
	 */
	void observeNewInstance(T instance) {
<span class="fc" id="L443">		instanceListeners.visit(listener -&gt; {</span>
<span class="fc bfc" id="L444" title="All 2 branches covered.">			if (listener != null)</span>
<span class="fc" id="L445">				listener.accept(instance);</span>
<span class="fc" id="L446">			return null;</span>
		});
<span class="fc" id="L448">	}</span>

	@Override
	public Map&lt;String, TypeFacade&lt;?, ?&gt;&gt; typeParameters() {
<span class="fc" id="L452">		checkSealed();</span>
<span class="fc" id="L453">		return parameterizedElement.typeParameters();</span>
	}

	@Override
	public String name() {
<span class="fc" id="L458">		return annotatedElement.getName();</span>
	}

	@Override
	public IuTypeReference&lt;T, ?&gt; reference() {
<span class="fc" id="L463">		return null;</span>
	}

	@Override
	public Type deref() {
<span class="fc" id="L468">		return type;</span>
	}

	@Override
	public IuType&lt;D, T&gt; erase() {
<span class="fc" id="L473">		return erasedType;</span>
	}

	@Override
	public Class&lt;T&gt; erasedClass() {
<span class="fc" id="L478">		return annotatedElement;</span>
	}

	@Override
	public IuType&lt;?, ? super T&gt; referTo(Type referentType) {
<span class="fc" id="L483">		return TypeUtils.referTo(this, hierarchy(), referentType);</span>
	}

	@Override
	public Iterable&lt;TypeFacade&lt;T, ?&gt;&gt; enclosedTypes() {
<span class="fc bfc" id="L488" title="All 2 branches covered.">		if (enclosedTypes == null)</span>
<span class="fc" id="L489">			initializeEnclosedTypes();</span>
<span class="fc" id="L490">		return enclosedTypes;</span>
	}

	@Override
	public Iterable&lt;? extends IuConstructor&lt;T&gt;&gt; constructors() {
<span class="fc" id="L495">		return constructors;</span>
	}

	@Override
	public Iterable&lt;TypeFacade&lt;?, ? super T&gt;&gt; hierarchy() {
<span class="fc bfc" id="L500" title="All 2 branches covered.">		if (hierarchy == null)</span>
<span class="fc" id="L501">			throw new IllegalStateException(&quot;hierarchy not sealed&quot;);</span>
<span class="fc" id="L502">		return hierarchy;</span>
	}

	@Override
	@SuppressWarnings(&quot;unchecked&quot;)
	public &lt;F&gt; FieldFacade&lt;? super T, F&gt; field(String name) {
<span class="fc" id="L508">		return (FieldFacade&lt;? super T, F&gt;) IuType.super.field(name);</span>
	}

	@Override
	public Iterable&lt;FieldFacade&lt;? super T, ?&gt;&gt; fields() {
<span class="fc bfc" id="L513" title="All 2 branches covered.">		if (fields == null)</span>
<span class="fc" id="L514">			throw new IllegalStateException(&quot;fields not sealed&quot;);</span>
<span class="fc" id="L515">		return fields;</span>
	}

	@Override
	public Iterable&lt;PropertyFacade&lt;? super T, ?&gt;&gt; properties() {
<span class="fc bfc" id="L520" title="All 2 branches covered.">		if (properties == null)</span>
<span class="fc" id="L521">			throw new IllegalStateException(&quot;properties not sealed&quot;);</span>
<span class="fc" id="L522">		return properties;</span>
	}

	@Override
	public Iterable&lt;MethodFacade&lt;? super T, ?&gt;&gt; methods() {
<span class="fc bfc" id="L527" title="All 2 branches covered.">		if (methods == null)</span>
<span class="fc" id="L528">			throw new IllegalStateException(&quot;methods not sealed&quot;);</span>
<span class="fc" id="L529">		return methods;</span>
	}

	@Override
	public String toString() {
<span class="fc" id="L534">		return &quot;IuType[&quot; + TypeUtils.printType(deref()) + ']';</span>
	}

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.10.202304240956</span></div></body></html>