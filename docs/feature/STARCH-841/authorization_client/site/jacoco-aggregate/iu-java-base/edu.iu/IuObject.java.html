<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>IuObject.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">IU Java Utilities API Reference</a> &gt; <a href="../index.html" class="el_bundle">iu-java-base</a> &gt; <a href="index.source.html" class="el_package">edu.iu</a> &gt; <span class="el_source">IuObject.java</span></div><h1>IuObject.java</h1><pre class="source lang-java linenums">/*
 * Copyright Â© 2024 Indiana University
 * All rights reserved.
 *
 * BSD 3-Clause License
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 
 * - Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 * 
 * - Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 * 
 * - Neither the name of the copyright holder nor the names of its
 *   contributors may be used to endorse or promote products derived from
 *   this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package edu.iu;

import java.lang.reflect.Array;
import java.time.Duration;
import java.time.Instant;
import java.util.Arrays;
import java.util.Comparator;
import java.util.Iterator;
import java.util.Map;
import java.util.Objects;
import java.util.Set;
import java.util.SortedSet;
import java.util.concurrent.TimeoutException;
import java.util.function.BooleanSupplier;
import java.util.function.Function;
import java.util.function.Predicate;
import java.util.function.Supplier;

/**
 * Simplifies building efficient {@link Object#equals(Object)},
 * {@link Object#hashCode()}, and {@link Comparable#compareTo(Object)} methods
 * on plain Java objects.
 * 
 * &lt;p&gt;
 * The use of this utility is preferred, following the examples below, over
 * other methods of generating these methods. When following these examples, the
 * implements can be expected to follow the expected contracts in a null-safe
 * and type-safe manner without undue object creation.
 * &lt;/p&gt;
 * 
 * &lt;dl&gt;
 * &lt;dt&gt;Top level object:&lt;/dt&gt;
 * &lt;dd&gt;
 * 
 * &lt;pre&gt;
 * &amp;#064;Override
 * public int hashCode() {
 * 	return ObjectUtil.hashCode(val1, val2);
 * }
 * 
 * &amp;#064;Override
 * public boolean equals(Object obj) {
 * 	if (!ObjectUtil.typeCheck(this, obj))
 * 		return false;
 * 	MyClass other = (MyClass) obj;
 * 	return ObjectUtil.equals(this.val1, other.val1) &amp;amp;&amp;amp; ObjectUtil.equals(this.val2, other.val2);
 * }
 * 
 * &amp;#064;Override
 * public int compareTo(T o) {
 * 	Integer rv = ObjectUtil.compareNullCheck(this, o);
 * 	if (rv != null)
 * 		return rv;
 * 
 * 	rv = ObjectUtil.compareTo(this.val1, o.val1);
 * 	if (rv != 0)
 * 		return rv;
 * 
 * 	return ObjectUtil.compareTo(this.val2, o.val2);
 * }
 * &lt;/pre&gt;
 * 
 * &lt;/dd&gt;
 * 
 * &lt;dt&gt;Subclass object:&lt;/dt&gt;
 * &lt;dd&gt;
 * 
 * &lt;pre&gt;
 * &amp;#064;Override
 * public int hashCode() {
 * 	return ObjectUtil.hashCodeSuper(super.hashCode(), val1, val2);
 * }
 * 
 * &amp;#064;Override
 * public boolean equals(Object obj) {
 * 	if (!ObjectUtil.typeCheck(this, obj))
 * 		return false;
 * 	MyClass other = (MyClass) obj;
 * 	return super.equals(obj) &amp;amp;&amp;amp; ObjectUtil.equals(this.val1, other.val1) &amp;amp;&amp;amp; ObjectUtil.equals(this.val2, other.val2);
 * }
 * 
 * &amp;#064;Override
 * public int compareTo(T o) {
 * 	Integer rv = ObjectUtil.compareNullCheck(this, o);
 * 	if (rv != null)
 * 		return rv;
 * 
 * 	rv = ObjectUtil.compareTo(this.val1, o.val1);
 * 	if (rv != 0)
 * 		return rv;
 * 
 * 	rv = ObjectUtil.compareTo(this.val2, o.val2);
 * 	if (rv != 0)
 * 		return rv;
 * 
 * 	return super.compareTo(o);
 * }
 * &lt;/pre&gt;
 * 
 * &lt;/dd&gt;
 * &lt;/dl&gt;
 * 
 * @since 4.0
 */
public final class IuObject {

	/**
	 * Determines if a name is relative to a package provided by the JDK or JEE
	 * platform.
	 * 
	 * @param name type name
	 * @return {@code true} if a platform type; else false
	 */
	public static boolean isPlatformName(String name) {
<span class="fc bfc" id="L146" title="All 2 branches covered.">		return name.startsWith(&quot;jakarta.&quot;) // JEE and related</span>
				// JDK packages:
<span class="fc bfc" id="L148" title="All 2 branches covered.">				|| name.startsWith(&quot;sun.&quot;) //</span>
<span class="fc bfc" id="L149" title="All 2 branches covered.">				|| name.startsWith(&quot;com.sun.&quot;) //</span>
<span class="fc bfc" id="L150" title="All 2 branches covered.">				|| name.startsWith(&quot;java.&quot;) //</span>
<span class="fc bfc" id="L151" title="All 2 branches covered.">				|| name.startsWith(&quot;javax.&quot;) //</span>
<span class="fc bfc" id="L152" title="All 2 branches covered.">				|| name.startsWith(&quot;jdk.&quot;) //</span>
<span class="fc bfc" id="L153" title="All 2 branches covered.">				|| name.startsWith(&quot;netscape.javascript.&quot;) //</span>
<span class="fc bfc" id="L154" title="All 2 branches covered.">				|| name.startsWith(&quot;org.ietf.jgss.&quot;) //</span>
<span class="fc bfc" id="L155" title="All 2 branches covered.">				|| name.startsWith(&quot;org.w3c.dom.&quot;) //</span>
<span class="fc bfc" id="L156" title="All 2 branches covered.">				|| name.startsWith(&quot;org.xml.sax.&quot;);</span>
	}

	/**
	 * Asserts that a class is in a module that is named and part of a package that
	 * is not open.
	 * 
	 * @param classToCheck {@link Class}
	 * @throws IllegalStateException if the class is in an open module and/or
	 *                               package
	 */
	public static void assertNotOpen(Class&lt;?&gt; classToCheck) throws IllegalStateException {
<span class="fc" id="L168">		final var module = classToCheck.getModule();</span>
<span class="fc bfc" id="L169" title="All 2 branches covered.">		if (module.isOpen(classToCheck.getPackageName()))</span>
<span class="fc" id="L170">			throw new IllegalStateException(&quot;Must be in a named module and not open&quot;);</span>
<span class="fc" id="L171">	}</span>

	/**
	 * Enforces that either a current or new value is non-null, and that both
	 * non-null values are equal.
	 * 
	 * @param &lt;T&gt;     value type
	 * @param current current value
	 * @param value   value to set or enforce as already set
	 * @return value
	 * @throws IllegalArgumentException if already set to the same value
	 */
	public static &lt;T&gt; T once(T current, T value) {
<span class="fc" id="L184">		return once(current, value, () -&gt; &quot;requires a single non-null value&quot;);</span>
	}

	/**
	 * Enforces that either a current or new value is non-null, and that both
	 * non-null values are equal.
	 * 
	 * @param &lt;T&gt;     value type
	 * @param current current value
	 * @param value   value to set or enforce as already set
	 * @param message message for {@link IllegalArgumentException} if current was
	 *                already set to a different value
	 * @return value
	 * @throws IllegalArgumentException if already set to the same value
	 */
	public static &lt;T&gt; T once(T current, T value, String message) {
<span class="fc" id="L200">		return once(current, value, () -&gt; message);</span>
	}

	/**
	 * Enforces that either a current or new value is non-null, and that both
	 * non-null values are equal.
	 * 
	 * @param &lt;T&gt;             value type
	 * @param current         current value
	 * @param value           value to set or enforce as already set
	 * @param messageSupplier provides a message for
	 *                        {@link IllegalArgumentException} if current was
	 *                        already set to a different value
	 * @return value
	 * @throws IllegalArgumentException if already set to the same value
	 */
	public static &lt;T&gt; T once(T current, T value, Supplier&lt;String&gt; messageSupplier) {
<span class="fc" id="L217">		return Objects.requireNonNull(first(current, value, messageSupplier), messageSupplier);</span>
	}

	/**
	 * Gets the first non-null, after enforces that all remaining values are either
	 * null or equal to the first value.
	 * 
	 * @param &lt;T&gt;    value type
	 * @param values values to set or enforce as already set
	 * @return first non-null value
	 * @throws IllegalArgumentException if any values are non-null and not equal to
	 *                                  the returned value
	 */
	@SafeVarargs
	public static &lt;T&gt; T first(T... values) {
<span class="fc" id="L232">		T first = null;</span>
<span class="fc bfc" id="L233" title="All 2 branches covered.">		for (final var value : values)</span>
<span class="fc bfc" id="L234" title="All 2 branches covered.">			if (first == null)</span>
<span class="fc" id="L235">				first = value;</span>
<span class="fc bfc" id="L236" title="All 2 branches covered.">			else if (value == null)</span>
<span class="fc" id="L237">				continue;</span>
<span class="fc bfc" id="L238" title="All 2 branches covered.">			else if (!first.equals(value))</span>
<span class="fc" id="L239">				throw new IllegalArgumentException(&quot;already set to another value&quot;);</span>

<span class="fc" id="L241">		return first;</span>
	}

	/**
	 * Enforces that a value is either not already set or is already set to the same
	 * value.
	 * 
	 * @param &lt;T&gt;             value type
	 * @param current         current value
	 * @param value           value to set or enforce as already set
	 * @param messageSupplier provides a message for
	 *                        {@link IllegalArgumentException} if current was
	 *                        already set to a different value
	 * @return value
	 * @throws IllegalArgumentException if already set to the same value
	 */
	public static &lt;T&gt; T first(T current, T value, Supplier&lt;String&gt; messageSupplier) {
<span class="fc bfc" id="L258" title="All 2 branches covered.">		if (current == null)</span>
<span class="fc" id="L259">			return value;</span>
<span class="fc bfc" id="L260" title="All 2 branches covered.">		else if (value == null)</span>
<span class="fc" id="L261">			return current;</span>
<span class="fc bfc" id="L262" title="All 2 branches covered.">		else if (!current.equals(value))</span>
<span class="fc" id="L263">			throw new IllegalArgumentException(messageSupplier.get());</span>
		else
<span class="fc" id="L265">			return value;</span>
	}

	/**
	 * Determines if either or both objects are null, then if both non-null if both
	 * are {@link #equals(Object, Object)}.
	 * 
	 * &lt;p&gt;
	 * This method is the boolean equivalent of {@link #first(Object...)}
	 * &lt;/p&gt;
	 * 
	 * @param a an object
	 * @param b another object
	 * @return true if either object is null or if both are equal; else false
	 */
	public static boolean represents(Object a, Object b) {
<span class="fc bfc" id="L281" title="All 6 branches covered.">		return a == null || b == null || IuObject.equals(a, b);</span>
	}

	/**
	 * Require value to be an instance of a specific type or null.
	 * 
	 * @param &lt;T&gt;   required type
	 * @param type  required type
	 * @param value value
	 * @return typed value
	 * @throws IllegalArgumentException if the types don't match
	 */
	public static &lt;T&gt; T requireType(Class&lt;T&gt; type, Object value) {
		try {
<span class="fc" id="L295">			return convert(value, type::cast);</span>
<span class="fc" id="L296">		} catch (ClassCastException e) {</span>
<span class="fc" id="L297">			throw new IllegalArgumentException(&quot;expected &quot; + type, e);</span>
		}
	}

	/**
	 * Require a condition to be true for a value.
	 * 
	 * @param &lt;T&gt;       value type
	 * @param value     value
	 * @param condition condition to verify
	 * @return value
	 * @throws IllegalArgumentException if the types don't match
	 */
	public static &lt;T&gt; T require(T value, Predicate&lt;T&gt; condition) {
<span class="fc" id="L311">		return require(value, condition, () -&gt; null);</span>
	}

	/**
	 * Require a condition to be true for a value if non-null.
	 * 
	 * @param &lt;T&gt;             value type
	 * @param value           value
	 * @param condition       condition to verify
	 * @param messageSupplier provides a message for
	 *                        {@link IllegalArgumentException}
	 * @return value
	 * @throws IllegalArgumentException if the types don't match
	 */
	public static &lt;T&gt; T require(T value, Predicate&lt;T&gt; condition, Supplier&lt;String&gt; messageSupplier) {
<span class="fc bfc" id="L326" title="All 2 branches covered.">		if (value != null //</span>
<span class="fc bfc" id="L327" title="All 2 branches covered.">				&amp;&amp; !condition.test(value))</span>
<span class="fc" id="L328">			throw new IllegalArgumentException(messageSupplier.get());</span>
<span class="fc" id="L329">		return value;</span>
	}

	/**
	 * Passes a value through a conversion function if non-null.
	 * 
	 * @param &lt;S&gt;                source type
	 * @param &lt;T&gt;                result type
	 * @param value              value
	 * @param conversionFunction conversion function
	 * @return converted value
	 */
	public static &lt;S, T&gt; T convert(S value, Function&lt;S, T&gt; conversionFunction) {
<span class="fc bfc" id="L342" title="All 2 branches covered.">		if (value == null)</span>
<span class="fc" id="L343">			return null;</span>
		else
<span class="fc" id="L345">			return conversionFunction.apply(value);</span>
	}

	/**
	 * Perform identity and and null check on two objects, returning a valid value
	 * for {@link Comparable#compareTo(Object)} if any of the checks result in a
	 * conclusive result.
	 * 
	 * @param o1 any object
	 * @param o2 any object
	 * @return 0 if o1 == o2, -1 if o1 is null, 1 if o2 is null; otherwise, return
	 *         null indicating that compareTo should continue to inspect each
	 *         object's specific data.
	 */
	public static Integer compareNullCheck(Object o1, Object o2) {
<span class="fc bfc" id="L360" title="All 2 branches covered.">		if (o1 == o2)</span>
<span class="fc" id="L361">			return 0;</span>
<span class="fc bfc" id="L362" title="All 2 branches covered.">		if (o1 == null)</span>
<span class="fc" id="L363">			return -1;</span>
<span class="fc bfc" id="L364" title="All 2 branches covered.">		if (o2 == null)</span>
<span class="fc" id="L365">			return 1;</span>
<span class="fc" id="L366">		return null;</span>
	}

	/**
	 * Compares two objects with null checks (see
	 * {@link #compareNullCheck(Object, Object)}) and also consistent sort order
	 * based for objects that don't implement {@link Comparable}.
	 * 
	 * @param o1 any object
	 * @param o2 any object
	 * @return Valid {@link Comparator} return value enforcing consistent sort order
	 *         within the same JVM instance.
	 */
	@SuppressWarnings({ &quot;rawtypes&quot;, &quot;unchecked&quot; })
	public static int compareTo(Object o1, Object o2) {
<span class="fc" id="L381">		Integer rv = compareNullCheck(o1, o2);</span>
<span class="fc bfc" id="L382" title="All 2 branches covered.">		if (rv != null)</span>
<span class="fc" id="L383">			return rv;</span>

		Comparable v1;
		Comparable v2;
<span class="fc bfc" id="L387" title="All 4 branches covered.">		if ((o1.getClass() != o2.getClass()) || !(o1 instanceof Comparable)) {</span>
<span class="fc" id="L388">			v1 = (Comparable) Integer.valueOf(o1.hashCode());</span>
<span class="fc" id="L389">			v2 = (Comparable) Integer.valueOf(o2.hashCode());</span>
		} else {
<span class="fc" id="L391">			v1 = (Comparable) o1;</span>
<span class="fc" id="L392">			v2 = (Comparable) o2;</span>
		}

<span class="fc" id="L395">		return v1.compareTo(v2);</span>
	}

	/**
	 * Generates a hash code for a top-level object based on related values (i.e.
	 * field, bean property values, etc).
	 * 
	 * @param oa related values
	 * @return hash code
	 */
	public static int hashCode(Object... oa) {
<span class="fc" id="L406">		return hashCodeSuper(1, oa);</span>
	}

	/**
	 * Generate a hash code for a subclass object based on its parent class' hash
	 * code and related values.
	 * 
	 * @param superHashCode parent class hash code
	 * @param oa            related values
	 * @return hash code
	 */
	public static int hashCodeSuper(int superHashCode, Object... oa) {
<span class="fc" id="L418">		final int prime = 31;</span>
<span class="fc" id="L419">		int result = superHashCode;</span>
<span class="fc bfc" id="L420" title="All 2 branches covered.">		for (Object o : oa) {</span>
			int hash;
<span class="fc bfc" id="L422" title="All 2 branches covered.">			if (o == null)</span>
<span class="fc" id="L423">				hash = 0;</span>
<span class="fc bfc" id="L424" title="All 2 branches covered.">			else if (o instanceof boolean[])</span>
<span class="fc" id="L425">				hash = Arrays.hashCode((boolean[]) o);</span>
<span class="fc bfc" id="L426" title="All 2 branches covered.">			else if (o instanceof byte[])</span>
<span class="fc" id="L427">				hash = Arrays.hashCode((byte[]) o);</span>
<span class="fc bfc" id="L428" title="All 2 branches covered.">			else if (o instanceof char[])</span>
<span class="fc" id="L429">				hash = Arrays.hashCode((char[]) o);</span>
<span class="fc bfc" id="L430" title="All 2 branches covered.">			else if (o instanceof double[])</span>
<span class="fc" id="L431">				hash = Arrays.hashCode((double[]) o);</span>
<span class="fc bfc" id="L432" title="All 2 branches covered.">			else if (o instanceof float[])</span>
<span class="fc" id="L433">				hash = Arrays.hashCode((float[]) o);</span>
<span class="fc bfc" id="L434" title="All 2 branches covered.">			else if (o instanceof int[])</span>
<span class="fc" id="L435">				hash = Arrays.hashCode((int[]) o);</span>
<span class="fc bfc" id="L436" title="All 2 branches covered.">			else if (o instanceof long[])</span>
<span class="fc" id="L437">				hash = Arrays.hashCode((long[]) o);</span>
<span class="fc bfc" id="L438" title="All 2 branches covered.">			else if (o instanceof short[])</span>
<span class="fc" id="L439">				hash = Arrays.hashCode((short[]) o);</span>
<span class="fc bfc" id="L440" title="All 2 branches covered.">			else if (o.getClass().isArray()) {</span>
<span class="fc" id="L441">				int l = Array.getLength(o);</span>
<span class="fc" id="L442">				int h = o.getClass().getComponentType().hashCode();</span>
<span class="fc bfc" id="L443" title="All 2 branches covered.">				for (int i = 0; i &lt; l; i++)</span>
<span class="fc" id="L444">					h = prime * h + hashCode(Array.get(o, i));</span>
<span class="fc" id="L445">				hash = h;</span>
<span class="fc" id="L446">			} else</span>
<span class="fc" id="L447">				hash = o.hashCode();</span>
<span class="fc" id="L448">			result = prime * result + hash;</span>
		}
<span class="fc" id="L450">		return result;</span>
	}

	/**
	 * Determine if two objects are both non-null instances of the same class. This
	 * method is useful as a null and type safety check when implementing equals. If
	 * this returns true, and the type of one of the objects is known, then it is
	 * safe to cast the other object to the same type.
	 * 
	 * @param &lt;T&gt; object type
	 * @param o1  any object
	 * @param o2  any object
	 * @return True if both objects are not null and instances of the same class.
	 */
	public static &lt;T&gt; boolean typeCheck(T o1, T o2) {
<span class="fc" id="L465">		return typeCheck(o1, o2, null);</span>
	}

	/**
	 * Determine if two objects are both instances of a specific class, or
	 * subclasses of that class. This method is useful as a null and type safety
	 * check when implementing equals. If this returns true, then it is safe to cast
	 * the both objects to the type provided.
	 * 
	 * @param &lt;T&gt;  object type
	 * 
	 * @param o1   any object
	 * @param o2   any object
	 * @param type the type to check, may be null for the behavior outlined in
	 *             {@link #typeCheck(Object, Object)}.
	 * @return True if both objects are not null and instances of the given type, or
	 *         are the same class if type is null.
	 */
	public static &lt;T&gt; boolean typeCheck(T o1, T o2, Class&lt;?&gt; type) {
<span class="fc bfc" id="L484" title="All 2 branches covered.">		if (type != null)</span>
<span class="fc bfc" id="L485" title="All 4 branches covered.">			return type.isInstance(o1) &amp;&amp; type.isInstance(o2);</span>
<span class="fc bfc" id="L486" title="All 2 branches covered.">		if (o1 == o2)</span>
<span class="fc" id="L487">			return true;</span>
<span class="fc bfc" id="L488" title="All 4 branches covered.">		if (o1 == null || o2 == null)</span>
<span class="fc" id="L489">			return false;</span>
<span class="fc bfc" id="L490" title="All 2 branches covered.">		return o1.getClass() == o2.getClass();</span>
	}

	/**
	 * Determine if two objects are equal, checking first for identity and null.
	 * 
	 * @param o1 any object
	 * @param o2 any object
	 * @return true if o1 and o2 refer to the same object, are both null, or if
	 *         o1.equals(o2) returns true. Otherwise, return false.
	 */
	public static boolean equals(Object o1, Object o2) {
<span class="fc bfc" id="L502" title="All 2 branches covered.">		if (o1 == o2)</span>
<span class="fc" id="L503">			return true;</span>
<span class="fc bfc" id="L504" title="All 4 branches covered.">		if (o1 == null || o2 == null)</span>
<span class="fc" id="L505">			return false;</span>

<span class="fc bfc" id="L507" title="All 2 branches covered.">		if (o1.getClass() != o2.getClass())</span>
<span class="fc bfc" id="L508" title="All 8 branches covered.">			if (o1 instanceof Set &amp;&amp; o2 instanceof Set &amp;&amp; !(o1 instanceof SortedSet) &amp;&amp; !(o2 instanceof SortedSet)) {</span>
<span class="fc" id="L509">				Set&lt;?&gt; s1 = (Set&lt;?&gt;) o1;</span>
<span class="fc" id="L510">				Set&lt;?&gt; s2 = (Set&lt;?&gt;) o2;</span>
<span class="fc bfc" id="L511" title="All 2 branches covered.">				if (s1.size() != s2.size())</span>
<span class="fc" id="L512">					return false;</span>
<span class="fc" id="L513">				return s1.containsAll(s2);</span>
<span class="fc bfc" id="L514" title="All 4 branches covered.">			} else if (o1 instanceof Iterable &amp;&amp; o2 instanceof Iterable) {</span>
<span class="fc" id="L515">				Iterator&lt;?&gt; i1 = ((Iterable&lt;?&gt;) o1).iterator();</span>
<span class="fc" id="L516">				Iterator&lt;?&gt; i2 = ((Iterable&lt;?&gt;) o2).iterator();</span>
<span class="fc bfc" id="L517" title="All 2 branches covered.">				while (i1.hasNext()) {</span>
<span class="fc bfc" id="L518" title="All 2 branches covered.">					if (!i2.hasNext())</span>
<span class="fc" id="L519">						return false;</span>
<span class="fc bfc" id="L520" title="All 2 branches covered.">					if (!equals(i1.next(), i2.next()))</span>
<span class="fc" id="L521">						return false;</span>
				}
<span class="fc bfc" id="L523" title="All 2 branches covered.">				if (i2.hasNext())</span>
<span class="fc" id="L524">					return false;</span>
<span class="fc" id="L525">				return true;</span>
<span class="fc bfc" id="L526" title="All 4 branches covered.">			} else if ((o1 instanceof Map &amp;&amp; o2 instanceof Map)) {</span>
<span class="fc" id="L527">				Map&lt;?, ?&gt; m1 = (Map&lt;?, ?&gt;) o1;</span>
<span class="fc" id="L528">				Map&lt;?, ?&gt; m2 = (Map&lt;?, ?&gt;) o2;</span>
<span class="fc bfc" id="L529" title="All 2 branches covered.">				if (!equals(m1.keySet(), m2.keySet()))</span>
<span class="fc" id="L530">					return false;</span>
<span class="fc bfc" id="L531" title="All 2 branches covered.">				for (Object k : m1.keySet())</span>
<span class="fc bfc" id="L532" title="All 2 branches covered.">					if (!equals(m1.get(k), m2.get(k)))</span>
<span class="fc" id="L533">						return false;</span>
<span class="fc" id="L534">				return true;</span>
			} else
<span class="fc" id="L536">				return false;</span>

<span class="fc bfc" id="L538" title="All 2 branches covered.">		if (o1 instanceof boolean[])</span>
<span class="fc" id="L539">			return Arrays.equals((boolean[]) o1, (boolean[]) o2);</span>
<span class="fc bfc" id="L540" title="All 2 branches covered.">		if (o1 instanceof byte[])</span>
<span class="fc" id="L541">			return Arrays.equals((byte[]) o1, (byte[]) o2);</span>
<span class="fc bfc" id="L542" title="All 2 branches covered.">		if (o1 instanceof char[])</span>
<span class="fc" id="L543">			return Arrays.equals((char[]) o1, (char[]) o2);</span>
<span class="fc bfc" id="L544" title="All 2 branches covered.">		if (o1 instanceof double[])</span>
<span class="fc" id="L545">			return Arrays.equals((double[]) o1, (double[]) o2);</span>
<span class="fc bfc" id="L546" title="All 2 branches covered.">		if (o1 instanceof float[])</span>
<span class="fc" id="L547">			return Arrays.equals((float[]) o1, (float[]) o2);</span>
<span class="fc bfc" id="L548" title="All 2 branches covered.">		if (o1 instanceof int[])</span>
<span class="fc" id="L549">			return Arrays.equals((int[]) o1, (int[]) o2);</span>
<span class="fc bfc" id="L550" title="All 2 branches covered.">		if (o1 instanceof long[])</span>
<span class="fc" id="L551">			return Arrays.equals((long[]) o1, (long[]) o2);</span>
<span class="fc bfc" id="L552" title="All 2 branches covered.">		if (o1 instanceof short[])</span>
<span class="fc" id="L553">			return Arrays.equals((short[]) o1, (short[]) o2);</span>
<span class="fc bfc" id="L554" title="All 2 branches covered.">		if (o1.getClass().isArray()) {</span>
<span class="fc" id="L555">			int l1 = Array.getLength(o1);</span>
<span class="fc" id="L556">			int l2 = Array.getLength(o2);</span>
<span class="fc bfc" id="L557" title="All 2 branches covered.">			if (l1 != l2)</span>
<span class="fc" id="L558">				return false;</span>
<span class="fc bfc" id="L559" title="All 2 branches covered.">			for (int i = 0; i &lt; l1; i++)</span>
<span class="fc bfc" id="L560" title="All 2 branches covered.">				if (!equals(Array.get(o1, i), Array.get(o2, i)))</span>
<span class="fc" id="L561">					return false;</span>
<span class="fc" id="L562">			return true;</span>
		}

<span class="fc" id="L565">		return o1.equals(o2);</span>
	}

	/**
	 * Waits until a condition is met or a timeout interval expires.
	 * 
	 * @param lock      object to synchronize on
	 * @param condition condition to wait for
	 * @param timeout   timeout interval
	 * 
	 * @throws InterruptedException if the current thread is interrupted while
	 *                              waiting for the condition to be met
	 * @throws TimeoutException     if the timeout interval expires before the
	 *                              condition is met
	 * 
	 */
	public static void waitFor(Object lock, BooleanSupplier condition, Duration timeout)
			throws InterruptedException, TimeoutException {
<span class="fc" id="L583">		waitFor(lock, condition, Instant.now().plus(timeout));</span>
<span class="fc" id="L584">	}</span>

	/**
	 * Waits until a condition is met or a timeout interval expires.
	 * 
	 * @param lock           object to synchronize on
	 * @param condition      condition to wait for
	 * @param timeout        timeout interval
	 * @param timeoutFactory creates a timeout exception to be thrown if the
	 *                       condition is not met before the expiration time
	 * 
	 * @throws InterruptedException if the current thread is interrupted while
	 *                              waiting for the condition to be met
	 * @throws TimeoutException     if the timeout interval expires before the
	 *                              condition is met
	 * 
	 */
	public static void waitFor(Object lock, BooleanSupplier condition, Duration timeout,
			Supplier&lt;TimeoutException&gt; timeoutFactory) throws InterruptedException, TimeoutException {
<span class="fc" id="L603">		waitFor(lock, condition, Instant.now().plus(timeout), timeoutFactory);</span>
<span class="fc" id="L604">	}</span>

	/**
	 * Waits until a condition is met or a timeout interval expires.
	 * 
	 * @param lock      object to synchronize on to receive status change
	 *                  notifications
	 * @param condition condition to wait for
	 * @param expires   timeout interval expiration time
	 * 
	 * @throws InterruptedException if the current thread is interrupted while
	 *                              waiting for the condition to be met
	 * @throws TimeoutException     if the timeout interval expires before the
	 *                              condition is met
	 */
	public static void waitFor(Object lock, BooleanSupplier condition, Instant expires)
			throws InterruptedException, TimeoutException {
<span class="fc" id="L621">		final var init = Instant.now();</span>
<span class="fc" id="L622">		waitFor(lock, condition, expires, () -&gt; {</span>
<span class="fc" id="L623">			StringBuilder sb = new StringBuilder(&quot;Timed out in &quot;);</span>
<span class="fc" id="L624">			sb.append(Duration.between(init, expires));</span>
<span class="fc" id="L625">			return new TimeoutException(sb.toString());</span>
		});
<span class="fc" id="L627">	}</span>

	/**
	 * Waits until a condition is met or a timeout interval expires.
	 * 
	 * @param lock           object to synchronize on to receive status change
	 *                       notifications
	 * @param condition      condition to wait for
	 * @param expires        timeout interval expiration time
	 * @param timeoutFactory creates a timeout exception to be thrown if the
	 *                       condition is not met before the expiration time
	 * 
	 * @throws InterruptedException if the current thread is interrupted while
	 *                              waiting for the condition to be met
	 * @throws TimeoutException     if the timeout interval expires before the
	 *                              condition is met
	 */
	public static void waitFor(Object lock, BooleanSupplier condition, Instant expires,
			Supplier&lt;TimeoutException&gt; timeoutFactory) throws InterruptedException, TimeoutException {
<span class="fc" id="L646">		synchronized (lock) {</span>
<span class="fc bfc" id="L647" title="All 2 branches covered.">			while (!condition.getAsBoolean()) {</span>
<span class="fc" id="L648">				final var now = Instant.now();</span>
<span class="fc bfc" id="L649" title="All 2 branches covered.">				if (now.isBefore(expires)) {</span>
<span class="fc" id="L650">					final var waitFor = Duration.between(now, expires);</span>
<span class="fc" id="L651">					lock.wait(waitFor.toMillis(), waitFor.toNanosPart() % 1_000_000);</span>
<span class="fc" id="L652">				} else</span>
<span class="fc" id="L653">					throw timeoutFactory.get();</span>
<span class="fc" id="L654">			}</span>
<span class="fc" id="L655">		}</span>
<span class="fc" id="L656">	}</span>

	private IuObject() {
	};

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.10.202304240956</span></div></body></html>