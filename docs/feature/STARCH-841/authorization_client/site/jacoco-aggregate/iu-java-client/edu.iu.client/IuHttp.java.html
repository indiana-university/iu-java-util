<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>IuHttp.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">IU Java Utilities API Reference</a> &gt; <a href="../index.html" class="el_bundle">iu-java-client</a> &gt; <a href="index.source.html" class="el_package">edu.iu.client</a> &gt; <span class="el_source">IuHttp.java</span></div><h1>IuHttp.java</h1><pre class="source lang-java linenums">/*
 * Copyright Â© 2024 Indiana University
 * All rights reserved.
 *
 * BSD 3-Clause License
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 
 * - Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 * 
 * - Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 * 
 * - Neither the name of the copyright holder nor the names of its
 *   contributors may be used to endorse or promote products derived from
 *   this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package edu.iu.client;

import java.io.InputStream;
import java.net.URI;
import java.net.http.HttpClient;
import java.net.http.HttpRequest;
import java.net.http.HttpResponse;
import java.net.http.HttpResponse.BodyHandlers;
import java.util.Collection;
import java.util.function.BiPredicate;
import java.util.function.Function;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.stream.Collectors;
import java.util.stream.Stream;

import edu.iu.IuException;
import edu.iu.IuObject;
import edu.iu.IuRuntimeEnvironment;
import edu.iu.IuWebUtils;
import edu.iu.UnsafeConsumer;
import jakarta.json.JsonObject;
import jakarta.json.JsonValue;

/**
 * Provides common base-level whitelisting, logging, and exception handling
 * utilities for {@link HttpRequest} and {@link HttpResponse}.
 * 
 * &lt;p&gt;
 * All requests are handled via a cached {@link HttpClient} instance configured
 * with {@link HttpClient#newHttpClient default settings}.
 * &lt;/p&gt;
 */
public class IuHttp {

<span class="fc" id="L67">	private static final Logger LOG = Logger.getLogger(IuHttp.class.getName());</span>

	static {
<span class="fc" id="L70">		IuObject.assertNotOpen(IuHttp.class);</span>
	}

<span class="fc" id="L73">	private static final Collection&lt;URI&gt; ALLOWED_URI = IuRuntimeEnvironment.env(&quot;iu.http.allowedUri&quot;,</span>
<span class="fc" id="L74">			a -&gt; Stream.of(a.split(&quot;,&quot;)).map(URI::create).collect(Collectors.toUnmodifiableList()));</span>

<span class="fc" id="L76">	private static final HttpClient HTTP = HttpClient.newHttpClient();</span>

	/**
	 * Validates a 200 OK response.
	 */
<span class="fc" id="L81">	public static final HttpResponseValidator OK = expectStatus(200);</span>

	/**
	 * Validates a 204 NO CONTENT response and returns null.
	 */
<span class="fc" id="L86">	public static final HttpResponseHandler&lt;?&gt; NO_CONTENT = validate(a -&gt; null, IuHttp.expectStatus(204));</span>

	/**
	 * Validates 200 OK then parses the response as a JSON object.
	 */
<span class="fc" id="L91">	public static final HttpResponseHandler&lt;JsonValue&gt; READ_JSON = validate(IuJson::parse, IuHttp.OK);</span>

	/**
	 * Validates 200 OK then parses the response as a JSON object.
	 */
<span class="fc" id="L96">	public static final HttpResponseHandler&lt;JsonObject&gt; READ_JSON_OBJECT = validate(a -&gt; IuJson.parse(a).asJsonObject(),</span>
			IuHttp.OK);

	/**
	 * Creates an HTTP response handler.
	 * 
	 * @param &lt;T&gt;                value type
	 * @param bodyDeserializer   function that deserializes the response body
	 * @param responseValidators one or more verification checks to apply to the
	 *                           response before passing to the handler
	 * @return decorated response handler
	 */
	public static &lt;T&gt; HttpResponseHandler&lt;T&gt; validate(Function&lt;InputStream, T&gt; bodyDeserializer,
			HttpResponseValidator... responseValidators) {
<span class="fc" id="L110">		return response -&gt; {</span>
<span class="fc bfc" id="L111" title="All 2 branches covered.">			for (final var responseValidator : responseValidators)</span>
<span class="fc" id="L112">				responseValidator.accept(response);</span>
<span class="fc" id="L113">			return bodyDeserializer.apply(response.body());</span>
		};
	}

	/**
	 * Gets a {@link HttpResponseValidator} that verifies an expected status code.
	 * 
	 * @param expectedStatusCode status code
	 * @return {@link HttpResponseValidator}
	 */
	public static HttpResponseValidator expectStatus(int expectedStatusCode) {
<span class="fc" id="L124">		return response -&gt; {</span>
<span class="fc" id="L125">			final var statusCode = response.statusCode();</span>
<span class="fc bfc" id="L126" title="All 2 branches covered.">			if (statusCode != expectedStatusCode)</span>
<span class="fc" id="L127">				throw new HttpException(response, &quot;Expected &quot; + IuWebUtils.describeStatus(expectedStatusCode)</span>
<span class="fc" id="L128">						+ &quot;, found &quot; + IuWebUtils.describeStatus(statusCode));</span>
<span class="fc" id="L129">		};</span>
	}

	/**
	 * Gets a {@link HttpResponseValidator} that tests response headers.
	 * 
	 * @param headerValidator test response headers
	 * @return {@link HttpResponseValidator}
	 */
	public static HttpResponseValidator checkHeaders(BiPredicate&lt;String, String&gt; headerValidator) {
<span class="fc" id="L139">		return response -&gt; {</span>
<span class="fc bfc" id="L140" title="All 2 branches covered.">			for (final var headerEntry : response.headers().map().entrySet()) {</span>
<span class="fc" id="L141">				final var name = headerEntry.getKey();</span>
<span class="fc bfc" id="L142" title="All 2 branches covered.">				for (final var value : headerEntry.getValue())</span>
<span class="fc bfc" id="L143" title="All 2 branches covered.">					if (!headerValidator.test(name, value))</span>
<span class="fc" id="L144">						throw new HttpException(response, &quot;Invalid header &quot; + name);</span>
<span class="fc" id="L145">			}</span>
<span class="fc" id="L146">		};</span>
	}

	/**
	 * Sends an HTTP GET request to a public URI.
	 * 
	 * @param uri public URI
	 * 
	 * @return {@link HttpResponse}
	 * @throws HttpException If the response has error status code.
	 */
	public static HttpResponse&lt;InputStream&gt; get(URI uri) throws HttpException {
<span class="fc" id="L158">		return send(uri, null);</span>
	}

	/**
	 * Sends an HTTP GET request to a public URI.
	 * 
	 * @param &lt;T&gt;             response type
	 * 
	 * @param uri             public URI
	 * @param responseHandler function that converts HTTP response data to the
	 *                        response type.
	 * 
	 * @return response value
	 * @throws HttpException If the response has error status code.
	 */
	public static &lt;T&gt; T get(URI uri, HttpResponseHandler&lt;T&gt; responseHandler) throws HttpException {
<span class="fc" id="L174">		return responseHandler.apply(send(uri, null));</span>
	}

	/**
	 * Sends a synchronous HTTP request.
	 * 
	 * @param uri             request URI
	 * @param requestConsumer receives the {@link HttpRequest.Builder} before
	 *                        sending to the server.
	 * 
	 * @return {@link HttpResponse}
	 * @throws HttpException If the response has error status code.
	 */
	public static HttpResponse&lt;InputStream&gt; send(URI uri, UnsafeConsumer&lt;HttpRequest.Builder&gt; requestConsumer)
			throws HttpException {
<span class="fc" id="L189">		return send(HttpException.class, uri, requestConsumer);</span>
	}

	/**
	 * Sends a synchronous HTTP request.
	 * 
	 * @param &lt;E&gt;             additional exception type
	 * 
	 * @param uri             request URI
	 * @param requestConsumer receives the {@link HttpRequest.Builder} before
	 *                        sending to the server.
	 * @param exceptionClass  additional checked exception type to allow thrown from
	 *                        requestConsumer
	 * 
	 * @return {@link HttpResponse}
	 * @throws HttpException If the response has error status code.
	 * @throws E             from requestConsumer
	 */
	public static &lt;E extends Exception&gt; HttpResponse&lt;InputStream&gt; send(Class&lt;E&gt; exceptionClass, URI uri,
			UnsafeConsumer&lt;HttpRequest.Builder&gt; requestConsumer) throws HttpException, E {
<span class="fc bfc" id="L209" title="All 2 branches covered.">		if (!&quot;https&quot;.equals(uri.getScheme()) //</span>
<span class="fc bfc" id="L210" title="All 2 branches covered.">				&amp;&amp; !&quot;localhost&quot;.equals(uri.getHost()))</span>
<span class="fc" id="L211">			throw new IllegalArgumentException(&quot;insecure URI&quot;);</span>

<span class="fc bfc" id="L213" title="All 2 branches covered.">		if (!ALLOWED_URI.stream().anyMatch(allowedUri -&gt; IuWebUtils.isRootOf(allowedUri, uri)))</span>
<span class="fc" id="L214">			throw new IllegalArgumentException(&quot;URI not allowed, must be relative to &quot; + ALLOWED_URI);</span>

<span class="fc" id="L216">		return IuException.checked(HttpException.class, exceptionClass, () -&gt; {</span>
<span class="fc" id="L217">			final var requestBuilder = HttpRequest.newBuilder(uri);</span>
<span class="fc bfc" id="L218" title="All 2 branches covered.">			if (requestConsumer != null)</span>
<span class="fc" id="L219">				requestConsumer.accept(requestBuilder);</span>
<span class="fc" id="L220">			final var request = requestBuilder.build();</span>

<span class="fc" id="L222">			final var sb = new StringBuilder();</span>
<span class="fc" id="L223">			sb.append(request.method());</span>
<span class="fc" id="L224">			sb.append(' ').append(request.uri());</span>
<span class="fc" id="L225">			final var requestHeaders = request.headers();</span>
<span class="fc" id="L226">			final var requestHeaderMap = requestHeaders.map();</span>
<span class="fc bfc" id="L227" title="All 2 branches covered.">			if (!requestHeaderMap.isEmpty())</span>
				// TODO: apply security filter
<span class="fc" id="L229">				sb.append(' ').append(requestHeaderMap.keySet());</span>

			final HttpResponse&lt;InputStream&gt; response;
			try {
<span class="fc" id="L233">				response = HTTP.send(request, BodyHandlers.ofInputStream());</span>
<span class="fc" id="L234">			} catch (Throwable e) {</span>
<span class="fc" id="L235">				final var m = &quot;HTTP connection failed &quot; + sb;</span>
<span class="fc" id="L236">				LOG.log(Level.INFO, e, () -&gt; m);</span>
<span class="fc" id="L237">				throw new IllegalStateException(m, e);</span>
<span class="fc" id="L238">			}</span>

<span class="fc" id="L240">			final var status = response.statusCode();</span>
<span class="fc" id="L241">			sb.append(&quot; &quot;).append(IuWebUtils.describeStatus(status));</span>

<span class="fc" id="L243">			final var responseHeaders = response.headers();</span>
<span class="fc" id="L244">			final var responseHeaderMap = responseHeaders.map();</span>
<span class="fc bfc" id="L245" title="All 2 branches covered.">			if (!responseHeaderMap.isEmpty())</span>
				// TODO: apply security filter
<span class="fc" id="L247">				sb.append(' ').append(responseHeaderMap.keySet());</span>

<span class="fc bfc" id="L249" title="All 2 branches covered.">			if (response.statusCode() &gt;= 400) {</span>
<span class="fc" id="L250">				final var m = sb.toString();</span>
<span class="fc" id="L251">				final var e = new HttpException(response, m);</span>
<span class="fc" id="L252">				LOG.log(Level.INFO, m, e);</span>
<span class="fc" id="L253">				throw e;</span>
			} else
<span class="fc" id="L255">				LOG.fine(sb::toString);</span>

<span class="fc" id="L257">			return response;</span>
		});
	}

	/**
	 * Sends a synchronous HTTP request expecting 200 OK and accepting all response
	 * headers.
	 * 
	 * @param &lt;T&gt;             response type
	 * 
	 * @param uri             request URI
	 * @param requestConsumer receives the {@link HttpRequest.Builder} before
	 *                        sending to the server.
	 * @param responseHandler function that converts HTTP response data to the
	 *                        response type.
	 * 
	 * @return response value
	 * @throws HttpException If the response has error status code.
	 */
	public static &lt;T&gt; T send(URI uri, UnsafeConsumer&lt;HttpRequest.Builder&gt; requestConsumer,
			HttpResponseHandler&lt;T&gt; responseHandler) throws HttpException {
<span class="fc" id="L278">		return send(HttpException.class, uri, requestConsumer, responseHandler);</span>
	}

	/**
	 * Sends a synchronous HTTP request expecting 200 OK and accepting all response
	 * headers.
	 * 
	 * @param &lt;T&gt;             response type
	 * @param &lt;E&gt;             additional exception type
	 * 
	 * @param uri             request URI
	 * @param requestConsumer receives the {@link HttpRequest.Builder} before
	 *                        sending to the server.
	 * @param exceptionClass  additional checked exception class to allow from
	 *                        requestConsumer
	 * @param responseHandler function that converts HTTP response data to the
	 *                        response type.
	 * 
	 * @return response value
	 * @throws HttpException If the response has error status code.
	 * @throws E             from requestConsumer
	 */
	public static &lt;T, E extends Exception&gt; T send(Class&lt;E&gt; exceptionClass, URI uri,
			UnsafeConsumer&lt;HttpRequest.Builder&gt; requestConsumer, HttpResponseHandler&lt;T&gt; responseHandler)
			throws HttpException, E {
<span class="fc" id="L303">		return responseHandler.apply(send(exceptionClass, uri, requestConsumer));</span>
	}

	private IuHttp() {
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.10.202304240956</span></div></body></html>