<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>IuWebUtils.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">IU Base Utilities Module</a> &gt; <a href="index.source.html" class="el_package">edu.iu</a> &gt; <span class="el_source">IuWebUtils.java</span></div><h1>IuWebUtils.java</h1><pre class="source lang-java linenums">package edu.iu;

import java.net.InetAddress;
import java.net.URLDecoder;
import java.net.URLEncoder;
import java.time.Duration;
import java.util.ArrayDeque;
import java.util.Collections;
import java.util.LinkedHashMap;
import java.util.Map;
import java.util.Queue;

/**
 * Provides useful utility methods for low-level web client and server
 * interactions.
 */
public final class IuWebUtils {

<span class="fc" id="L19">	private static final Map&lt;String, InetAddress&gt; IP_CACHE = new IuCacheMap&lt;&gt;(Duration.ofSeconds(5L));</span>

	/**
	 * Parses a query string.
	 * 
	 * @param queryString query string
	 * @return {@link Map}
	 */
	public static Map&lt;String, ? extends Iterable&lt;String&gt;&gt; parseQueryString(String queryString) {
<span class="fc" id="L28">		final Map&lt;String, Queue&lt;String&gt;&gt; parsedParameterValues = new LinkedHashMap&lt;&gt;();</span>

<span class="fc bfc" id="L30" title="All 2 branches covered.">		var startOfName = queryString.startsWith(&quot;?&quot;) ? 1 : 0;</span>
<span class="fc bfc" id="L31" title="All 2 branches covered.">		if (startOfName == queryString.length())</span>
<span class="fc" id="L32">			return parsedParameterValues;</span>

<span class="fc" id="L34">		var endOfName = queryString.indexOf('=', startOfName);</span>
<span class="fc" id="L35">		var endOfValue = queryString.indexOf('&amp;', startOfName);</span>

		int startOfValue;
<span class="fc bfc" id="L38" title="All 2 branches covered.">		if (endOfValue == -1)</span>
<span class="fc" id="L39">			endOfValue = queryString.length();</span>

<span class="fc bfc" id="L41" title="All 4 branches covered.">		if (endOfName == -1 //</span>
				|| endOfName &gt; endOfValue)
<span class="fc" id="L43">			endOfName = startOfValue = endOfValue;</span>
		else
<span class="fc" id="L45">			startOfValue = endOfName + 1;</span>

		while (true) {
<span class="fc" id="L48">			final var name = queryString.substring(startOfName, endOfName);</span>

<span class="fc" id="L50">			var values = parsedParameterValues.get(name);</span>
<span class="fc bfc" id="L51" title="All 2 branches covered.">			if (values == null)</span>
<span class="fc" id="L52">				parsedParameterValues.put(name, values = new ArrayDeque&lt;&gt;());</span>

<span class="fc bfc" id="L54" title="All 2 branches covered.">			if (endOfValue == queryString.length()) {</span>
<span class="fc" id="L55">				final var value = queryString.substring(startOfValue);</span>
<span class="fc" id="L56">				values.offer(IuException.unchecked(() -&gt; URLDecoder.decode(value, &quot;UTF-8&quot;)));</span>
<span class="fc" id="L57">				endOfName = -1;</span>
<span class="fc" id="L58">				break;</span>
			}

<span class="fc" id="L61">			final var value = queryString.substring(startOfValue, endOfValue);</span>
<span class="fc" id="L62">			values.offer(IuException.unchecked(() -&gt; URLDecoder.decode(value, &quot;UTF-8&quot;)));</span>

<span class="fc" id="L64">			startOfName = endOfValue + 1;</span>
<span class="fc" id="L65">			endOfName = queryString.indexOf('=', startOfName);</span>
<span class="fc" id="L66">			endOfValue = queryString.indexOf('&amp;', startOfName);</span>
<span class="fc bfc" id="L67" title="All 2 branches covered.">			if (endOfValue == -1)</span>
<span class="fc" id="L68">				endOfValue = queryString.length();</span>

<span class="fc bfc" id="L70" title="All 4 branches covered.">			if (endOfName == -1 //</span>
					|| endOfName &gt; endOfValue)
<span class="fc" id="L72">				endOfName = startOfValue = endOfValue;</span>
			else
<span class="fc" id="L74">				startOfValue = endOfName + 1;</span>
<span class="fc" id="L75">		}</span>

<span class="fc" id="L77">		return parsedParameterValues;</span>
	}

	/**
	 * Creates a query string from a map.
	 * 
	 * @param params {@link Map} of parameter values
	 * @return query string
	 */
	public static String createQueryString(Map&lt;String, ? extends Iterable&lt;String&gt;&gt; params) {
<span class="fc" id="L87">		final var queryString = new StringBuilder();</span>
<span class="fc bfc" id="L88" title="All 2 branches covered.">		for (final var paramEntry : params.entrySet())</span>
<span class="fc bfc" id="L89" title="All 2 branches covered.">			for (final var paramValue : paramEntry.getValue()) {</span>
<span class="fc bfc" id="L90" title="All 2 branches covered.">				if (queryString.length() &gt; 0)</span>
<span class="fc" id="L91">					queryString.append('&amp;');</span>
<span class="fc" id="L92">				queryString.append(IuException.unchecked(() -&gt; URLEncoder.encode(paramEntry.getKey(), &quot;UTF-8&quot;)));</span>
<span class="fc" id="L93">				queryString.append(&quot;=&quot;).append(IuException.unchecked(() -&gt; URLEncoder.encode(paramValue, &quot;UTF-8&quot;)));</span>
<span class="fc" id="L94">			}</span>
<span class="fc" id="L95">		return queryString.toString();</span>
	}

	/**
	 * Parses a header value composed of key/value pairs separated by semicolon ';'.
	 * 
	 * @param headerValue header value
	 * @return {@link Map} of header elements
	 */
	public static Map&lt;String, String&gt; parseHeader(String headerValue) {
<span class="fc" id="L105">		int semicolon = headerValue.indexOf(';');</span>
<span class="fc bfc" id="L106" title="All 2 branches covered.">		if (semicolon == -1)</span>
<span class="fc" id="L107">			return Collections.singletonMap(&quot;&quot;, headerValue);</span>

<span class="fc" id="L109">		final Map&lt;String, String&gt; parsedHeader = new LinkedHashMap&lt;&gt;();</span>
<span class="fc" id="L110">		parsedHeader.put(&quot;&quot;, headerValue.substring(0, semicolon));</span>

<span class="fc bfc" id="L112" title="All 2 branches covered.">		while (semicolon &lt; headerValue.length()) {</span>
<span class="fc" id="L113">			final var start = semicolon + 1;</span>
<span class="fc" id="L114">			final var eq = headerValue.indexOf('=', start + 1);</span>

<span class="fc" id="L116">			semicolon = headerValue.indexOf(';', start + 1);</span>
<span class="fc bfc" id="L117" title="All 2 branches covered.">			if (semicolon == -1)</span>
<span class="fc" id="L118">				semicolon = headerValue.length();</span>

<span class="fc bfc" id="L120" title="All 4 branches covered.">			if (eq == -1 || eq &gt; semicolon)</span>
<span class="fc" id="L121">				parsedHeader.put(headerValue.substring(start, semicolon).trim(), &quot;&quot;);</span>
			else {
<span class="fc" id="L123">				final var elementName = headerValue.substring(start, eq).trim();</span>
<span class="fc" id="L124">				final String elementValue = headerValue.substring(eq + 1, semicolon).trim();</span>
<span class="fc" id="L125">				parsedHeader.put(elementName, elementValue);</span>
			}
<span class="fc" id="L127">		}</span>

<span class="fc" id="L129">		return parsedHeader;</span>
	}

	/**
	 * Validates and normalizes case for an HTTP header name.
	 * 
	 * &lt;p&gt;
	 * Follows each hyphen '-' character with an upper case character; converts
	 * other characters {@link Character#toLowerCase(char) to lower case}
	 * &lt;/p&gt;
	 * 
	 * @param headerName HTTP header name
	 * @return {@link String}
	 * @throws IllegalArgumentException If the name contains non-alphabetic
	 *                                  characters other than hyphen '-', or if the
	 *                                  name begins or ends with a hyphen.
	 */
	public static String normalizeHeaderName(String headerName) throws IllegalArgumentException {
<span class="fc bfc" id="L147" title="All 2 branches covered.">		if (!headerName.matches(&quot;\\p{Alpha}+(\\-\\p{Alpha}+?)*&quot;))</span>
<span class="fc" id="L148">			throw new IllegalArgumentException(&quot;Invalid header name &quot; + headerName);</span>

<span class="fc" id="L150">		final var sb = new StringBuilder(headerName.toLowerCase());</span>
<span class="fc" id="L151">		sb.setCharAt(0, Character.toUpperCase(sb.charAt(0)));</span>
<span class="fc" id="L152">		for (int i = headerName.indexOf('-') + 1; //</span>
<span class="fc bfc" id="L153" title="All 2 branches covered.">				i != 0; //</span>
<span class="fc" id="L154">				i = headerName.indexOf('-', i + 1) + 1)</span>
<span class="fc" id="L155">			sb.setCharAt(i, Character.toUpperCase(sb.charAt(i)));</span>

<span class="fc" id="L157">		return sb.toString();</span>
	}

	/**
	 * Describes an HTTP status code.
	 * 
	 * @param statusCode HTTP status code
	 * @return {@link String}
	 */
	public static String describeStatus(int statusCode) {
<span class="fc bfc" id="L167" title="All 41 branches covered.">		switch (statusCode) {</span>
		case 100:
<span class="fc" id="L169">			return statusCode + &quot; CONTINUE&quot;;</span>
		case 101:
<span class="fc" id="L171">			return statusCode + &quot; SWITCHING PROTOCOLS&quot;;</span>
		case 200:
<span class="fc" id="L173">			return statusCode + &quot; OK&quot;;</span>
		case 201:
<span class="fc" id="L175">			return statusCode + &quot; CREATED&quot;;</span>
		case 202:
<span class="fc" id="L177">			return statusCode + &quot; ACCEPTED&quot;;</span>
		case 203:
<span class="fc" id="L179">			return statusCode + &quot; NON AUTHORITATIVE INFORMATION&quot;;</span>
		case 204:
<span class="fc" id="L181">			return statusCode + &quot; NO CONTENT&quot;;</span>
		case 205:
<span class="fc" id="L183">			return statusCode + &quot; RESET CONTENT&quot;;</span>
		case 206:
<span class="fc" id="L185">			return statusCode + &quot; PARTIAL CONTENT&quot;;</span>
		case 300:
<span class="fc" id="L187">			return statusCode + &quot; MULTIPLE CHOICES&quot;;</span>
		case 301:
<span class="fc" id="L189">			return statusCode + &quot; MOVED PERMANENTLY&quot;;</span>
		case 302:
<span class="fc" id="L191">			return statusCode + &quot; FOUND&quot;;</span>
		case 303:
<span class="fc" id="L193">			return statusCode + &quot; SEE OTHER&quot;;</span>
		case 304:
<span class="fc" id="L195">			return statusCode + &quot; NOT MODIFIED&quot;;</span>
		case 305:
<span class="fc" id="L197">			return statusCode + &quot; USE PROXY&quot;;</span>
		case 307:
<span class="fc" id="L199">			return statusCode + &quot; TEMPORARY REDIRECT&quot;;</span>
		case 400:
<span class="fc" id="L201">			return statusCode + &quot; BAD REQUEST&quot;;</span>
		case 401:
<span class="fc" id="L203">			return statusCode + &quot; UNAUTHORIZED&quot;;</span>
		case 402:
<span class="fc" id="L205">			return statusCode + &quot; PAYMENT REQUIRED&quot;;</span>
		case 403:
<span class="fc" id="L207">			return statusCode + &quot; FORBIDDEN&quot;;</span>
		case 404:
<span class="fc" id="L209">			return statusCode + &quot; NOT FOUND&quot;;</span>
		case 405:
<span class="fc" id="L211">			return statusCode + &quot; METHOD NOT ALLOWED&quot;;</span>
		case 406:
<span class="fc" id="L213">			return statusCode + &quot; NOT ACCEPTABLE&quot;;</span>
		case 407:
<span class="fc" id="L215">			return statusCode + &quot; PROXY AUTHENTICATION REQUIRED&quot;;</span>
		case 408:
<span class="fc" id="L217">			return statusCode + &quot; REQUEST TIMEOUT&quot;;</span>
		case 409:
<span class="fc" id="L219">			return statusCode + &quot; CONFLICT&quot;;</span>
		case 410:
<span class="fc" id="L221">			return statusCode + &quot; GONE&quot;;</span>
		case 411:
<span class="fc" id="L223">			return statusCode + &quot; LENGTH REQUIRED&quot;;</span>
		case 412:
<span class="fc" id="L225">			return statusCode + &quot; PRECONDITION FAILED&quot;;</span>
		case 413:
<span class="fc" id="L227">			return statusCode + &quot; REQUEST ENTITY TOO LARGE&quot;;</span>
		case 414:
<span class="fc" id="L229">			return statusCode + &quot; REQUEST URI TOO LONG&quot;;</span>
		case 415:
<span class="fc" id="L231">			return statusCode + &quot; UNSUPPORTED MEDIA TYPE&quot;;</span>
		case 416:
<span class="fc" id="L233">			return statusCode + &quot; REQUESTED RANGE NOT SATISFIABLE&quot;;</span>
		case 417:
<span class="fc" id="L235">			return statusCode + &quot; EXPECTATION FAILED&quot;;</span>
		case 500:
<span class="fc" id="L237">			return statusCode + &quot; INTERNAL SERVER ERROR&quot;;</span>
		case 501:
<span class="fc" id="L239">			return statusCode + &quot; NOT IMPLEMENTED&quot;;</span>
		case 502:
<span class="fc" id="L241">			return statusCode + &quot; BAD GATEWAY&quot;;</span>
		case 503:
<span class="fc" id="L243">			return statusCode + &quot; SERVICE UNAVAILABLE&quot;;</span>
		case 504:
<span class="fc" id="L245">			return statusCode + &quot; GATEWAY TIMEOUT&quot;;</span>
		case 505:
<span class="fc" id="L247">			return statusCode + &quot; HTTP VERSION NOT SUPPORTED&quot;;</span>
		default:
<span class="fc" id="L249">			return statusCode + &quot; UNKNOWN&quot;;</span>
		}
	}

	/**
	 * Resolves and caches the {@link InetAddress IP address} for a host name.
	 * 
	 * @param hostname host name
	 * @return resolved {@link InetAddress}
	 */
	public static InetAddress getInetAddress(String hostname) {
<span class="fc" id="L260">		var addr = IP_CACHE.get(hostname);</span>
<span class="fc bfc" id="L261" title="All 2 branches covered.">		if (addr != null)</span>
<span class="fc" id="L262">			return addr;</span>

<span class="fc" id="L264">		addr = IuException.unchecked(() -&gt; InetAddress.getByName(hostname));</span>
<span class="fc" id="L265">		IP_CACHE.put(hostname, addr);</span>

<span class="fc" id="L267">		return addr;</span>
	}

	/**
	 * Determines whether or not an IP address is included in a CIDR range.
	 * 
	 * @param address address
	 * @param range   CIDR range
	 * @return true if the range includes the address; else false
	 */
	public static boolean isInetAddressInRange(InetAddress address, String range) {
<span class="fc" id="L278">		byte[] hostaddr = address.getAddress();</span>
<span class="fc" id="L279">		int lastSlash = range.lastIndexOf('/');</span>

		byte[] rangeaddr;
		int maskbits;
<span class="fc bfc" id="L283" title="All 2 branches covered.">		if (lastSlash == -1) {</span>
<span class="fc" id="L284">			rangeaddr = getInetAddress(range).getAddress();</span>
<span class="fc" id="L285">			maskbits = rangeaddr.length * 8;</span>
		} else {
<span class="fc" id="L287">			rangeaddr = getInetAddress(range.substring(0, lastSlash)).getAddress();</span>
<span class="fc" id="L288">			maskbits = Integer.parseInt(range.substring(lastSlash + 1));</span>
		}

<span class="fc bfc" id="L291" title="All 2 branches covered.">		for (int i = 0; i &lt; rangeaddr.length; i++) {</span>
<span class="fc bfc" id="L292" title="All 2 branches covered.">			if (maskbits &gt;= 8) {</span>
<span class="fc" id="L293">				maskbits -= 8;</span>
<span class="fc bfc" id="L294" title="All 2 branches covered.">				if (hostaddr[i] != rangeaddr[i])</span>
<span class="fc" id="L295">					return false;</span>
<span class="fc bfc" id="L296" title="All 2 branches covered.">			} else if (maskbits &gt; 0) {</span>
<span class="fc" id="L297">				int mask = ~((1 &lt;&lt; (8 - maskbits)) - 1);</span>
<span class="fc bfc" id="L298" title="All 2 branches covered.">				return (hostaddr[i] &amp; mask) == (rangeaddr[i] &amp; mask);</span>
			} else
				break;
		}

<span class="fc" id="L303">		return true;</span>
	}

	private IuWebUtils() {
	}

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.10.202304240956</span></div></body></html>