<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>IuWebUtils.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">IU Java Utilities API Reference</a> &gt; <a href="../index.html" class="el_bundle">iu-java-base</a> &gt; <a href="index.source.html" class="el_package">edu.iu</a> &gt; <span class="el_source">IuWebUtils.java</span></div><h1>IuWebUtils.java</h1><pre class="source lang-java linenums">/*
 * Copyright Â© 2024 Indiana University
 * All rights reserved.
 *
 * BSD 3-Clause License
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 
 * - Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 * 
 * - Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 * 
 * - Neither the name of the copyright holder nor the names of its
 *   contributors may be used to endorse or promote products derived from
 *   this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package edu.iu;

import java.net.InetAddress;
import java.net.URI;
import java.net.URLDecoder;
import java.net.URLEncoder;
import java.time.Duration;
import java.util.ArrayDeque;
import java.util.Collections;
import java.util.LinkedHashMap;
import java.util.Map;
import java.util.Queue;

/**
 * Provides useful utility methods for low-level web client and server
 * interactions.
 */
public final class IuWebUtils {

<span class="fc" id="L51">	private static final Map&lt;String, InetAddress&gt; IP_CACHE = new IuCacheMap&lt;&gt;(Duration.ofSeconds(5L));</span>

	/**
	 * Determines if a root {@link URI} encompasses a resource {@link URI}.
	 * 
	 * @param rootUri     root {@link URI}
	 * @param resourceUri resource {@link URI}
	 * @return {@link URI}
	 */
	public static boolean isRootOf(URI rootUri, URI resourceUri) {
<span class="fc bfc" id="L61" title="All 2 branches covered.">		if (rootUri.equals(resourceUri))</span>
<span class="fc" id="L62">			return true;</span>

<span class="fc bfc" id="L64" title="All 2 branches covered.">		if (!resourceUri.isAbsolute() //</span>
<span class="fc bfc" id="L65" title="All 2 branches covered.">				|| resourceUri.isOpaque() //</span>
<span class="fc bfc" id="L66" title="All 2 branches covered.">				|| !IuObject.equals(rootUri.getScheme(), resourceUri.getScheme()) //</span>
<span class="fc bfc" id="L67" title="All 2 branches covered.">				|| !IuObject.equals(rootUri.getAuthority(), resourceUri.getAuthority()))</span>
<span class="fc" id="L68">			return false;</span>

<span class="fc" id="L70">		final var root = rootUri.getPath();</span>
<span class="fc bfc" id="L71" title="All 2 branches covered.">		if (root.isEmpty())</span>
<span class="fc" id="L72">			return true;</span>
		
<span class="fc" id="L74">		final var resource = resourceUri.getPath();</span>
<span class="fc" id="L75">		final var l = root.length();</span>
<span class="fc bfc" id="L76" title="All 2 branches covered.">		return resource.startsWith(root) //</span>
<span class="fc bfc" id="L77" title="All 2 branches covered.">				&amp;&amp; (root.charAt(l - 1) == '/' //</span>
<span class="fc bfc" id="L78" title="All 2 branches covered.">						|| resource.charAt(l) == '/');</span>
	}

	/**
	 * Parses a query string.
	 * 
	 * @param queryString query string
	 * @return {@link Map}
	 */
	public static Map&lt;String, ? extends Iterable&lt;String&gt;&gt; parseQueryString(String queryString) {
<span class="fc" id="L88">		final Map&lt;String, Queue&lt;String&gt;&gt; parsedParameterValues = new LinkedHashMap&lt;&gt;();</span>

<span class="fc bfc" id="L90" title="All 2 branches covered.">		var startOfName = queryString.startsWith(&quot;?&quot;) ? 1 : 0;</span>
<span class="fc bfc" id="L91" title="All 2 branches covered.">		if (startOfName == queryString.length())</span>
<span class="fc" id="L92">			return parsedParameterValues;</span>

<span class="fc" id="L94">		var endOfName = queryString.indexOf('=', startOfName);</span>
<span class="fc" id="L95">		var endOfValue = queryString.indexOf('&amp;', startOfName);</span>

		int startOfValue;
<span class="fc bfc" id="L98" title="All 2 branches covered.">		if (endOfValue == -1)</span>
<span class="fc" id="L99">			endOfValue = queryString.length();</span>

<span class="fc bfc" id="L101" title="All 4 branches covered.">		if (endOfName == -1 //</span>
				|| endOfName &gt; endOfValue)
<span class="fc" id="L103">			endOfName = startOfValue = endOfValue;</span>
		else
<span class="fc" id="L105">			startOfValue = endOfName + 1;</span>

		while (true) {
<span class="fc" id="L108">			final var name = queryString.substring(startOfName, endOfName);</span>

<span class="fc" id="L110">			var values = parsedParameterValues.get(name);</span>
<span class="fc bfc" id="L111" title="All 2 branches covered.">			if (values == null)</span>
<span class="fc" id="L112">				parsedParameterValues.put(name, values = new ArrayDeque&lt;&gt;());</span>

<span class="fc bfc" id="L114" title="All 2 branches covered.">			if (endOfValue == queryString.length()) {</span>
<span class="fc" id="L115">				final var value = queryString.substring(startOfValue);</span>
<span class="fc" id="L116">				values.offer(IuException.unchecked(() -&gt; URLDecoder.decode(value, &quot;UTF-8&quot;)));</span>
<span class="fc" id="L117">				endOfName = -1;</span>
<span class="fc" id="L118">				break;</span>
			}

<span class="fc" id="L121">			final var value = queryString.substring(startOfValue, endOfValue);</span>
<span class="fc" id="L122">			values.offer(IuException.unchecked(() -&gt; URLDecoder.decode(value, &quot;UTF-8&quot;)));</span>

<span class="fc" id="L124">			startOfName = endOfValue + 1;</span>
<span class="fc" id="L125">			endOfName = queryString.indexOf('=', startOfName);</span>
<span class="fc" id="L126">			endOfValue = queryString.indexOf('&amp;', startOfName);</span>
<span class="fc bfc" id="L127" title="All 2 branches covered.">			if (endOfValue == -1)</span>
<span class="fc" id="L128">				endOfValue = queryString.length();</span>

<span class="fc bfc" id="L130" title="All 4 branches covered.">			if (endOfName == -1 //</span>
					|| endOfName &gt; endOfValue)
<span class="fc" id="L132">				endOfName = startOfValue = endOfValue;</span>
			else
<span class="fc" id="L134">				startOfValue = endOfName + 1;</span>
<span class="fc" id="L135">		}</span>

<span class="fc" id="L137">		return parsedParameterValues;</span>
	}

	/**
	 * Creates a query string from a map.
	 * 
	 * @param params {@link Map} of parameter values
	 * @return query string
	 */
	public static String createQueryString(Map&lt;String, ? extends Iterable&lt;String&gt;&gt; params) {
<span class="fc" id="L147">		final var queryString = new StringBuilder();</span>
<span class="fc bfc" id="L148" title="All 2 branches covered.">		for (final var paramEntry : params.entrySet())</span>
<span class="fc bfc" id="L149" title="All 2 branches covered.">			for (final var paramValue : paramEntry.getValue()) {</span>
<span class="fc bfc" id="L150" title="All 2 branches covered.">				if (queryString.length() &gt; 0)</span>
<span class="fc" id="L151">					queryString.append('&amp;');</span>
<span class="fc" id="L152">				queryString.append(IuException.unchecked(() -&gt; URLEncoder.encode(paramEntry.getKey(), &quot;UTF-8&quot;)));</span>
<span class="fc" id="L153">				queryString.append(&quot;=&quot;).append(IuException.unchecked(() -&gt; URLEncoder.encode(paramValue, &quot;UTF-8&quot;)));</span>
<span class="fc" id="L154">			}</span>
<span class="fc" id="L155">		return queryString.toString();</span>
	}

	/**
	 * Parses a header value composed of key/value pairs separated by semicolon ';'.
	 * 
	 * @param headerValue header value
	 * @return {@link Map} of header elements
	 */
	public static Map&lt;String, String&gt; parseHeader(String headerValue) {
<span class="fc" id="L165">		int semicolon = headerValue.indexOf(';');</span>
<span class="fc bfc" id="L166" title="All 2 branches covered.">		if (semicolon == -1)</span>
<span class="fc" id="L167">			return Collections.singletonMap(&quot;&quot;, headerValue);</span>

<span class="fc" id="L169">		final Map&lt;String, String&gt; parsedHeader = new LinkedHashMap&lt;&gt;();</span>
<span class="fc" id="L170">		parsedHeader.put(&quot;&quot;, headerValue.substring(0, semicolon));</span>

<span class="fc bfc" id="L172" title="All 2 branches covered.">		while (semicolon &lt; headerValue.length()) {</span>
<span class="fc" id="L173">			final var start = semicolon + 1;</span>
<span class="fc" id="L174">			final var eq = headerValue.indexOf('=', start + 1);</span>

<span class="fc" id="L176">			semicolon = headerValue.indexOf(';', start + 1);</span>
<span class="fc bfc" id="L177" title="All 2 branches covered.">			if (semicolon == -1)</span>
<span class="fc" id="L178">				semicolon = headerValue.length();</span>

<span class="fc bfc" id="L180" title="All 4 branches covered.">			if (eq == -1 || eq &gt; semicolon)</span>
<span class="fc" id="L181">				parsedHeader.put(headerValue.substring(start, semicolon).trim(), &quot;&quot;);</span>
			else {
<span class="fc" id="L183">				final var elementName = headerValue.substring(start, eq).trim();</span>
<span class="fc" id="L184">				final String elementValue = headerValue.substring(eq + 1, semicolon).trim();</span>
<span class="fc" id="L185">				parsedHeader.put(elementName, elementValue);</span>
			}
<span class="fc" id="L187">		}</span>

<span class="fc" id="L189">		return parsedHeader;</span>
	}

	/**
	 * Validates and normalizes case for an HTTP header name.
	 * 
	 * &lt;p&gt;
	 * Follows each hyphen '-' character with an upper case character; converts
	 * other characters {@link Character#toLowerCase(char) to lower case}
	 * &lt;/p&gt;
	 * 
	 * @param headerName HTTP header name
	 * @return {@link String}
	 * @throws IllegalArgumentException If the name contains non-alphabetic
	 *                                  characters other than hyphen '-', or if the
	 *                                  name begins or ends with a hyphen.
	 */
	public static String normalizeHeaderName(String headerName) throws IllegalArgumentException {
<span class="fc bfc" id="L207" title="All 2 branches covered.">		if (!headerName.matches(&quot;\\p{Alpha}+(\\-\\p{Alpha}+?)*&quot;))</span>
<span class="fc" id="L208">			throw new IllegalArgumentException(&quot;Invalid header name &quot; + headerName);</span>

<span class="fc" id="L210">		final var sb = new StringBuilder(headerName.toLowerCase());</span>
<span class="fc" id="L211">		sb.setCharAt(0, Character.toUpperCase(sb.charAt(0)));</span>
<span class="fc" id="L212">		for (int i = headerName.indexOf('-') + 1; //</span>
<span class="fc bfc" id="L213" title="All 2 branches covered.">				i != 0; //</span>
<span class="fc" id="L214">				i = headerName.indexOf('-', i + 1) + 1)</span>
<span class="fc" id="L215">			sb.setCharAt(i, Character.toUpperCase(sb.charAt(i)));</span>

<span class="fc" id="L217">		return sb.toString();</span>
	}

	/**
	 * Describes an HTTP status code.
	 * 
	 * @param statusCode HTTP status code
	 * @return {@link String}
	 */
	public static String describeStatus(int statusCode) {
<span class="fc bfc" id="L227" title="All 41 branches covered.">		switch (statusCode) {</span>
		case 100:
<span class="fc" id="L229">			return statusCode + &quot; CONTINUE&quot;;</span>
		case 101:
<span class="fc" id="L231">			return statusCode + &quot; SWITCHING PROTOCOLS&quot;;</span>
		case 200:
<span class="fc" id="L233">			return statusCode + &quot; OK&quot;;</span>
		case 201:
<span class="fc" id="L235">			return statusCode + &quot; CREATED&quot;;</span>
		case 202:
<span class="fc" id="L237">			return statusCode + &quot; ACCEPTED&quot;;</span>
		case 203:
<span class="fc" id="L239">			return statusCode + &quot; NON AUTHORITATIVE INFORMATION&quot;;</span>
		case 204:
<span class="fc" id="L241">			return statusCode + &quot; NO CONTENT&quot;;</span>
		case 205:
<span class="fc" id="L243">			return statusCode + &quot; RESET CONTENT&quot;;</span>
		case 206:
<span class="fc" id="L245">			return statusCode + &quot; PARTIAL CONTENT&quot;;</span>
		case 300:
<span class="fc" id="L247">			return statusCode + &quot; MULTIPLE CHOICES&quot;;</span>
		case 301:
<span class="fc" id="L249">			return statusCode + &quot; MOVED PERMANENTLY&quot;;</span>
		case 302:
<span class="fc" id="L251">			return statusCode + &quot; FOUND&quot;;</span>
		case 303:
<span class="fc" id="L253">			return statusCode + &quot; SEE OTHER&quot;;</span>
		case 304:
<span class="fc" id="L255">			return statusCode + &quot; NOT MODIFIED&quot;;</span>
		case 305:
<span class="fc" id="L257">			return statusCode + &quot; USE PROXY&quot;;</span>
		case 307:
<span class="fc" id="L259">			return statusCode + &quot; TEMPORARY REDIRECT&quot;;</span>
		case 400:
<span class="fc" id="L261">			return statusCode + &quot; BAD REQUEST&quot;;</span>
		case 401:
<span class="fc" id="L263">			return statusCode + &quot; UNAUTHORIZED&quot;;</span>
		case 402:
<span class="fc" id="L265">			return statusCode + &quot; PAYMENT REQUIRED&quot;;</span>
		case 403:
<span class="fc" id="L267">			return statusCode + &quot; FORBIDDEN&quot;;</span>
		case 404:
<span class="fc" id="L269">			return statusCode + &quot; NOT FOUND&quot;;</span>
		case 405:
<span class="fc" id="L271">			return statusCode + &quot; METHOD NOT ALLOWED&quot;;</span>
		case 406:
<span class="fc" id="L273">			return statusCode + &quot; NOT ACCEPTABLE&quot;;</span>
		case 407:
<span class="fc" id="L275">			return statusCode + &quot; PROXY AUTHENTICATION REQUIRED&quot;;</span>
		case 408:
<span class="fc" id="L277">			return statusCode + &quot; REQUEST TIMEOUT&quot;;</span>
		case 409:
<span class="fc" id="L279">			return statusCode + &quot; CONFLICT&quot;;</span>
		case 410:
<span class="fc" id="L281">			return statusCode + &quot; GONE&quot;;</span>
		case 411:
<span class="fc" id="L283">			return statusCode + &quot; LENGTH REQUIRED&quot;;</span>
		case 412:
<span class="fc" id="L285">			return statusCode + &quot; PRECONDITION FAILED&quot;;</span>
		case 413:
<span class="fc" id="L287">			return statusCode + &quot; REQUEST ENTITY TOO LARGE&quot;;</span>
		case 414:
<span class="fc" id="L289">			return statusCode + &quot; REQUEST URI TOO LONG&quot;;</span>
		case 415:
<span class="fc" id="L291">			return statusCode + &quot; UNSUPPORTED MEDIA TYPE&quot;;</span>
		case 416:
<span class="fc" id="L293">			return statusCode + &quot; REQUESTED RANGE NOT SATISFIABLE&quot;;</span>
		case 417:
<span class="fc" id="L295">			return statusCode + &quot; EXPECTATION FAILED&quot;;</span>
		case 500:
<span class="fc" id="L297">			return statusCode + &quot; INTERNAL SERVER ERROR&quot;;</span>
		case 501:
<span class="fc" id="L299">			return statusCode + &quot; NOT IMPLEMENTED&quot;;</span>
		case 502:
<span class="fc" id="L301">			return statusCode + &quot; BAD GATEWAY&quot;;</span>
		case 503:
<span class="fc" id="L303">			return statusCode + &quot; SERVICE UNAVAILABLE&quot;;</span>
		case 504:
<span class="fc" id="L305">			return statusCode + &quot; GATEWAY TIMEOUT&quot;;</span>
		case 505:
<span class="fc" id="L307">			return statusCode + &quot; HTTP VERSION NOT SUPPORTED&quot;;</span>
		default:
<span class="fc" id="L309">			return statusCode + &quot; UNKNOWN&quot;;</span>
		}
	}

	/**
	 * Resolves and caches the {@link InetAddress IP address} for a host name.
	 * 
	 * @param hostname host name
	 * @return resolved {@link InetAddress}
	 */
	public static InetAddress getInetAddress(String hostname) {
<span class="fc" id="L320">		var addr = IP_CACHE.get(hostname);</span>
<span class="fc bfc" id="L321" title="All 2 branches covered.">		if (addr != null)</span>
<span class="fc" id="L322">			return addr;</span>

<span class="fc" id="L324">		addr = IuException.unchecked(() -&gt; InetAddress.getByName(hostname));</span>
<span class="fc" id="L325">		IP_CACHE.put(hostname, addr);</span>

<span class="fc" id="L327">		return addr;</span>
	}

	/**
	 * Determines whether or not an IP address is included in a CIDR range.
	 * 
	 * @param address address
	 * @param range   CIDR range
	 * @return true if the range includes the address; else false
	 */
	public static boolean isInetAddressInRange(InetAddress address, String range) {
<span class="fc" id="L338">		byte[] hostaddr = address.getAddress();</span>
<span class="fc" id="L339">		int lastSlash = range.lastIndexOf('/');</span>

		byte[] rangeaddr;
		int maskbits;
<span class="fc bfc" id="L343" title="All 2 branches covered.">		if (lastSlash == -1) {</span>
<span class="fc" id="L344">			rangeaddr = getInetAddress(range).getAddress();</span>
<span class="fc" id="L345">			maskbits = rangeaddr.length * 8;</span>
		} else {
<span class="fc" id="L347">			rangeaddr = getInetAddress(range.substring(0, lastSlash)).getAddress();</span>
<span class="fc" id="L348">			maskbits = Integer.parseInt(range.substring(lastSlash + 1));</span>
		}

<span class="fc bfc" id="L351" title="All 2 branches covered.">		for (int i = 0; i &lt; rangeaddr.length; i++) {</span>
<span class="fc bfc" id="L352" title="All 2 branches covered.">			if (maskbits &gt;= 8) {</span>
<span class="fc" id="L353">				maskbits -= 8;</span>
<span class="fc bfc" id="L354" title="All 2 branches covered.">				if (hostaddr[i] != rangeaddr[i])</span>
<span class="fc" id="L355">					return false;</span>
<span class="fc bfc" id="L356" title="All 2 branches covered.">			} else if (maskbits &gt; 0) {</span>
<span class="fc" id="L357">				int mask = ~((1 &lt;&lt; (8 - maskbits)) - 1);</span>
<span class="fc bfc" id="L358" title="All 2 branches covered.">				return (hostaddr[i] &amp; mask) == (rangeaddr[i] &amp; mask);</span>
			} else
				break;
		}

<span class="fc" id="L363">		return true;</span>
	}

	private IuWebUtils() {
	}

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.10.202304240956</span></div></body></html>