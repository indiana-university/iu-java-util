<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>OidcAuthorizationClient.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">IU OpenID Connect Client</a> &gt; <a href="index.source.html" class="el_package">iu.auth.oidc</a> &gt; <span class="el_source">OidcAuthorizationClient.java</span></div><h1>OidcAuthorizationClient.java</h1><pre class="source lang-java linenums">/*
 * Copyright Â© 2024 Indiana University
 * All rights reserved.
 *
 * BSD 3-Clause License
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 
 * - Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 * 
 * - Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 * 
 * - Neither the name of the copyright holder nor the names of its
 *   contributors may be used to endorse or promote products derived from
 *   this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package iu.auth.oidc;

import java.io.Serializable;
import java.net.URI;
import java.net.http.HttpRequest;
import java.security.MessageDigest;
import java.security.Principal;
import java.time.Duration;
import java.time.Instant;
import java.util.Arrays;
import java.util.Base64;
import java.util.Collections;
import java.util.HashSet;
import java.util.LinkedHashMap;
import java.util.Map;
import java.util.Objects;
import java.util.Set;
import java.util.function.BiConsumer;
import java.util.function.Predicate;
import java.util.function.Supplier;
import java.util.logging.Level;
import java.util.logging.Logger;

import javax.security.auth.Subject;

import com.auth0.jwt.interfaces.DecodedJWT;

import edu.iu.IdGenerator;
import edu.iu.IuAuthorizationFailedException;
import edu.iu.IuBadRequestException;
import edu.iu.IuException;
import edu.iu.IuIterable;
import edu.iu.IuObject;
import edu.iu.IuOutOfServiceException;
import edu.iu.IuText;
import edu.iu.auth.IuApiCredentials;
import edu.iu.auth.IuAuthenticationException;
import edu.iu.auth.oauth.IuAuthorizationClient;
import edu.iu.auth.oauth.IuBearerAuthCredentials;
import edu.iu.auth.oauth.IuTokenResponse;
import edu.iu.auth.oidc.IuOpenIdClaim;
import edu.iu.auth.oidc.IuOpenIdClient;
import iu.auth.util.AccessTokenVerifier;
import iu.auth.util.HttpUtils;
import jakarta.json.JsonObject;
import jakarta.json.JsonString;

/**
 * OpenID Connect {@link IuAuthorizationClient} implementation.
 */
class OidcAuthorizationClient implements IuAuthorizationClient {

<span class="fc" id="L84">	private static final Logger LOG = Logger.getLogger(OidcAuthorizationClient.class.getName());</span>

<span class="fc" id="L86">	private static final Iterable&lt;String&gt; OIDC_SCOPE = IuIterable.iter(&quot;openid&quot;);</span>
<span class="fc" id="L87">	private static final Predicate&lt;String&gt; IS_OIDC = &quot;openid&quot;::equals;</span>

	private static class Id implements Principal, Serializable {
		private static final long serialVersionUID = 1L;

		private final String name;
<span class="fc" id="L93">		private String activationCode = IdGenerator.generateId();</span>

<span class="fc" id="L95">		private Id(String name) {</span>
<span class="fc" id="L96">			this.name = name;</span>
<span class="fc" id="L97">		}</span>

		@Override
		public String getName() {
<span class="fc" id="L101">			return name;</span>
		}

		@Override
		public int hashCode() {
<span class="fc" id="L106">			return IuObject.hashCode(name);</span>
		}

		@Override
		public boolean equals(Object obj) {
<span class="fc bfc" id="L111" title="All 2 branches covered.">			if (!IuObject.typeCheck(this, obj))</span>
<span class="fc" id="L112">				return false;</span>
<span class="fc" id="L113">			Id other = (Id) obj;</span>
<span class="fc" id="L114">			return IuObject.equals(name, other.name);</span>
		}

		@Override
		public String toString() {
<span class="fc" id="L119">			return &quot;OIDC Principal ID [name=&quot; + name + &quot;]&quot;;</span>
		}
	}

	private final String realm;
	private final URI authorizationEndpoint;
	private final URI tokenEndpoint;
	private final URI userinfoEndpoint;
	private final IuOpenIdClient client;
	private final AccessTokenVerifier idTokenVerifier;

<span class="fc" id="L130">	private final Set&lt;String&gt; nonces = new HashSet&lt;&gt;();</span>

	/**
	 * Constructor.
	 * 
	 * @param config          parsed OIDC provider configuration
	 * @param client          client configuration metadata
	 * @param idTokenVerifier ID token verifier
	 */
<span class="fc" id="L139">	OidcAuthorizationClient(JsonObject config, IuOpenIdClient client, AccessTokenVerifier idTokenVerifier) {</span>
<span class="fc" id="L140">		realm = config.getString(&quot;issuer&quot;);</span>
<span class="fc" id="L141">		authorizationEndpoint = IuException.unchecked(() -&gt; new URI(config.getString(&quot;authorization_endpoint&quot;)));</span>
<span class="fc" id="L142">		tokenEndpoint = IuException.unchecked(() -&gt; new URI(config.getString(&quot;token_endpoint&quot;)));</span>
<span class="fc" id="L143">		userinfoEndpoint = IuException.unchecked(() -&gt; new URI(config.getString(&quot;userinfo_endpoint&quot;)));</span>
<span class="fc" id="L144">		this.client = client;</span>
<span class="fc" id="L145">		this.idTokenVerifier = idTokenVerifier;</span>
<span class="fc" id="L146">	}</span>

	@Override
	public String getRealm() {
<span class="fc" id="L150">		return realm;</span>
	}

	@Override
	public URI getAuthorizationEndpoint() {
<span class="fc" id="L155">		return authorizationEndpoint;</span>
	}

	@Override
	public URI getTokenEndpoint() {
<span class="fc" id="L160">		return tokenEndpoint;</span>
	}

	@Override
	public URI getRedirectUri() {
<span class="fc" id="L165">		return client.getRedirectUri();</span>
	}

	@Override
	public Map&lt;String, String&gt; getAuthorizationCodeAttributes() {
<span class="fc" id="L170">		final Map&lt;String, String&gt; attributes = new LinkedHashMap&lt;&gt;();</span>

<span class="fc" id="L172">		final var clientAttributes = client.getAuthorizationCodeAttributes();</span>
<span class="fc bfc" id="L173" title="All 2 branches covered.">		if (clientAttributes != null)</span>
<span class="fc" id="L174">			attributes.putAll(clientAttributes);</span>

<span class="fc" id="L176">		final var nonce = IdGenerator.generateId();</span>
<span class="fc" id="L177">		synchronized (nonces) {</span>
<span class="fc" id="L178">			nonces.add(nonce);</span>
<span class="fc" id="L179">		}</span>
<span class="fc" id="L180">		attributes.put(&quot;nonce&quot;, nonce);</span>

<span class="fc" id="L182">		final var authenticatedSessionTimeout = client.getAuthenticatedSessionTimeout();</span>
<span class="fc bfc" id="L183" title="All 2 branches covered.">		if (authenticatedSessionTimeout != null)</span>
<span class="fc" id="L184">			attributes.put(&quot;max_age&quot;, Long.toString(authenticatedSessionTimeout.toSeconds()));</span>

<span class="fc" id="L186">		return Collections.unmodifiableMap(attributes);</span>
	}

	@Override
	public Map&lt;String, String&gt; getClientCredentialsAttributes() {
<span class="fc" id="L191">		return client.getClientCredentialsAttributes();</span>
	}

	@Override
	public IuApiCredentials getCredentials() {
<span class="fc" id="L196">		return client.getCredentials();</span>
	}

	@Override
	public Duration getAuthenticationTimeout() {
<span class="fc" id="L201">		return client.getAuthenticationTimeout();</span>
	}

	@Override
	public URI getResourceUri() {
<span class="fc" id="L206">		return client.getResourceUri();</span>
	}

	@Override
	public Iterable&lt;String&gt; getScope() {
<span class="fc" id="L211">		final var scope = client.getScope();</span>
<span class="fc bfc" id="L212" title="All 2 branches covered.">		if (scope == null)</span>
<span class="fc" id="L213">			return OIDC_SCOPE;</span>
		else
<span class="fc bfc" id="L215" title="All 2 branches covered.">			return (Iterable&lt;String&gt;) IuIterable.cat(OIDC_SCOPE, IuIterable.filter(scope, a -&gt; !&quot;openid&quot;.equals(a)));</span>
	}

	@Override
	public Subject verify(IuTokenResponse tokenResponse) throws IuAuthenticationException, IuBadRequestException,
			IuAuthorizationFailedException, IuOutOfServiceException, IllegalStateException {
<span class="fc bfc" id="L221" title="All 2 branches covered.">		if (!IuIterable.filter(tokenResponse.getScope(), IS_OIDC).iterator().hasNext())</span>
<span class="fc" id="L222">			throw new IuAuthorizationFailedException(&quot;missing openid scope&quot;);</span>

<span class="fc" id="L224">		final var accessToken = Objects.requireNonNull(tokenResponse.getAccessToken(), &quot;access_token&quot;);</span>

		// TODO: STARCH-595 resolve String cast
<span class="fc" id="L227">		final var clientId = client.getCredentials().getName();</span>
<span class="fc" id="L228">		final var idToken = tokenResponse.getTokenAttributes().get(&quot;id_token&quot;);</span>
		final DecodedJWT verifiedIdToken;
<span class="fc bfc" id="L230" title="All 2 branches covered.">		if (idToken != null) {</span>
<span class="fc" id="L231">			final var alg = client.getIdTokenSignedResponseAlg();</span>
<span class="fc" id="L232">			verifiedIdToken = idTokenVerifier.verify(clientId, (String) idToken);</span>
<span class="fc bfc" id="L233" title="All 2 branches covered.">			if (!alg.equals(verifiedIdToken.getAlgorithm()))</span>
<span class="fc" id="L234">				throw new IllegalArgumentException(alg + &quot; required&quot;);</span>

<span class="fc" id="L236">			final var encodedHash = IuException</span>
<span class="fc" id="L237">					.unchecked(() -&gt; MessageDigest.getInstance(&quot;SHA-256&quot;).digest(IuText.utf8(accessToken)));</span>
<span class="fc" id="L238">			final var halfOfEncodedHash = Arrays.copyOf(encodedHash, (encodedHash.length / 2));</span>
<span class="fc" id="L239">			final var atHashGeneratedfromAccessToken = Base64.getUrlEncoder().withoutPadding()</span>
<span class="fc" id="L240">					.encodeToString(halfOfEncodedHash);</span>

<span class="fc" id="L242">			final var atHash = Objects.requireNonNull(verifiedIdToken.getClaim(&quot;at_hash&quot;).asString(), &quot;at_hash&quot;);</span>
<span class="fc bfc" id="L243" title="All 2 branches covered.">			if (!atHash.equals(atHashGeneratedfromAccessToken))</span>
<span class="fc" id="L244">				throw new IllegalStateException(&quot;Invalid at_hash&quot;);</span>

<span class="fc" id="L246">			final var nonce = verifiedIdToken.getClaim(&quot;nonce&quot;).asString();</span>
<span class="fc" id="L247">			IdGenerator.verifyId(nonce, client.getAuthenticationTimeout().toMillis());</span>
<span class="fc" id="L248">			synchronized (nonces) {</span>
<span class="fc bfc" id="L249" title="All 2 branches covered.">				if (!nonces.remove(nonce))</span>
<span class="fc" id="L250">					throw new IllegalArgumentException(&quot;Invalid nonce&quot;);</span>
<span class="fc" id="L251">			}</span>
<span class="fc" id="L252">		} else</span>
<span class="fc" id="L253">			verifiedIdToken = null;</span>

<span class="fc" id="L255">		final var userinfo = HttpUtils.read(HttpRequest.newBuilder(userinfoEndpoint) //</span>
<span class="fc" id="L256">				.header(&quot;Authorization&quot;, &quot;Bearer &quot; + accessToken).build()).asJsonObject();</span>
<span class="fc" id="L257">		final var principal = userinfo.getString(&quot;principal&quot;);</span>
<span class="fc" id="L258">		final var sub = userinfo.getString(&quot;sub&quot;);</span>
<span class="fc" id="L259">		final var id = new Id(principal);</span>

<span class="fc bfc" id="L261" title="All 4 branches covered.">		if (clientId.equals(principal) &amp;&amp; clientId.equals(sub)) {</span>
<span class="fc" id="L262">			id.activationCode = IdGenerator.generateId();</span>
<span class="fc" id="L263">			return new Subject(true, Set.of(id), Set.of(), Set.of());</span>
		}

<span class="fc bfc" id="L266" title="All 2 branches covered.">		if (idToken == null)</span>
<span class="fc" id="L267">			throw new IllegalStateException(&quot;Token response missing id_token&quot;);</span>

<span class="fc" id="L269">		final var now = Instant.now();</span>
<span class="fc" id="L270">		final var authTime = verifiedIdToken.getClaim(&quot;auth_time&quot;).asInstant();</span>
<span class="fc" id="L271">		final var authExpires = authTime.plus(client.getAuthenticatedSessionTimeout());</span>
<span class="fc bfc" id="L272" title="All 2 branches covered.">		if (now.isAfter(authExpires)) {</span>
<span class="fc" id="L273">			final Map&lt;String, String&gt; challengeAttributes = new LinkedHashMap&lt;&gt;();</span>
<span class="fc" id="L274">			challengeAttributes.put(&quot;realm&quot;, realm);</span>
<span class="fc" id="L275">			challengeAttributes.put(&quot;scope&quot;, String.join(&quot; &quot;, getScope()));</span>
<span class="fc" id="L276">			challengeAttributes.put(&quot;error&quot;, &quot;invalid_token&quot;);</span>
<span class="fc" id="L277">			challengeAttributes.put(&quot;error_description&quot;, &quot;auth session timeout, must reauthenticate&quot;);</span>
<span class="fc" id="L278">			throw new IuAuthenticationException(HttpUtils.createChallenge(&quot;Bearer&quot;, challengeAttributes));</span>
		}

<span class="fc" id="L281">		final Set&lt;String&gt; seen = new HashSet&lt;&gt;();</span>
<span class="fc" id="L282">		final var subject = new Subject();</span>
<span class="fc" id="L283">		final var principals = subject.getPrincipals();</span>
<span class="fc" id="L284">		principals.add(id);</span>

<span class="fc" id="L286">		final BiConsumer&lt;String, Supplier&lt;?&gt;&gt; claimConsumer = //</span>
				(claimName, claimSupplier) -&gt; {
<span class="fc bfc" id="L288" title="All 2 branches covered.">					if (seen.add(claimName))</span>
<span class="fc" id="L289">						principals.add(new OidcClaim&lt;&gt;(principal, claimName,</span>
<span class="fc" id="L290">								Objects.requireNonNull(claimSupplier.get(), claimName)));</span>
<span class="fc" id="L291">				};</span>

<span class="fc" id="L293">		claimConsumer.accept(&quot;principal&quot;, () -&gt; principal);</span>
<span class="fc" id="L294">		claimConsumer.accept(&quot;sub&quot;, () -&gt; sub);</span>
<span class="fc" id="L295">		claimConsumer.accept(&quot;aud&quot;, () -&gt; clientId);</span>
<span class="fc" id="L296">		claimConsumer.accept(&quot;iat&quot;, verifiedIdToken::getIssuedAtAsInstant);</span>
<span class="fc" id="L297">		claimConsumer.accept(&quot;exp&quot;, verifiedIdToken::getExpiresAtAsInstant);</span>
<span class="fc" id="L298">		claimConsumer.accept(&quot;auth_time&quot;, () -&gt; authTime);</span>

<span class="fc bfc" id="L300" title="All 2 branches covered.">		for (final var userinfoClaimEntry : userinfo.entrySet())</span>
<span class="fc" id="L301">			claimConsumer.accept(userinfoClaimEntry.getKey(), () -&gt; {</span>
<span class="fc" id="L302">				final var claimJsonValue = userinfoClaimEntry.getValue();</span>
<span class="fc bfc" id="L303" title="All 2 branches covered.">				if (claimJsonValue instanceof JsonString)</span>
<span class="fc" id="L304">					return ((JsonString) claimJsonValue).getString();</span>
				else
<span class="fc" id="L306">					return claimJsonValue.toString();</span>
			});

<span class="fc" id="L309">		return subject;</span>
	}

	@Override
	public Subject verify(IuTokenResponse refreshTokenResponse, IuTokenResponse originalTokenResponse)
			throws IuAuthenticationException, IuBadRequestException, IuAuthorizationFailedException,
			IuOutOfServiceException, IllegalStateException {
		// TODO establish and verify refresh token integration test
<span class="fc" id="L317">		throw new UnsupportedOperationException(&quot;TODO&quot;);</span>
	}

	@Override
	public void activate(IuApiCredentials credentials) throws IuAuthenticationException, IuBadRequestException,
			IuAuthorizationFailedException, IuOutOfServiceException, IllegalStateException {
<span class="fc bfc" id="L323" title="All 2 branches covered.">		if (!(credentials instanceof IuBearerAuthCredentials))</span>
<span class="fc" id="L324">			throw new IllegalArgumentException(&quot;Invalid credentials type&quot;);</span>

<span class="fc" id="L326">		final var bearer = (IuBearerAuthCredentials) credentials;</span>
<span class="fc" id="L327">		final var subject = Objects.requireNonNull(bearer.getSubject(), &quot;subject&quot;);</span>
<span class="fc" id="L328">		final var id = subject.getPrincipals(Id.class).iterator().next();</span>
		try {
<span class="fc" id="L330">			IdGenerator.verifyId(id.activationCode, client.getActivationInterval().toMillis());</span>
<span class="fc" id="L331">			return;</span>
<span class="fc" id="L332">		} catch (Throwable e) {</span>
<span class="fc" id="L333">			LOG.log(Level.FINER, e, () -&gt; &quot;discarding invalid activation code&quot;);</span>
<span class="fc" id="L334">			id.activationCode = null;</span>
		}

		try {
<span class="fc" id="L338">			final Map&lt;String, Object&gt; claims = new LinkedHashMap&lt;&gt;();</span>
<span class="fc bfc" id="L339" title="All 2 branches covered.">			for (final var claim : subject.getPrincipals(IuOpenIdClaim.class))</span>
<span class="fc" id="L340">				claims.put(claim.getClaimName(), claim.getClaim());</span>

<span class="fc" id="L342">			final var accessToken = Objects.requireNonNull(bearer.getAccessToken(), &quot;accessToken&quot;);</span>
<span class="fc" id="L343">			final var userinfo = HttpUtils.read(HttpRequest.newBuilder(userinfoEndpoint) //</span>
<span class="fc" id="L344">					.header(&quot;Authorization&quot;, &quot;Bearer &quot; + accessToken).build()).asJsonObject();</span>
<span class="fc" id="L345">			final var principal = userinfo.getString(&quot;principal&quot;);</span>
<span class="fc" id="L346">			final var sub = userinfo.getString(&quot;sub&quot;);</span>

<span class="fc" id="L348">			final var clientId = client.getCredentials().getName();</span>
<span class="fc bfc" id="L349" title="All 4 branches covered.">			if (clientId.equals(principal) &amp;&amp; clientId.equals(sub)) {</span>
<span class="fc" id="L350">				id.activationCode = IdGenerator.generateId();</span>
<span class="fc" id="L351">				return;</span>
			}

<span class="fc bfc" id="L354" title="All 2 branches covered.">			if (!clientId.equals(claims.get(&quot;aud&quot;)))</span>
<span class="fc" id="L355">				throw new IllegalArgumentException(&quot;Invalid aud&quot;);</span>

<span class="fc" id="L357">			final var now = Instant.now();</span>
<span class="fc" id="L358">			final var authTime = (Instant) claims.get(&quot;auth_time&quot;);</span>
<span class="fc" id="L359">			final var authExpires = authTime.plus(client.getAuthenticatedSessionTimeout());</span>
<span class="fc bfc" id="L360" title="All 2 branches covered.">			if (now.isAfter(authExpires)) {</span>
<span class="fc" id="L361">				final Map&lt;String, String&gt; challengeAttributes = new LinkedHashMap&lt;&gt;();</span>
<span class="fc" id="L362">				challengeAttributes.put(&quot;realm&quot;, realm);</span>
<span class="fc" id="L363">				challengeAttributes.put(&quot;scope&quot;, String.join(&quot; &quot;, getScope()));</span>
<span class="fc" id="L364">				challengeAttributes.put(&quot;error&quot;, &quot;invalid_token&quot;);</span>
<span class="fc" id="L365">				challengeAttributes.put(&quot;error_description&quot;, &quot;auth session timeout, must reauthenticate&quot;);</span>
<span class="fc" id="L366">				throw new IuAuthenticationException(HttpUtils.createChallenge(&quot;Bearer&quot;, challengeAttributes));</span>
			}

<span class="fc bfc" id="L369" title="All 2 branches covered.">			for (final var userinfoClaimEntry : userinfo.entrySet()) {</span>
<span class="fc" id="L370">				final var claimJsonValue = userinfoClaimEntry.getValue();</span>
				final String claim;
<span class="fc bfc" id="L372" title="All 2 branches covered.">				if (claimJsonValue instanceof JsonString)</span>
<span class="fc" id="L373">					claim = ((JsonString) claimJsonValue).getString();</span>
				else
<span class="fc" id="L375">					claim = claimJsonValue.toString();</span>

<span class="fc bfc" id="L377" title="All 2 branches covered.">				if (!IuObject.equals(claim, claims.get(userinfoClaimEntry.getKey())))</span>
<span class="fc" id="L378">					throw new IllegalArgumentException(userinfoClaimEntry.getKey());</span>
<span class="fc" id="L379">			}</span>
<span class="fc" id="L380">		} catch (Throwable e) {</span>
<span class="fc" id="L381">			Map&lt;String, String&gt; challengeAttributes = new LinkedHashMap&lt;&gt;();</span>
<span class="fc" id="L382">			challengeAttributes.put(&quot;realm&quot;, realm);</span>
<span class="fc" id="L383">			challengeAttributes.put(&quot;scope&quot;, String.join(&quot; &quot;, getScope()));</span>
<span class="fc" id="L384">			challengeAttributes.put(&quot;error&quot;, &quot;invalid_token&quot;);</span>
<span class="fc" id="L385">			challengeAttributes.put(&quot;error_description&quot;, &quot;session activation failed, must reauthenticate&quot;);</span>
<span class="fc" id="L386">			throw new IuAuthenticationException(HttpUtils.createChallenge(&quot;Bearer&quot;, challengeAttributes), e);</span>
<span class="fc" id="L387">		}</span>

<span class="fc" id="L389">		client.activate(credentials);</span>

<span class="fc" id="L391">		id.activationCode = IdGenerator.generateId();</span>
<span class="fc" id="L392">	}</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.10.202304240956</span></div></body></html>