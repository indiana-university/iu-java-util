<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>IuObject.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">IU Base Utilities Module</a> &gt; <a href="index.source.html" class="el_package">edu.iu</a> &gt; <span class="el_source">IuObject.java</span></div><h1>IuObject.java</h1><pre class="source lang-java linenums">/*
 * Copyright Â© 2023 Indiana University
 * All rights reserved.
 *
 * BSD 3-Clause License
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 
 * - Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 * 
 * - Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 * 
 * - Neither the name of the copyright holder nor the names of its
 *   contributors may be used to endorse or promote products derived from
 *   this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package edu.iu;

import java.lang.reflect.Array;
import java.util.Arrays;
import java.util.Comparator;
import java.util.Iterator;
import java.util.Map;
import java.util.Set;
import java.util.SortedSet;

/**
 * Simplifies building efficient {@link Object#equals(Object)},
 * {@link Object#hashCode()}, and {@link Comparable#compareTo(Object)} methods
 * on plain Java objects.
 * 
 * &lt;p&gt;
 * The use of this utility is preferred, following the examples below, over
 * other methods of generating these methods. When following these examples, the
 * implements can be expected to follow the expected contracts in a null-safe
 * and type-safe manner without undue object creation.
 * &lt;/p&gt;
 * 
 * &lt;dl&gt;
 * &lt;dt&gt;Top level object:&lt;/dt&gt;
 * &lt;dd&gt;
 * 
 * &lt;pre&gt;
 * &amp;#064;Override
 * public int hashCode() {
 * 	return ObjectUtil.hashCode(val1, val2);
 * }
 * 
 * &amp;#064;Override
 * public boolean equals(Object obj) {
 * 	if (!ObjectUtil.typeCheck(this, obj))
 * 		return false;
 * 	MyClass other = (MyClass) obj;
 * 	return ObjectUtil.equals(this.val1, other.val1) &amp;amp;&amp;amp; ObjectUtil.equals(this.val2, other.val2);
 * }
 * 
 * &amp;#064;Override
 * public int compareTo(T o) {
 * 	Integer rv = ObjectUtil.compareNullCheck(this, o);
 * 	if (rv != null)
 * 		return rv;
 * 
 * 	rv = ObjectUtil.compareTo(this.val1, o.val1);
 * 	if (rv != 0)
 * 		return rv;
 * 
 * 	return ObjectUtil.compareTo(this.val2, o.val2);
 * }
 * &lt;/pre&gt;
 * 
 * &lt;/dd&gt;
 * 
 * &lt;dt&gt;Subclass object:&lt;/dt&gt;
 * &lt;dd&gt;
 * 
 * &lt;pre&gt;
 * &amp;#064;Override
 * public int hashCode() {
 * 	return ObjectUtil.hashCodeSuper(super.hashCode(), val1, val2);
 * }
 * 
 * &amp;#064;Override
 * public boolean equals(Object obj) {
 * 	if (!ObjectUtil.typeCheck(this, obj))
 * 		return false;
 * 	MyClass other = (MyClass) obj;
 * 	return super.equals(obj) &amp;amp;&amp;amp; ObjectUtil.equals(this.val1, other.val1) &amp;amp;&amp;amp; ObjectUtil.equals(this.val2, other.val2);
 * }
 * 
 * &amp;#064;Override
 * public int compareTo(T o) {
 * 	Integer rv = ObjectUtil.compareNullCheck(this, o);
 * 	if (rv != null)
 * 		return rv;
 * 
 * 	rv = ObjectUtil.compareTo(this.val1, o.val1);
 * 	if (rv != 0)
 * 		return rv;
 * 
 * 	rv = ObjectUtil.compareTo(this.val2, o.val2);
 * 	if (rv != 0)
 * 		return rv;
 * 
 * 	return super.compareTo(o);
 * }
 * &lt;/pre&gt;
 * 
 * &lt;/dd&gt;
 * &lt;/dl&gt;
 * 
 * @since 4.0
 */
public final class IuObject {

	/**
	 * Perform identity and and null check on two objects, returning a valid value
	 * for {@link Comparable#compareTo(Object)} if any of the checks result in a
	 * conclusive result.
	 * 
	 * @param o1 any object
	 * @param o2 any object
	 * @return 0 if o1 == o2, -1 if o1 is null, 1 if o2 is null; otherwise, return
	 *         null indicating that compareTo should continue to inspect each
	 *         object's specific data.
	 */
	public static Integer compareNullCheck(Object o1, Object o2) {
<span class="fc bfc" id="L142" title="All 2 branches covered.">		if (o1 == o2)</span>
<span class="fc" id="L143">			return 0;</span>
<span class="fc bfc" id="L144" title="All 2 branches covered.">		if (o1 == null)</span>
<span class="fc" id="L145">			return -1;</span>
<span class="fc bfc" id="L146" title="All 2 branches covered.">		if (o2 == null)</span>
<span class="fc" id="L147">			return 1;</span>
<span class="fc" id="L148">		return null;</span>
	}

	/**
	 * Compares two objects with null checks (see
	 * {@link #compareNullCheck(Object, Object)}) and also consistent sort order
	 * based for objects that don't implement {@link Comparable}.
	 * 
	 * @param o1 any object
	 * @param o2 any object
	 * @return Valid {@link Comparator} return value enforcing consistent sort order
	 *         within the same JVM instance.
	 */
	@SuppressWarnings({ &quot;rawtypes&quot;, &quot;unchecked&quot; })
	public static int compareTo(Object o1, Object o2) {
<span class="fc" id="L163">		Integer rv = compareNullCheck(o1, o2);</span>
<span class="fc bfc" id="L164" title="All 2 branches covered.">		if (rv != null)</span>
<span class="fc" id="L165">			return rv;</span>

		Comparable v1;
		Comparable v2;
<span class="fc bfc" id="L169" title="All 4 branches covered.">		if ((o1.getClass() != o2.getClass()) || !(o1 instanceof Comparable)) {</span>
<span class="fc" id="L170">			v1 = (Comparable) Integer.valueOf(o1.hashCode());</span>
<span class="fc" id="L171">			v2 = (Comparable) Integer.valueOf(o2.hashCode());</span>
		} else {
<span class="fc" id="L173">			v1 = (Comparable) o1;</span>
<span class="fc" id="L174">			v2 = (Comparable) o2;</span>
		}

<span class="fc" id="L177">		return v1.compareTo(v2);</span>
	}

	/**
	 * Generates a hash code for a top-level object based on related values (i.e.
	 * field, bean property values, etc).
	 * 
	 * @param oa related values
	 * @return hash code
	 */
	public static int hashCode(Object... oa) {
<span class="fc" id="L188">		return hashCodeSuper(1, oa);</span>
	}

	/**
	 * Generate a hash code for a subclass object based on its parent class' hash
	 * code and related values.
	 * 
	 * @param superHashCode parent class hash code
	 * @param oa            related values
	 * @return hash code
	 */
	public static int hashCodeSuper(int superHashCode, Object... oa) {
<span class="fc" id="L200">		final int prime = 31;</span>
<span class="fc" id="L201">		int result = superHashCode;</span>
<span class="fc bfc" id="L202" title="All 2 branches covered.">		for (Object o : oa) {</span>
			int hash;
<span class="fc bfc" id="L204" title="All 2 branches covered.">			if (o == null)</span>
<span class="fc" id="L205">				hash = 0;</span>
<span class="fc bfc" id="L206" title="All 2 branches covered.">			else if (o instanceof boolean[])</span>
<span class="fc" id="L207">				hash = Arrays.hashCode((boolean[]) o);</span>
<span class="fc bfc" id="L208" title="All 2 branches covered.">			else if (o instanceof byte[])</span>
<span class="fc" id="L209">				hash = Arrays.hashCode((byte[]) o);</span>
<span class="fc bfc" id="L210" title="All 2 branches covered.">			else if (o instanceof char[])</span>
<span class="fc" id="L211">				hash = Arrays.hashCode((char[]) o);</span>
<span class="fc bfc" id="L212" title="All 2 branches covered.">			else if (o instanceof double[])</span>
<span class="fc" id="L213">				hash = Arrays.hashCode((double[]) o);</span>
<span class="fc bfc" id="L214" title="All 2 branches covered.">			else if (o instanceof float[])</span>
<span class="fc" id="L215">				hash = Arrays.hashCode((float[]) o);</span>
<span class="fc bfc" id="L216" title="All 2 branches covered.">			else if (o instanceof int[])</span>
<span class="fc" id="L217">				hash = Arrays.hashCode((int[]) o);</span>
<span class="fc bfc" id="L218" title="All 2 branches covered.">			else if (o instanceof long[])</span>
<span class="fc" id="L219">				hash = Arrays.hashCode((long[]) o);</span>
<span class="fc bfc" id="L220" title="All 2 branches covered.">			else if (o instanceof short[])</span>
<span class="fc" id="L221">				hash = Arrays.hashCode((short[]) o);</span>
<span class="fc bfc" id="L222" title="All 2 branches covered.">			else if (o.getClass().isArray()) {</span>
<span class="fc" id="L223">				int l = Array.getLength(o);</span>
<span class="fc" id="L224">				int h = o.getClass().getComponentType().hashCode();</span>
<span class="fc bfc" id="L225" title="All 2 branches covered.">				for (int i = 0; i &lt; l; i++)</span>
<span class="fc" id="L226">					h = prime * h + hashCode(Array.get(o, i));</span>
<span class="fc" id="L227">				hash = h;</span>
<span class="fc" id="L228">			} else</span>
<span class="fc" id="L229">				hash = o.hashCode();</span>
<span class="fc" id="L230">			result = prime * result + hash;</span>
		}
<span class="fc" id="L232">		return result;</span>
	}

	/**
	 * Determine if two objects are both non-null instances of the same class. This
	 * method is useful as a null and type safety check when implementing equals. If
	 * this returns true, and the type of one of the objects is known, then it is
	 * safe to cast the other object to the same type.
	 * 
	 * @param &lt;T&gt; object type
	 * @param o1  any object
	 * @param o2  any object
	 * @return True if both objects are not null and instances of the same class.
	 */
	public static &lt;T&gt; boolean typeCheck(T o1, T o2) {
<span class="fc" id="L247">		return typeCheck(o1, o2, null);</span>
	}

	/**
	 * Determine if two objects are both instances of a specific class, or
	 * subclasses of that class. This method is useful as a null and type safety
	 * check when implementing equals. If this returns true, then it is safe to cast
	 * the both objects to the type provided.
	 * 
	 * @param &lt;T&gt;  object type
	 * 
	 * @param o1   any object
	 * @param o2   any object
	 * @param type the type to check, may be null for the behavior outlined in
	 *             {@link #typeCheck(Object, Object)}.
	 * @return True if both objects are not null and instances of the given type, or
	 *         are the same class if type is null.
	 */
	public static &lt;T&gt; boolean typeCheck(T o1, T o2, Class&lt;?&gt; type) {
<span class="fc bfc" id="L266" title="All 2 branches covered.">		if (type != null)</span>
<span class="fc bfc" id="L267" title="All 4 branches covered.">			return type.isInstance(o1) &amp;&amp; type.isInstance(o2);</span>
<span class="fc bfc" id="L268" title="All 2 branches covered.">		if (o1 == o2)</span>
<span class="fc" id="L269">			return true;</span>
<span class="fc bfc" id="L270" title="All 4 branches covered.">		if (o1 == null || o2 == null)</span>
<span class="fc" id="L271">			return false;</span>
<span class="fc bfc" id="L272" title="All 2 branches covered.">		return o1.getClass() == o2.getClass();</span>
	}

	/**
	 * Determine if two objects are equal, checking first for identity and null.
	 * 
	 * @param o1 any object
	 * @param o2 any object
	 * @return true if o1 and o2 refer to the same object, are both null, or if
	 *         o1.equals(o2) returns true. Otherwise, return false.
	 */
	public static boolean equals(Object o1, Object o2) {
<span class="fc bfc" id="L284" title="All 2 branches covered.">		if (o1 == o2)</span>
<span class="fc" id="L285">			return true;</span>
<span class="fc bfc" id="L286" title="All 4 branches covered.">		if (o1 == null || o2 == null)</span>
<span class="fc" id="L287">			return false;</span>

<span class="fc bfc" id="L289" title="All 2 branches covered.">		if (o1.getClass() != o2.getClass())</span>
<span class="fc bfc" id="L290" title="All 8 branches covered.">			if (o1 instanceof Set &amp;&amp; o2 instanceof Set &amp;&amp; !(o1 instanceof SortedSet) &amp;&amp; !(o2 instanceof SortedSet)) {</span>
<span class="fc" id="L291">				Set&lt;?&gt; s1 = (Set&lt;?&gt;) o1;</span>
<span class="fc" id="L292">				Set&lt;?&gt; s2 = (Set&lt;?&gt;) o2;</span>
<span class="fc bfc" id="L293" title="All 2 branches covered.">				if (s1.size() != s2.size())</span>
<span class="fc" id="L294">					return false;</span>
<span class="fc" id="L295">				return s1.containsAll(s2);</span>
<span class="fc bfc" id="L296" title="All 4 branches covered.">			} else if (o1 instanceof Iterable &amp;&amp; o2 instanceof Iterable) {</span>
<span class="fc" id="L297">				Iterator&lt;?&gt; i1 = ((Iterable&lt;?&gt;) o1).iterator();</span>
<span class="fc" id="L298">				Iterator&lt;?&gt; i2 = ((Iterable&lt;?&gt;) o2).iterator();</span>
<span class="fc bfc" id="L299" title="All 2 branches covered.">				while (i1.hasNext()) {</span>
<span class="fc bfc" id="L300" title="All 2 branches covered.">					if (!i2.hasNext())</span>
<span class="fc" id="L301">						return false;</span>
<span class="fc bfc" id="L302" title="All 2 branches covered.">					if (!equals(i1.next(), i2.next()))</span>
<span class="fc" id="L303">						return false;</span>
				}
<span class="fc bfc" id="L305" title="All 2 branches covered.">				if (i2.hasNext())</span>
<span class="fc" id="L306">					return false;</span>
<span class="fc" id="L307">				return true;</span>
<span class="fc bfc" id="L308" title="All 4 branches covered.">			} else if ((o1 instanceof Map &amp;&amp; o2 instanceof Map)) {</span>
<span class="fc" id="L309">				Map&lt;?, ?&gt; m1 = (Map&lt;?, ?&gt;) o1;</span>
<span class="fc" id="L310">				Map&lt;?, ?&gt; m2 = (Map&lt;?, ?&gt;) o2;</span>
<span class="fc bfc" id="L311" title="All 2 branches covered.">				if (!equals(m1.keySet(), m2.keySet()))</span>
<span class="fc" id="L312">					return false;</span>
<span class="fc bfc" id="L313" title="All 2 branches covered.">				for (Object k : m1.keySet())</span>
<span class="fc bfc" id="L314" title="All 2 branches covered.">					if (!equals(m1.get(k), m2.get(k)))</span>
<span class="fc" id="L315">						return false;</span>
<span class="fc" id="L316">				return true;</span>
			} else
<span class="fc" id="L318">				return false;</span>

<span class="fc bfc" id="L320" title="All 2 branches covered.">		if (o1 instanceof boolean[])</span>
<span class="fc" id="L321">			return Arrays.equals((boolean[]) o1, (boolean[]) o2);</span>
<span class="fc bfc" id="L322" title="All 2 branches covered.">		if (o1 instanceof byte[])</span>
<span class="fc" id="L323">			return Arrays.equals((byte[]) o1, (byte[]) o2);</span>
<span class="fc bfc" id="L324" title="All 2 branches covered.">		if (o1 instanceof char[])</span>
<span class="fc" id="L325">			return Arrays.equals((char[]) o1, (char[]) o2);</span>
<span class="fc bfc" id="L326" title="All 2 branches covered.">		if (o1 instanceof double[])</span>
<span class="fc" id="L327">			return Arrays.equals((double[]) o1, (double[]) o2);</span>
<span class="fc bfc" id="L328" title="All 2 branches covered.">		if (o1 instanceof float[])</span>
<span class="fc" id="L329">			return Arrays.equals((float[]) o1, (float[]) o2);</span>
<span class="fc bfc" id="L330" title="All 2 branches covered.">		if (o1 instanceof int[])</span>
<span class="fc" id="L331">			return Arrays.equals((int[]) o1, (int[]) o2);</span>
<span class="fc bfc" id="L332" title="All 2 branches covered.">		if (o1 instanceof long[])</span>
<span class="fc" id="L333">			return Arrays.equals((long[]) o1, (long[]) o2);</span>
<span class="fc bfc" id="L334" title="All 2 branches covered.">		if (o1 instanceof short[])</span>
<span class="fc" id="L335">			return Arrays.equals((short[]) o1, (short[]) o2);</span>
<span class="fc bfc" id="L336" title="All 2 branches covered.">		if (o1.getClass().isArray()) {</span>
<span class="fc" id="L337">			int l1 = Array.getLength(o1);</span>
<span class="fc" id="L338">			int l2 = Array.getLength(o2);</span>
<span class="fc bfc" id="L339" title="All 2 branches covered.">			if (l1 != l2)</span>
<span class="fc" id="L340">				return false;</span>
<span class="fc bfc" id="L341" title="All 2 branches covered.">			for (int i = 0; i &lt; l1; i++)</span>
<span class="fc bfc" id="L342" title="All 2 branches covered.">				if (!equals(Array.get(o1, i), Array.get(o2, i)))</span>
<span class="fc" id="L343">					return false;</span>
<span class="fc" id="L344">			return true;</span>
		}

<span class="fc" id="L347">		return o1.equals(o2);</span>
	}

	private IuObject() {
	};

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.10.202304240956</span></div></body></html>