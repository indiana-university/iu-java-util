<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>IuPooledConnection.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">IU Database Connection Pools</a> &gt; <a href="index.source.html" class="el_package">edu.iu.jdbc.pool</a> &gt; <span class="el_source">IuPooledConnection.java</span></div><h1>IuPooledConnection.java</h1><pre class="source lang-java linenums">package edu.iu.jdbc.pool;

import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;
import java.sql.CallableStatement;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.SQLException;
import java.time.Duration;
import java.time.Instant;
import java.util.ArrayDeque;
import java.util.HashMap;
import java.util.Map;
import java.util.Objects;
import java.util.Queue;
import java.util.WeakHashMap;
import java.util.concurrent.ConcurrentLinkedQueue;
import java.util.concurrent.ScheduledFuture;
import java.util.concurrent.ScheduledThreadPoolExecutor;
import java.util.concurrent.ThreadFactory;
import java.util.concurrent.TimeUnit;
import java.util.function.Consumer;
import java.util.logging.Level;
import java.util.logging.Logger;

import javax.sql.ConnectionEvent;
import javax.sql.ConnectionEventListener;
import javax.sql.PooledConnection;
import javax.sql.StatementEvent;
import javax.sql.StatementEventListener;

import edu.iu.IuException;
import edu.iu.IuObject;
import edu.iu.UnsafeFunction;

/**
 * Generic {@link PooledConnection} implementation.
 */
public class IuPooledConnection implements PooledConnection, ConnectionEventListener, StatementEventListener {

<span class="fc" id="L42">	private static final Logger LOG = Logger.getLogger(IuPooledConnection.class.getName());</span>

<span class="fc" id="L44">	private static final ClassLoader JAVA_SQL_LOADER = Connection.class.getClassLoader();</span>
<span class="fc" id="L45">	private static final Class&lt;?&gt;[] CONNECTION_PROXY_INTERFACES = new Class&lt;?&gt;[] { Connection.class };</span>
	private static final ScheduledThreadPoolExecutor REAPER_SCHEDULER;

	static {
<span class="fc" id="L49">		final var threadGroup = new ThreadGroup(&quot;iu-java-jdbc-pool-reaper&quot;);</span>
<span class="fc" id="L50">		final var threadFactory = new ThreadFactory() {</span>
			private int num;

			@Override
			public Thread newThread(Runnable r) {
<span class="fc" id="L55">				final var thread = new Thread(threadGroup, r, &quot;iu-java-jdbc-pool-reaper/&quot; + (++num));</span>
<span class="fc" id="L56">				thread.setDaemon(true);</span>
<span class="fc" id="L57">				return thread;</span>
			}
		};
<span class="fc" id="L60">		REAPER_SCHEDULER = new ScheduledThreadPoolExecutor(4, threadFactory);</span>
<span class="fc" id="L61">	}</span>

	/**
	 * Hash key for {@link PreparedStatement} initialization args.
	 */
	static class StatementKey {
		private final Class&lt;? extends PreparedStatement&gt; type;
		private final Object[] args;

		/**
		 * Constructor.
		 * 
		 * @param type {@link PreparedStatement} or {@link CallableStatement}
		 * @param args arguments to be passed to
		 *             {@link Method#invoke(Object, Object...)} after a cache miss.
		 */
<span class="fc" id="L77">		StatementKey(Class&lt;? extends PreparedStatement&gt; type, Object[] args) {</span>
<span class="fc" id="L78">			this.type = type;</span>
<span class="fc" id="L79">			this.args = args;</span>
<span class="fc" id="L80">		}</span>

		@Override
		public int hashCode() {
<span class="fc" id="L84">			return IuObject.hashCode(type, args);</span>
		}

		@Override
		public boolean equals(Object obj) {
<span class="fc bfc" id="L89" title="All 2 branches covered.">			if (!IuObject.typeCheck(this, obj))</span>
<span class="fc" id="L90">				return false;</span>
<span class="fc" id="L91">			StatementKey other = (StatementKey) obj;</span>
<span class="fc bfc" id="L92" title="All 4 branches covered.">			return type == other.type &amp;&amp; IuObject.equals(args, other.args);</span>
		}
	}

	private class ConnectionHandler implements InvocationHandler {

		private final Connection delegate;

<span class="fc" id="L100">		private ConnectionHandler(Connection delegate) {</span>
<span class="fc" id="L101">			this.delegate = delegate;</span>
<span class="fc" id="L102">		}</span>

		@Override
		public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
<span class="fc" id="L106">			final var returnType = method.getReturnType();</span>

			final StatementKey statementKey;
<span class="fc bfc" id="L109" title="All 2 branches covered.">			if (PreparedStatement.class.isAssignableFrom(returnType)) {</span>
<span class="fc" id="L110">				statementKey = new StatementKey(returnType.asSubclass(PreparedStatement.class), args);</span>

<span class="fc" id="L112">				synchronized (reusableStatements) {</span>
<span class="fc" id="L113">					Queue&lt;PreparedStatement&gt; cachedStatements = reusableStatements.get(statementKey);</span>
<span class="fc bfc" id="L114" title="All 2 branches covered.">					if (cachedStatements != null) {</span>
<span class="fc" id="L115">						final var cachedStatement = cachedStatements.poll();</span>
<span class="fc bfc" id="L116" title="All 2 branches covered.">						if (cachedStatements.isEmpty())</span>
<span class="fc" id="L117">							reusableStatements.remove(statementKey);</span>

<span class="fc" id="L119">						handleStatementReused(cachedStatement);</span>
<span class="fc" id="L120">						return cachedStatement;</span>
					}
<span class="fc" id="L122">				}</span>

			} else
<span class="fc" id="L125">				statementKey = null;</span>

<span class="fc" id="L127">			final var rv = IuException.checkedInvocation(() -&gt; method.invoke(delegate, args));</span>

<span class="fc bfc" id="L129" title="All 2 branches covered.">			if (statementKey != null) {</span>
<span class="fc" id="L130">				final var statement = (PreparedStatement) rv;</span>
<span class="fc" id="L131">				handleStatementOpened(statement);</span>

<span class="fc" id="L133">				synchronized (statementReverseIndex) {</span>
<span class="fc" id="L134">					statementReverseIndex.put(statement, statementKey);</span>
<span class="fc" id="L135">				}</span>
			}

<span class="fc" id="L138">			return rv;</span>
		}
	}

<span class="fc" id="L142">	private final Queue&lt;ConnectionEventListener&gt; connectionEventListeners = new ConcurrentLinkedQueue&lt;&gt;();</span>
<span class="fc" id="L143">	private final Queue&lt;StatementEventListener&gt; statementEventListeners = new ConcurrentLinkedQueue&lt;&gt;();</span>
<span class="fc" id="L144">	private final Map&lt;StatementKey, Queue&lt;PreparedStatement&gt;&gt; reusableStatements = new HashMap&lt;&gt;();</span>
<span class="fc" id="L145">	private final Map&lt;PreparedStatement, StatementKey&gt; statementReverseIndex = new WeakHashMap&lt;&gt;();</span>
<span class="fc" id="L146">	private final ConnectionEvent connectionClosedEvent = new ConnectionEvent(this);</span>

	private final Instant connectionInitiated;
<span class="fc" id="L149">	private final Instant connectionOpened = Instant.now();</span>
	private final PooledConnection physicalConnection;
	private final UnsafeFunction&lt;Connection, Connection&gt; connectionInitializer;
	private final Duration abandonedConnectionTimeout;
	private final Consumer&lt;IuPooledConnection&gt; onClose;

	private volatile boolean validated;
	private volatile Connection connection;
	private volatile Instant logicalConnectionOpened;
	private volatile ScheduledFuture&lt;?&gt; reaper;
	private volatile Throwable error;
	private volatile boolean closed;

	private volatile Instant lastTransactionSegmentStarted;
	private volatile Instant lastTransactionSegmentEnded;
	private volatile Duration averageTransactionSegmentDuration;
	private volatile Duration maxTransactionSegmentDuration;
	private volatile long transactionSegmentCount;

	/**
	 * Constructor.
	 * 
	 * @param initTime                   {@link Instant} the physical connection was
	 *                                   initiated
	 * @param abandonedConnectionTimeout {@link Duration} after
	 *                                   {@link #getConnection()} is invoked when
	 *                                   the connection will be considered abandoned
	 *                                   and removed from the pool
	 * @param physicalConnection         {@link PooledConnection} downstream
	 *                                   physical connection
	 * @param connectionInitializer      From
	 *                                   {@link IuCommonDataSource#setConnectionInitializer(UnsafeFunction)}
	 * @param onClose                    receives a handle to this pooled connection
	 *                                   decorator when {@link #close()} is invoked
	 */
	public IuPooledConnection(Instant initTime, PooledConnection physicalConnection,
			UnsafeFunction&lt;Connection, Connection&gt; connectionInitializer, Duration abandonedConnectionTimeout,
<span class="fc" id="L186">			Consumer&lt;IuPooledConnection&gt; onClose) {</span>
<span class="fc" id="L187">		this.connectionInitiated = initTime;</span>
<span class="fc" id="L188">		this.physicalConnection = physicalConnection;</span>
<span class="fc" id="L189">		this.connectionInitializer = connectionInitializer;</span>
<span class="fc" id="L190">		this.abandonedConnectionTimeout = abandonedConnectionTimeout;</span>
<span class="fc" id="L191">		this.onClose = onClose;</span>

<span class="fc" id="L193">		physicalConnection.addConnectionEventListener(this);</span>
<span class="fc" id="L194">		physicalConnection.addStatementEventListener(this);</span>
<span class="fc" id="L195">	}</span>

	@Override
	public synchronized Connection getConnection() throws SQLException {
<span class="fc bfc" id="L199" title="All 2 branches covered.">		if (closed) {</span>
<span class="fc" id="L200">			final var closedError = new IllegalStateException(&quot;closed&quot;);</span>
<span class="fc bfc" id="L201" title="All 2 branches covered.">			if (error != null)</span>
<span class="fc" id="L202">				closedError.initCause(error);</span>
<span class="fc" id="L203">			throw closedError;</span>
		}

<span class="fc bfc" id="L206" title="All 2 branches covered.">		if (connection != null)</span>
<span class="fc bfc" id="L207" title="All 2 branches covered.">			if (validated) {</span>
<span class="fc" id="L208">				validated = false;</span>
<span class="fc" id="L209">				return connection;</span>
			} else
<span class="fc" id="L211">				throw new IllegalStateException(&quot;already connected&quot;);</span>

<span class="fc" id="L213">		final var newConnection = physicalConnection.getConnection();</span>
<span class="fc" id="L214">		LOG.finer(() -&gt; &quot;jdbc-pool-logical-open:&quot; + newConnection + &quot;; &quot; + this);</span>

<span class="fc" id="L216">		final var openTrace = new Throwable(&quot;opened by&quot;);</span>
<span class="fc" id="L217">		reaper = REAPER_SCHEDULER.schedule(() -&gt; {</span>
			try {
<span class="fc" id="L219">				afterLogicalClose();</span>
<span class="fc" id="L220">				close();</span>
<span class="fc" id="L221">				LOG.log(Level.INFO, openTrace, () -&gt; &quot;jdbc-pool-reaper-close:&quot; + newConnection);</span>
<span class="fc" id="L222">			} catch (Throwable e) {</span>
<span class="fc" id="L223">				LOG.log(Level.WARNING, e, () -&gt; &quot;jdbc-pool-reaper-fail:&quot; + newConnection);</span>
<span class="fc" id="L224">			}</span>
<span class="fc" id="L225">		}, abandonedConnectionTimeout.toMillis(), TimeUnit.MILLISECONDS);</span>

<span class="fc bfc" id="L227" title="All 2 branches covered.">		if (connectionInitializer != null) {</span>
<span class="fc" id="L228">			final var initializedConnection = IuException.checked(SQLException.class, newConnection,</span>
					connectionInitializer);
<span class="fc bfc" id="L230" title="All 2 branches covered.">			if (newConnection != initializedConnection.unwrap(Connection.class))</span>
<span class="fc" id="L231">				throw new SQLException(</span>
						&quot;Invalid connection initializer; unwrap(Connection.class) must return original connection&quot;);
<span class="fc" id="L233">			connection = initializedConnection;</span>
<span class="fc" id="L234">		} else</span>
<span class="fc" id="L235">			connection = newConnection;</span>

<span class="fc" id="L237">		logicalConnectionOpened = Instant.now();</span>

<span class="fc" id="L239">		return (Connection) Proxy.newProxyInstance(JAVA_SQL_LOADER, CONNECTION_PROXY_INTERFACES,</span>
				new ConnectionHandler(connection));
	}

	@Override
	public void addConnectionEventListener(ConnectionEventListener listener) {
<span class="fc" id="L245">		connectionEventListeners.add(listener);</span>
<span class="fc" id="L246">	}</span>

	@Override
	public void connectionClosed(ConnectionEvent event) {
<span class="fc" id="L250">		Objects.requireNonNull(connection, &quot;not connected&quot;);</span>

<span class="fc" id="L252">		final var connection = this.connection;</span>
<span class="fc" id="L253">		afterLogicalClose();</span>
<span class="fc" id="L254">		LOG.finer(() -&gt; &quot;jdbc-pool-logical-close:&quot; + connection + &quot;; &quot; + this);</span>

<span class="fc" id="L256">		connectionEventListeners.parallelStream().forEach(a -&gt; a.connectionClosed(connectionClosedEvent));</span>
<span class="fc" id="L257">	}</span>

	@Override
	public void connectionErrorOccurred(ConnectionEvent event) {
<span class="fc" id="L261">		final var error = event.getSQLException();</span>
<span class="fc bfc" id="L262" title="All 2 branches covered.">		if (connection != null) {</span>
<span class="fc" id="L263">			final var connection = this.connection;</span>
<span class="fc" id="L264">			afterLogicalClose();</span>
<span class="fc" id="L265">			LOG.log(Level.INFO, error, () -&gt; &quot;jdbc-pool-logical-close:&quot; + connection + &quot;; &quot; + this);</span>
		}
<span class="fc" id="L267">		afterPhysicalClose(error);</span>

<span class="fc" id="L269">		final var decoratedEvent = new ConnectionEvent(this, error);</span>
<span class="fc" id="L270">		connectionEventListeners.parallelStream().forEach(a -&gt; a.connectionErrorOccurred(decoratedEvent));</span>
<span class="fc" id="L271">	}</span>

	@Override
	public void removeConnectionEventListener(ConnectionEventListener listener) {
<span class="fc" id="L275">		connectionEventListeners.remove(listener);</span>
<span class="fc" id="L276">	}</span>

	@Override
	public void addStatementEventListener(StatementEventListener listener) {
<span class="fc" id="L280">		statementEventListeners.add(listener);</span>
<span class="fc" id="L281">	}</span>

	@Override
	public void statementClosed(StatementEvent event) {
<span class="fc" id="L285">		final var statement = event.getStatement();</span>
<span class="fc" id="L286">		LOG.finer(() -&gt; &quot;jdbc-pool-statement-close:&quot; + connection + ':' + statement + &quot;; &quot; + this);</span>

<span class="fc" id="L288">		final var decoratedEvent = new StatementEvent(this, statement);</span>
<span class="fc" id="L289">		statementEventListeners.parallelStream().forEach(a -&gt; a.statementClosed(decoratedEvent));</span>

<span class="fc" id="L291">		final var statementKey = statementReverseIndex.get(statement);</span>
<span class="fc bfc" id="L292" title="All 2 branches covered.">		if (statementKey != null)</span>
<span class="fc" id="L293">			synchronized (reusableStatements) {</span>
<span class="fc" id="L294">				var cachedStatements = reusableStatements.get(statementKey);</span>
<span class="fc bfc" id="L295" title="All 2 branches covered.">				if (cachedStatements == null)</span>
<span class="fc" id="L296">					reusableStatements.put(statementKey, cachedStatements = new ArrayDeque&lt;&gt;());</span>
<span class="fc" id="L297">				cachedStatements.offer(statement);</span>
<span class="fc" id="L298">			}</span>
<span class="fc" id="L299">	}</span>

	@Override
	public void statementErrorOccurred(StatementEvent event) {
<span class="fc" id="L303">		final var statement = event.getStatement();</span>
<span class="fc" id="L304">		final var error = event.getSQLException();</span>
<span class="fc" id="L305">		LOG.log(Level.INFO, error, () -&gt; &quot;jdbc-pool-statement-error:&quot; + connection + ':' + statement + &quot;; &quot; + this);</span>

<span class="fc" id="L307">		final var decoratedEvent = new StatementEvent(this, statement, error);</span>
<span class="fc" id="L308">		statementEventListeners.parallelStream().forEach(a -&gt; a.statementErrorOccurred(decoratedEvent));</span>

<span class="fc" id="L310">		synchronized (statementReverseIndex) {</span>
<span class="fc" id="L311">			statementReverseIndex.remove(statement);</span>
<span class="fc" id="L312">		}</span>

<span class="fc" id="L314">		synchronized (reusableStatements) {</span>
<span class="fc" id="L315">			final var i = reusableStatements.values().iterator();</span>
<span class="fc bfc" id="L316" title="All 2 branches covered.">			while (i.hasNext()) {</span>
<span class="fc" id="L317">				final var q = i.next();</span>
<span class="fc bfc" id="L318" title="All 2 branches covered.">				if (q.remove(statement) //</span>
<span class="fc bfc" id="L319" title="All 2 branches covered.">						&amp;&amp; q.isEmpty())</span>
<span class="fc" id="L320">					i.remove();</span>
<span class="fc" id="L321">			}</span>
<span class="fc" id="L322">		}</span>
<span class="fc" id="L323">	}</span>

	@Override
	public void removeStatementEventListener(StatementEventListener listener) {
<span class="fc" id="L327">		statementEventListeners.remove(listener);</span>
<span class="fc" id="L328">	}</span>

	@Override
	public synchronized void close() throws SQLException {
		final Throwable closeError;
<span class="fc bfc" id="L333" title="All 2 branches covered.">		if (!closed)</span>
<span class="fc" id="L334">			closeError = IuException.suppress(null, physicalConnection::close);</span>
		else
<span class="fc" id="L336">			closeError = null;</span>

<span class="fc" id="L338">		Throwable error = closeError;</span>
<span class="fc bfc" id="L339" title="All 2 branches covered.">		if (connection != null)</span>
<span class="fc" id="L340">			error = IuException.suppress(error, () -&gt; afterLogicalClose());</span>
<span class="fc" id="L341">		error = IuException.suppress(error, () -&gt; afterPhysicalClose(closeError));</span>

<span class="fc bfc" id="L343" title="All 2 branches covered.">		if (error != null)</span>
<span class="fc" id="L344">			throw IuException.checked(error, SQLException.class);</span>
<span class="fc" id="L345">	}</span>

	@Override
	public String toString() {
<span class="fc" id="L349">		return &quot;IuPooledConnection [&quot; //</span>
				+ &quot;connectionInitiated=&quot; + connectionInitiated //
				+ &quot;, connectionOpened=&quot; + connectionOpened //
				+ &quot;, physicalConnection=&quot; + physicalConnection //
				+ &quot;, connection=&quot; + connection //
				+ &quot;, logicalConnectionOpened=&quot; + logicalConnectionOpened //
				+ &quot;, lastTransactionSegmentStarted=&quot; + lastTransactionSegmentStarted //
				+ &quot;, lastTransactionSegmentEnded=&quot; + lastTransactionSegmentEnded //
				+ &quot;, averageTransactionSegmentDuration=&quot; + averageTransactionSegmentDuration //
				+ &quot;, maxTransactionSegmentDuration=&quot; + maxTransactionSegmentDuration //
				+ &quot;, transactionSegmentCount=&quot; + transactionSegmentCount //
				+ &quot;, closed=&quot; + closed + &quot;]&quot;;
	}

	/**
	 * Gets the {@link Instant} the connection factory initiated this physical
	 * connection.
	 * 
	 * @return {@link Instant}
	 */
	public Instant connectionInitiated() {
<span class="fc" id="L370">		return connectionInitiated;</span>
	}

	/**
	 * Gets the {@link Instant} the connection factory opened this physical
	 * connection.
	 * 
	 * @return {@link Instant}
	 */
	public Instant connectionOpened() {
<span class="fc" id="L380">		return connectionOpened;</span>
	}

	/**
	 * Gets the {@link Instant} the logical connection associated with this physical
	 * connection was opened.
	 * 
	 * @return {@link Instant}
	 */
	public Instant logicalConnectionOpened() {
<span class="fc" id="L390">		return logicalConnectionOpened;</span>
	}

	/**
	 * Gets the start {@link Instant} of the last transaction segment completed on
	 * this physical connection.
	 * 
	 * @return {@link Instant}
	 */
	public Instant lastTransactionSegmentStarted() {
<span class="fc" id="L400">		return lastTransactionSegmentStarted;</span>
	}

	/**
	 * Gets the end {@link Instant} of the last transaction segment completed on
	 * this physical connection.
	 * 
	 * @return {@link Instant}
	 */
	public Instant lastTransactionSegmentEnded() {
<span class="fc" id="L410">		return lastTransactionSegmentEnded;</span>
	}

	/**
	 * Gets the average {@link Duration} of the transaction segments completed via
	 * this physical connection.
	 * 
	 * @return {@link Duration}
	 */
	public Duration averageTransactionSegmentDuration() {
<span class="fc" id="L420">		return averageTransactionSegmentDuration;</span>
	}

	/**
	 * Gets the average {@link Duration} of the transaction segments completed via
	 * this physical connection.
	 * 
	 * @return {@link Duration}
	 */
	public Duration maxTransactionSegmentDuration() {
<span class="fc" id="L430">		return maxTransactionSegmentDuration;</span>
	}

	/**
	 * Gets the number of times this connection has been used.
	 * 
	 * @return {@link long}
	 */
	public long transactionSegmentCount() {
<span class="fc" id="L439">		return transactionSegmentCount;</span>
	}

	/**
	 * Gets the error that invalidated this connection, if invalid due to an error.
	 * 
	 * @return {@link SQLException}; null if the connection has not experienced a
	 *         error
	 */
	Throwable error() {
<span class="fc" id="L449">		return error;</span>
	}

	/**
	 * Pre-emptively establishes and validates the logical connection.
	 * 
	 * @param validationQuery SQL to execute on the connection, &lt;em&gt;should&lt;/em&gt;
	 *                        produce at least one row with a non-null value in the
	 *                        first column
	 * @throws SQLException if the logical connection cannot be established or the
	 *                      validation query fails
	 */
	synchronized void validate(String validationQuery) throws SQLException {
<span class="fc" id="L462">		final var c = getConnection();</span>

<span class="fc" id="L464">		try (final var s = c.createStatement(); //</span>
<span class="fc" id="L465">				final var r = s.executeQuery(validationQuery)) {</span>
<span class="fc bfc" id="L466" title="All 4 branches covered.">			if (!r.next() || r.getObject(1) == null) {</span>
<span class="fc" id="L467">				final var error = new SQLException(</span>
						&quot;Validation query failed to produce a non-null result: &quot; + validationQuery + &quot;; &quot; + this);
<span class="fc" id="L469">				connectionErrorOccurred(new ConnectionEvent(this, error));</span>
<span class="fc" id="L470">				throw error;</span>
			}
		}

<span class="fc" id="L474">		validated = true;</span>
<span class="fc" id="L475">	}</span>

	private void handleStatementOpened(PreparedStatement statement) {
<span class="fc" id="L478">		LOG.finer(() -&gt; &quot;jdbc-pool-statement-open:&quot; + connection + ':' + statement + &quot;; &quot; + this);</span>
<span class="fc" id="L479">	}</span>

	private void handleStatementReused(PreparedStatement statement) {
<span class="fc" id="L482">		LOG.finer(() -&gt; &quot;jdbc-pool-statement-reuse:&quot; + connection + ':' + statement + &quot;; &quot; + this);</span>
<span class="fc" id="L483">	}</span>

	private synchronized void afterLogicalClose() {
<span class="fc" id="L486">		Objects.requireNonNull(connection);</span>
<span class="pc bpc" id="L487" title="1 of 2 branches missed.">		if (reaper != null) {</span>
<span class="fc" id="L488">			reaper.cancel(false);</span>
<span class="fc" id="L489">			reaper = null;</span>
		}

<span class="fc" id="L492">		connection = null;</span>

<span class="fc" id="L494">		lastTransactionSegmentStarted = Objects.requireNonNull(logicalConnectionOpened);</span>
<span class="fc" id="L495">		logicalConnectionOpened = null;</span>

<span class="fc" id="L497">		lastTransactionSegmentEnded = Instant.now();</span>
<span class="fc" id="L498">		final var transactionTime = Duration.between(lastTransactionSegmentStarted, lastTransactionSegmentEnded);</span>
<span class="fc bfc" id="L499" title="All 4 branches covered.">		if (maxTransactionSegmentDuration == null || maxTransactionSegmentDuration.compareTo(transactionTime) &lt; 0)</span>
<span class="fc" id="L500">			maxTransactionSegmentDuration = transactionTime;</span>

<span class="fc bfc" id="L502" title="All 2 branches covered.">		if (averageTransactionSegmentDuration == null)</span>
<span class="fc" id="L503">			averageTransactionSegmentDuration = transactionTime;</span>
		else
<span class="fc" id="L505">			averageTransactionSegmentDuration = (averageTransactionSegmentDuration.multipliedBy(transactionSegmentCount)</span>
<span class="fc" id="L506">					.plus(transactionTime)).dividedBy(transactionSegmentCount + 1);</span>

<span class="fc" id="L508">		transactionSegmentCount++;</span>
<span class="fc" id="L509">	}</span>

	private synchronized void afterPhysicalClose(Throwable error) {
<span class="fc bfc" id="L512" title="All 2 branches covered.">		if (!closed) {</span>
<span class="fc" id="L513">			this.error = error;</span>
<span class="fc" id="L514">			onClose.accept(this);</span>
<span class="fc" id="L515">			closed = true;</span>
		} else
<span class="fc" id="L517">			return;</span>
<span class="fc" id="L518">	}</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.10.202304240956</span></div></body></html>