<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>IuAsynchronousSubject.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">IU Java Utilities API Reference</a> &gt; <a href="../index.html" class="el_bundle">iu-java-base</a> &gt; <a href="index.source.html" class="el_package">edu.iu</a> &gt; <span class="el_source">IuAsynchronousSubject.java</span></div><h1>IuAsynchronousSubject.java</h1><pre class="source lang-java linenums">/*
 * Copyright Â© 2023 Indiana University
 * All rights reserved.
 *
 * BSD 3-Clause License
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 
 * - Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 * 
 * - Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 * 
 * - Neither the name of the copyright holder nor the names of its
 *   contributors may be used to endorse or promote products derived from
 *   this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package edu.iu;

import java.time.Duration;
import java.time.Instant;
import java.util.Queue;
import java.util.Spliterator;
import java.util.concurrent.ConcurrentLinkedDeque;
import java.util.concurrent.ConcurrentLinkedQueue;
import java.util.concurrent.TimeoutException;
import java.util.function.Consumer;
import java.util.function.Supplier;
import java.util.stream.Stream;
import java.util.stream.StreamSupport;

/**
 * Provides &lt;strong&gt;subscriber&lt;/strong&gt; {@link Stream} instances over a shared
 * source &lt;strong&gt;subject&lt;/strong&gt;.
 * 
 * &lt;p&gt;
 * Each &lt;strong&gt;subject&lt;/strong&gt; is backed externally by a &lt;strong&gt;controlling
 * component&lt;/strong&gt; that:
 * &lt;/p&gt;
 * &lt;ul&gt;
 * &lt;li&gt;Provides an &lt;strong&gt;initial {@link Spliterator split}&lt;/strong&gt; of
 * available values at the point in time a new {@link #subscribe() subscription}
 * is created.&lt;/li&gt;
 * &lt;li&gt;{@link #accept(Object) Accepts} new values to be distributed to active
 * &lt;strong&gt;subscribers&lt;/strong&gt;.&lt;/li&gt;
 * &lt;/ul&gt;
 * 
 * &lt;p&gt;
 * After the &lt;strong&gt;initial {@link Spliterator split}&lt;/strong&gt; is created, but
 * before the values available at {@link #subscribe() subscription} time have
 * all been {@link Spliterator#tryAdvance(Consumer) advanced}, newly
 * {@link #accept(Object) accepted} values are offered to a queue. Values
 * &lt;em&gt;may&lt;/em&gt; be removed from the queue if also advanced from the initial
 * split. Queued values will be polled and advanced after the last split of the
 * initial split advances its last value.
 * &lt;/p&gt;
 * 
 * &lt;p&gt;
 * After all queued values have been advanced, the &lt;strong&gt;subscriber&lt;/strong&gt;
 * transitions to a dedicated {@link IuAsynchronousPipe} and passes new values
 * through to {@link IuAsynchronousPipe#accept(Object)}.
 * &lt;/p&gt;
 * 
 * &lt;p&gt;
 * The &lt;strong&gt;subject&lt;/strong&gt; makes no guarantee to the &lt;strong&gt;controlling
 * component&lt;/strong&gt; when or if a &lt;strong&gt;subscriber&lt;/strong&gt; will transition
 * from non-blocking access to available values, to potentially blocking access
 * via {@link IuAsynchronousPipe}. It is, however, guaranteed that all values
 * available from the point in time the &lt;strong&gt;subscriber&lt;/strong&gt; begins
 * processing the {@link Stream} until &lt;strong&gt;unsubscribing&lt;/strong&gt; will be
 * supplied exactly once regardless of how the value is actually delivered.
 * &lt;/p&gt;
 * 
 * &lt;img src=&quot;doc-files/IuAsynchronousSubject.svg&quot; alt=&quot;UML Sequence Diagram&quot;&gt;
 * 
 * &lt;p&gt;
 * New values &lt;em&gt;should&lt;/em&gt; be {@link #accept(Object) accepted} before
 * appending the external source, to gracefully avoid a potential race condition
 * between the initial split and an internal appended values queue. For example:
 * &lt;/p&gt;
 * 
 * &lt;pre&gt;
 * class MyControllingComponent&amp;lt;T&amp;gt; implements Consumer&amp;lt;T&amp;gt; {
 * 	private final Queue&amp;lt;T&amp;gt; queue = new ConcurrentLinkedQueue&amp;lt;&amp;gt;();
 * 	private final IuAsynchronousSubject&amp;lt;T&amp;gt; subject =
 * 		new IuAsynchronousSubject&amp;lt;&amp;gt;(queue::spliterator);
 * 
 * 	{@literal @}Override
 * 	public void accept(T t) {
 * 		subject.accept(t);
 * 		queue.offer(t);
 * 	}
 * }
 * &lt;/pre&gt;
 * 
 * &lt;p&gt;
 * When the &lt;strong&gt;source&lt;/strong&gt; is sequential, &lt;strong&gt;subscribers&lt;/strong&gt;
 * &lt;em&gt;may&lt;/em&gt; expect to receive values in the order supplied.
 * &lt;/p&gt;
 * 
 * &lt;p&gt;
 * Each &lt;strong&gt;subscriber&lt;/strong&gt; {@link Stream} provides all values that may
 * be retrieved without blocking, then transitions to an
 * {@link IuAsynchronousPipe} managed by the &lt;strong&gt;subject&lt;/strong&gt; to block
 * until new values become available.
 * &lt;/p&gt;
 * 
 * &lt;p&gt;
 * A &lt;strong&gt;subscriber's&lt;/strong&gt; {@link Stream} may be {@link Stream#close()
 * closed} without affecting the status of the &lt;strong&gt;controlling
 * component&lt;/strong&gt;, or of any other &lt;strong&gt;subscriber&lt;/strong&gt; {@link Stream
 * streams}.
 * &lt;/p&gt;
 * 
 * &lt;p&gt;
 * This class is thread-safe and intended for use by high-volume
 * parallel-processing workloads.
 * &lt;/p&gt;
 * 
 * @param &lt;T&gt; value type
 * @see IuAsynchronousPipe
 */
public class IuAsynchronousSubject&lt;T&gt; implements Consumer&lt;T&gt;, AutoCloseable {

	private class SourceSplit implements Spliterator&lt;T&gt; {
		private final Subscriber subscriber;
		private volatile Spliterator&lt;T&gt; delegate;

<span class="fc" id="L143">		private SourceSplit(Spliterator&lt;T&gt; delegate, Subscriber subscriber) {</span>
<span class="fc" id="L144">			this.subscriber = subscriber;</span>
<span class="fc" id="L145">			this.delegate = delegate;</span>
<span class="fc" id="L146">			subscriber.children.offer(this);</span>
<span class="fc" id="L147">		}</span>

		@Override
		public boolean tryAdvance(Consumer&lt;? super T&gt; action) {
<span class="fc bfc" id="L151" title="All 2 branches covered.">			if (delegate != null //</span>
<span class="fc bfc" id="L152" title="All 2 branches covered.">					&amp;&amp; delegate.tryAdvance(subscriber.cancelAcceptedValueAfterAction(action))) {</span>

<span class="fc bfc" id="L154" title="All 2 branches covered.">				if (delegate.estimateSize() == 0)</span>
<span class="fc" id="L155">					delegate = null;</span>

<span class="fc" id="L157">				return true;</span>
			} else
<span class="fc" id="L159">				delegate = null;</span>

<span class="fc" id="L161">			return subscriber.continueAdvance(action);</span>
		}

		@Override
		public void forEachRemaining(Consumer&lt;? super T&gt; action) {
<span class="fc bfc" id="L166" title="All 2 branches covered.">			if (delegate != null) {</span>
<span class="fc" id="L167">				delegate.forEachRemaining(subscriber.cancelAcceptedValueAfterAction(action));</span>
<span class="fc" id="L168">				delegate = null;</span>
			}

<span class="fc" id="L171">			subscriber.continueForEach(action);</span>
<span class="fc" id="L172">		}</span>

		@Override
		public Spliterator&lt;T&gt; trySplit() {
<span class="fc bfc" id="L176" title="All 2 branches covered.">			if (delegate == null)</span>
<span class="fc" id="L177">				return null;</span>

<span class="fc" id="L179">			final var split = delegate.trySplit();</span>
<span class="fc bfc" id="L180" title="All 2 branches covered.">			if (split == null)</span>
<span class="fc" id="L181">				return null;</span>
			else
<span class="fc" id="L183">				return new SourceSplit(split, subscriber);</span>
		}

		@Override
		public long estimateSize() {
<span class="fc" id="L188">			var count = 0L;</span>

<span class="fc" id="L190">			final var delegate = this.delegate;</span>
<span class="fc bfc" id="L191" title="All 2 branches covered.">			if (delegate != null)</span>
<span class="fc" id="L192">				count += delegate.estimateSize();</span>

<span class="fc bfc" id="L194" title="All 2 branches covered.">			if (subscriber.isExhausted() //</span>
<span class="fc bfc" id="L195" title="All 2 branches covered.">					|| (subscriber.children.size() == 1 //</span>
<span class="fc bfc" id="L196" title="All 2 branches covered.">							&amp;&amp; subscriber.children.contains(this)))</span>
<span class="fc" id="L197">				count += subscriber.acceptedSize();</span>

<span class="fc" id="L199">			return count;</span>
		}

		@Override
		public int characteristics() {
<span class="fc" id="L204">			final var delegate = this.delegate;</span>
<span class="fc bfc" id="L205" title="All 2 branches covered.">			if (delegate != null)</span>
<span class="fc" id="L206">				return delegate.characteristics();</span>
			else
<span class="fc" id="L208">				return SIZED;</span>
		}

	}

	private class Subscriber implements Spliterator&lt;T&gt;, IuAsynchronousSubscription&lt;T&gt; {
		private final Stream&lt;T&gt; stream;
//		private volatile Source&lt;T&gt; source;
<span class="fc" id="L216">		private final Queue&lt;SourceSplit&gt; children = new ConcurrentLinkedDeque&lt;&gt;();</span>
<span class="fc" id="L217">		private final Queue&lt;T&gt; accepted = new ConcurrentLinkedQueue&lt;&gt;();</span>
		private volatile Spliterator&lt;T&gt; delegate;
		private volatile long acceptedCount;
		private volatile Throwable error;
		private volatile boolean closed;
		private volatile IuAsynchronousPipe&lt;T&gt; pipe;
		private volatile Spliterator&lt;T&gt; pipedSplit;

<span class="fc" id="L225">		private Subscriber() {</span>
<span class="fc" id="L226">			final var delegate = initialSplitSupplier.get();</span>
<span class="fc bfc" id="L227" title="All 2 branches covered.">			if (delegate.estimateSize() &gt; 0)</span>
<span class="fc" id="L228">				this.delegate = delegate;</span>

<span class="fc" id="L230">			subscribers.offer(this);</span>
<span class="fc" id="L231">			stream = StreamSupport.stream(this, false).onClose(this::close);</span>
<span class="fc" id="L232">		}</span>

		@Override
		public Spliterator&lt;T&gt; trySplit() {
<span class="fc" id="L236">			final var delegate = this.delegate;</span>
<span class="fc bfc" id="L237" title="All 2 branches covered.">			if (delegate != null) {</span>
<span class="fc" id="L238">				final var split = delegate.trySplit();</span>
<span class="fc bfc" id="L239" title="All 2 branches covered.">				if (split != null)</span>
<span class="fc" id="L240">					return new SourceSplit(split, this);</span>
			}

<span class="fc bfc" id="L243" title="All 2 branches covered.">			if (error != null)</span>
<span class="fc" id="L244">				throw IuException.unchecked(error);</span>
<span class="fc bfc" id="L245" title="All 2 branches covered.">			else if (pipedSplit != null)</span>
<span class="fc" id="L246">				return pipedSplit.trySplit();</span>
			else
<span class="fc" id="L248">				return null;</span>
		}

		@Override
		public boolean tryAdvance(Consumer&lt;? super T&gt; action) {
<span class="fc" id="L253">			final var delegate = this.delegate;</span>
<span class="fc bfc" id="L254" title="All 2 branches covered.">			if (delegate != null //</span>
<span class="fc bfc" id="L255" title="All 2 branches covered.">					&amp;&amp; delegate.tryAdvance(cancelAcceptedValueAfterAction(action))) {</span>

<span class="fc bfc" id="L257" title="All 2 branches covered.">				if (delegate.estimateSize() == 0)</span>
<span class="fc" id="L258">					this.delegate = null;</span>

<span class="fc" id="L260">				return true;</span>
			} else
<span class="fc" id="L262">				this.delegate = null;</span>

<span class="fc bfc" id="L264" title="All 2 branches covered.">			if (continueAdvance(action)) {</span>
<span class="pc bpc" id="L265" title="1 of 2 branches missed.">				if (isExhausted() //</span>
<span class="fc bfc" id="L266" title="All 2 branches covered.">						&amp;&amp; acceptedSize() == 0)</span>
<span class="fc" id="L267">					bootstrapPipe();</span>

<span class="fc" id="L269">				return true;</span>
			}

<span class="fc" id="L272">			bootstrapPipe();</span>

<span class="fc bfc" id="L274" title="All 2 branches covered.">			if (error != null)</span>
<span class="fc" id="L275">				throw IuException.unchecked(error);</span>
<span class="fc bfc" id="L276" title="All 2 branches covered.">			else if (pipedSplit != null)</span>
<span class="fc" id="L277">				return pipedSplit.tryAdvance(action);</span>
			else
<span class="fc" id="L279">				return false;</span>
		}

		@Override
		public void forEachRemaining(Consumer&lt;? super T&gt; action) {
<span class="fc bfc" id="L284" title="All 2 branches covered.">			if (delegate != null) {</span>
<span class="fc" id="L285">				delegate.forEachRemaining(cancelAcceptedValueAfterAction(action));</span>
<span class="fc" id="L286">				delegate = null;</span>
			}

<span class="fc" id="L289">			continueForEach(action);</span>

<span class="fc" id="L291">			bootstrapPipe();</span>

<span class="fc bfc" id="L293" title="All 2 branches covered.">			if (error != null)</span>
<span class="fc" id="L294">				throw IuException.unchecked(error);</span>
<span class="fc bfc" id="L295" title="All 2 branches covered.">			else if (pipedSplit != null)</span>
<span class="fc" id="L296">				pipedSplit.forEachRemaining(action);</span>
<span class="fc" id="L297">		}</span>

		@Override
		public synchronized long available() {
<span class="fc" id="L301">			var count = 0;</span>

<span class="fc bfc" id="L303" title="All 2 branches covered.">			if (delegate != null //</span>
<span class="fc bfc" id="L304" title="All 2 branches covered.">					&amp;&amp; delegate.hasCharacteristics(SIZED))</span>
<span class="fc" id="L305">				count += delegate.estimateSize();</span>

<span class="fc bfc" id="L307" title="All 2 branches covered.">			if (areChildrenExhausted())</span>
<span class="fc" id="L308">				count += acceptedSize();</span>

<span class="fc bfc" id="L310" title="All 2 branches covered.">			if (pipe != null)</span>
<span class="fc" id="L311">				count += pipe.getPendingCount();</span>

<span class="fc" id="L313">			return count;</span>
		}

		@Override
		public synchronized long estimateSize() {
<span class="fc bfc" id="L318" title="All 2 branches covered.">			if (pipedSplit == null) {</span>
<span class="fc bfc" id="L319" title="All 4 branches covered.">				if (!closed &amp;&amp; error == null)</span>
<span class="fc" id="L320">					return Long.MAX_VALUE;</span>
				else
<span class="fc" id="L322">					return available();</span>
			} else
<span class="fc" id="L324">				return pipedSplit.estimateSize();</span>
		}

		@Override
		public int characteristics() {
<span class="fc bfc" id="L329" title="All 2 branches covered.">			if (pipedSplit == null)</span>
<span class="fc bfc" id="L330" title="All 2 branches covered.">				if (!isClosedOrError())</span>
<span class="fc" id="L331">					return CONCURRENT;</span>
				else
<span class="fc" id="L333">					return IMMUTABLE | SIZED;</span>
			else
<span class="fc" id="L335">				return pipedSplit.characteristics();</span>
		}

		@Override
		public Stream&lt;T&gt; stream() {
<span class="fc" id="L340">			return stream;</span>
		}

		@Override
		public long pause(long acceptedCount, Duration timeout) throws TimeoutException, InterruptedException {
<span class="fc bfc" id="L345" title="All 2 branches covered.">			if (acceptedCount &lt;= 0L)</span>
<span class="fc" id="L346">				return 0L;</span>

<span class="fc" id="L348">			final var now = Instant.now();</span>
<span class="fc" id="L349">			final var expires = now.plus(timeout);</span>

<span class="fc" id="L351">			final var initCount = this.acceptedCount;</span>
<span class="fc" id="L352">			final var targetCount = initCount + acceptedCount;</span>
<span class="fc" id="L353">			IuObject.waitFor(this, //</span>
<span class="fc bfc" id="L354" title="All 2 branches covered.">					() -&gt; (pipe != null //</span>
<span class="pc bpc" id="L355" title="1 of 2 branches missed.">							&amp;&amp; pipe.isClosed()) //</span>
<span class="fc bfc" id="L356" title="All 4 branches covered.">							|| isClosedOrError() //</span>
							|| this.acceptedCount &gt;= targetCount //
					, expires);

<span class="fc" id="L360">			return this.acceptedCount - initCount;</span>
		}

		@Override
		public long pause(Instant expires) throws InterruptedException {
<span class="fc" id="L365">			final var initCount = acceptedCount;</span>

<span class="fc" id="L367">			synchronized (this) {</span>
<span class="pc bpc" id="L368" title="1 of 6 branches missed.">				while ((pipe == null || !pipe.isClosed()) &amp;&amp; !isClosedOrError()) {</span>
<span class="fc" id="L369">					final var now = Instant.now();</span>
<span class="fc bfc" id="L370" title="All 2 branches covered.">					if (now.isBefore(expires)) {</span>
<span class="fc" id="L371">						final var waitFor = Duration.between(now, expires);</span>
<span class="fc" id="L372">						this.wait(waitFor.toMillis(), waitFor.toNanosPart() % 1_000_000);</span>
					} else
						break;
<span class="fc" id="L375">				}</span>
<span class="fc" id="L376">			}</span>

<span class="fc" id="L378">			return acceptedCount - initCount;</span>
		}

		@Override
		public synchronized void error(Throwable e) {
<span class="fc bfc" id="L383" title="All 2 branches covered.">			if (pipe != null)</span>
<span class="fc" id="L384">				pipe.error(e);</span>
			else
<span class="fc" id="L386">				error = e;</span>

<span class="fc" id="L388">			this.notifyAll();</span>
<span class="fc" id="L389">		}</span>

		@Override
		public synchronized void close() {
<span class="fc" id="L393">			subscribers.remove(this);</span>

<span class="fc bfc" id="L395" title="All 2 branches covered.">			if (pipe != null)</span>
<span class="fc" id="L396">				pipe.close();</span>
			else
<span class="fc" id="L398">				closed = true;</span>

<span class="fc" id="L400">			this.notifyAll();</span>
<span class="fc" id="L401">		}</span>

		private boolean isClosedOrError() {
<span class="pc bpc" id="L404" title="1 of 4 branches missed.">			return closed //</span>
					|| error != null;
		}

		private Consumer&lt;? super T&gt; cancelAcceptedValueAfterAction(Consumer&lt;? super T&gt; action) {
<span class="fc" id="L409">			return value -&gt; {</span>
<span class="fc" id="L410">				action.accept(value);</span>

<span class="fc" id="L412">				synchronized (this) {</span>
<span class="fc" id="L413">					accepted.remove(value);</span>
<span class="fc" id="L414">					this.notifyAll();</span>
<span class="fc" id="L415">				}</span>
<span class="fc" id="L416">			};</span>
		}

		private boolean continueAdvance(Consumer&lt;? super T&gt; action) {
<span class="fc bfc" id="L420" title="All 2 branches covered.">			if (isExhausted()) {</span>
<span class="fc" id="L421">				final var value = accepted.poll();</span>
<span class="fc bfc" id="L422" title="All 2 branches covered.">				if (value != null) {</span>
<span class="fc" id="L423">					action.accept(value);</span>
<span class="fc" id="L424">					synchronized (this) {</span>
<span class="fc" id="L425">						this.notifyAll();</span>
<span class="fc" id="L426">					}</span>
<span class="fc" id="L427">					return true;</span>
				}
			}
<span class="fc" id="L430">			return false;</span>
		}

		private void continueForEach(Consumer&lt;? super T&gt; action) {
<span class="fc bfc" id="L434" title="All 2 branches covered.">			if (isExhausted()) {</span>
<span class="fc bfc" id="L435" title="All 2 branches covered.">				while (!accepted.isEmpty()) {</span>
<span class="fc" id="L436">					action.accept(accepted.poll());</span>
<span class="fc" id="L437">					synchronized (this) {</span>
<span class="fc" id="L438">						this.notifyAll();</span>
<span class="fc" id="L439">					}</span>
				}
			}
<span class="fc" id="L442">		}</span>

		private int acceptedSize() {
<span class="fc" id="L445">			return accepted.size();</span>
		}

		private boolean areChildrenExhausted() {
<span class="fc" id="L449">			final var i = children.iterator();</span>
<span class="fc bfc" id="L450" title="All 2 branches covered.">			while (i.hasNext())</span>
<span class="fc bfc" id="L451" title="All 2 branches covered.">				if (i.next().delegate == null)</span>
<span class="fc" id="L452">					i.remove();</span>
				else
<span class="fc" id="L454">					return false;</span>

<span class="fc" id="L456">			return true;</span>
		}

		private boolean isExhausted() {
<span class="fc bfc" id="L460" title="All 2 branches covered.">			if (delegate != null)</span>
<span class="fc" id="L461">				return false;</span>

<span class="fc" id="L463">			return areChildrenExhausted();</span>
		}

		private synchronized void bootstrapPipe() {
<span class="fc bfc" id="L467" title="All 6 branches covered.">			if (pipe == null //</span>
					&amp;&amp; error == null //
					&amp;&amp; !closed) {
<span class="fc" id="L470">				pipe = new IuAsynchronousPipe&lt;&gt;();</span>
<span class="fc" id="L471">				pipedSplit = pipe.stream().spliterator();</span>
			}
<span class="fc" id="L473">		}</span>

		private void accept(T t) {
<span class="fc" id="L476">			synchronized (this) {</span>
<span class="fc bfc" id="L477" title="All 4 branches covered.">				if (delegate != null || !accepted.isEmpty())</span>
<span class="fc" id="L478">					accepted.offer(t);</span>
				else {
<span class="fc" id="L480">					bootstrapPipe();</span>
<span class="fc" id="L481">					pipe.accept(t);</span>
				}
<span class="fc" id="L483">				acceptedCount++;</span>
<span class="fc" id="L484">				this.notifyAll();</span>
<span class="fc" id="L485">			}</span>

<span class="fc" id="L487">		}</span>

	}

	private final Supplier&lt;Spliterator&lt;T&gt;&gt; initialSplitSupplier;
<span class="fc" id="L492">	private final Queue&lt;Subscriber&gt; subscribers = new ConcurrentLinkedQueue&lt;&gt;();</span>
	private boolean closed;

	/**
	 * Creates a new &lt;strong&gt;subject&lt;/strong&gt;.
	 * 
	 * @param initialSplitSupplier supplies the initial split backing new
	 *                             &lt;strong&gt;subscriber&lt;/strong&gt; streams.
	 */
<span class="fc" id="L501">	public IuAsynchronousSubject(Supplier&lt;Spliterator&lt;T&gt;&gt; initialSplitSupplier) {</span>
<span class="fc" id="L502">		this.initialSplitSupplier = initialSplitSupplier;</span>
<span class="fc" id="L503">	}</span>

	/**
	 * &lt;strong&gt;Subscribes&lt;/strong&gt; to a {@link Stream} that supplies all values
	 * available without blocking then blocks until new values are available or the
	 * &lt;strong&gt;subject&lt;/strong&gt; is {@link #close() closed}.
	 * 
	 * @return {@link IuAsynchronousSubscription}
	 */
	public IuAsynchronousSubscription&lt;T&gt; subscribe() {
<span class="fc bfc" id="L513" title="All 2 branches covered.">		if (closed)</span>
<span class="fc" id="L514">			throw new IllegalStateException(&quot;closed&quot;);</span>

<span class="fc" id="L516">		return new Subscriber();</span>
	}

	/**
	 * Distributes a value to all potentially blocking &lt;strong&gt;subscribers&lt;/strong&gt;
	 * that have completed the transition to an {@link IuAsynchronousPipe}.
	 * 
	 * &lt;p&gt;
	 * This method does not supply values to &lt;strong&gt;subscribers&lt;/strong&gt; that
	 * haven't yet completed the transition. The &lt;strong&gt;controlling
	 * component&lt;/strong&gt; is responsible for independently supplying those values to
	 * it's {@link Spliterator}-supplying backing &lt;strong&gt;source&lt;/strong&gt;.
	 * &lt;/p&gt;
	 * 
	 * @param value value to supply to all &lt;strong&gt;subscribers&lt;/strong&gt;
	 */
	@Override
	public synchronized void accept(T value) {
<span class="fc bfc" id="L534" title="All 2 branches covered.">		if (closed)</span>
<span class="fc" id="L535">			throw new IllegalStateException(&quot;closed&quot;);</span>

<span class="fc" id="L537">		subscribers.forEach(subscriber -&gt; subscriber.accept(value));</span>
<span class="fc" id="L538">	}</span>

	/**
	 * Closes the &lt;strong&gt;subject&lt;/strong&gt;.
	 * 
	 * &lt;p&gt;
	 * Once closed:
	 * &lt;/p&gt;
	 * &lt;ul&gt;
	 * &lt;li&gt;Existing &lt;strong&gt;subscribers&lt;/strong&gt; may finish retrieving all values
	 * already supplied&lt;/li&gt;
	 * &lt;li&gt;Blocking &lt;strong&gt;subscriber&lt;/strong&gt; {@link Stream}s will be terminated
	 * gracefully&lt;/li&gt;
	 * &lt;li&gt;No new &lt;strong&gt;subscribers&lt;/strong&gt; may be created&lt;/li&gt;
	 * &lt;li&gt;No new &lt;strong&gt;values&lt;/strong&gt; may be supplied&lt;/li&gt;
	 * &lt;/ul&gt;
	 */
	@Override
	public synchronized void close() {
<span class="fc bfc" id="L557" title="All 2 branches covered.">		if (closed)</span>
<span class="fc" id="L558">			return;</span>

<span class="fc" id="L560">		closed = true;</span>

<span class="fc" id="L562">		Throwable e = null;</span>
<span class="fc bfc" id="L563" title="All 2 branches covered.">		while (!subscribers.isEmpty())</span>
<span class="fc" id="L564">			e = IuException.suppress(e, () -&gt; subscribers.poll().close());</span>

<span class="fc bfc" id="L566" title="All 2 branches covered.">		if (e != null)</span>
<span class="fc" id="L567">			throw IuException.unchecked(e);</span>
<span class="fc" id="L568">	}</span>

	/**
	 * Reports a fatal error to all &lt;strong&gt;subscribers&lt;/strong&gt; and {@link #close()
	 * closes} the &lt;strong&gt;subject&lt;/strong&gt;.
	 * 
	 * @param e fatal error
	 */
	public synchronized void error(Throwable e) {
<span class="fc bfc" id="L577" title="All 2 branches covered.">		while (!subscribers.isEmpty())</span>
<span class="fc" id="L578">			IuException.suppress(e, () -&gt; subscribers.poll().error(e));</span>

<span class="fc" id="L580">		closed = true;</span>
<span class="fc" id="L581">	}</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.10.202304240956</span></div></body></html>