<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>IuRuntimeConfiguration.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">IU Java Utilities API Reference</a> &gt; <a href="../index.html" class="el_bundle">iu-java-runtime-api</a> &gt; <a href="index.source.html" class="el_package">edu.iu.runtime</a> &gt; <span class="el_source">IuRuntimeConfiguration.java</span></div><h1>IuRuntimeConfiguration.java</h1><pre class="source lang-java linenums">/*
 * Copyright Â© 2023 Indiana University
 * All rights reserved.
 *
 * BSD 3-Clause License
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 
 * - Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 * 
 * - Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 * 
 * - Neither the name of the copyright holder nor the names of its
 *   contributors may be used to endorse or promote products derived from
 *   this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package edu.iu.runtime;

import java.lang.reflect.GenericArrayType;
import java.lang.reflect.ParameterizedType;
import java.lang.reflect.Type;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.time.Instant;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.LocalTime;
import java.time.Year;
import java.time.YearMonth;
import java.time.ZonedDateTime;
import java.util.Collection;
import java.util.Date;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.SortedSet;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.regex.Pattern;
import java.util.stream.DoubleStream;
import java.util.stream.IntStream;
import java.util.stream.LongStream;
import java.util.stream.Stream;

/**
 * Provides uniform access to runtime configuration.
 * 
 * &lt;h2&gt;Expected Types&lt;/h2&gt;
 * &lt;p&gt;
 * The underlying configuration value must be appropriate for the expected type,
 * otherwise {@link IllegalArgumentException} is thrown.
 * &lt;/p&gt;
 * 
 * &lt;h2&gt;Atomic Types&lt;/h2&gt;
 * &lt;p&gt;
 * The following atomic types &lt;em&gt;must&lt;/em&gt; be supported:
 * &lt;/p&gt;
 * 
 * &lt;ul&gt;
 * &lt;li&gt;{@link BigDecimal}&lt;/li&gt;
 * &lt;li&gt;{@link BigInteger}&lt;/li&gt;
 * &lt;li&gt;{@link Boolean}&lt;/li&gt;
 * &lt;li&gt;{@link Date}&lt;/li&gt;
 * &lt;li&gt;{@link Instant}&lt;/li&gt;
 * &lt;li&gt;{@link Integer}&lt;/li&gt;
 * &lt;li&gt;{@link LocalDate}&lt;/li&gt;
 * &lt;li&gt;{@link LocalDateTime}&lt;/li&gt;
 * &lt;li&gt;{@link LocalTime}&lt;/li&gt;
 * &lt;li&gt;{@link Long}&lt;/li&gt;
 * &lt;li&gt;{@link Number}&lt;/li&gt;
 * &lt;li&gt;{@link Pattern}&lt;/li&gt;
 * &lt;li&gt;{@link String}&lt;/li&gt;
 * &lt;li&gt;{@link Year}&lt;/li&gt;
 * &lt;li&gt;{@link YearMonth}&lt;/li&gt;
 * &lt;li&gt;{@link ZonedDateTime}&lt;/li&gt;
 * &lt;/ul&gt;
 * 
 * &lt;h2&gt;Collection Types&lt;/h2&gt;
 * &lt;p&gt;
 * The following collection types &lt;em&gt;must&lt;/em&gt; be supported:
 * &lt;/p&gt;
 * 
 * &lt;ul&gt;
 * &lt;li&gt;Array&lt;/li&gt;
 * &lt;li&gt;{@link Collection}&lt;/li&gt;
 * &lt;li&gt;{@link DoubleStream}&lt;/li&gt;
 * &lt;li&gt;{@link IntStream}&lt;/li&gt;
 * &lt;li&gt;{@link Iterable}&lt;/li&gt;
 * &lt;li&gt;{@link List}&lt;/li&gt;
 * &lt;li&gt;{@link LongStream}&lt;/li&gt;
 * &lt;li&gt;{@link Set}&lt;/li&gt;
 * &lt;li&gt;{@link SortedSet}&lt;/li&gt;
 * &lt;li&gt;{@link Stream}&lt;/li&gt;
 * &lt;/ul&gt;
 * 
 * &lt;p&gt;
 * When handing collection types, an implementation:
 * &lt;/p&gt;
 * 
 * &lt;ul&gt;
 * &lt;li&gt;&lt;em&gt;Must&lt;/em&gt; convert atomic values from the underlying configuration
 * source to a singleton when a collection type is expected.&lt;/li&gt;
 * 
 * &lt;li&gt;&lt;em&gt;Must&lt;/em&gt; use {@link ParameterizedType},
 * {@link GenericArrayType#getGenericComponentType()}, or
 * {@link Class#getComponentType()} to determine the expected type of items in
 * the collection.&lt;/li&gt;
 * 
 * &lt;li&gt;&lt;em&gt;Must not&lt;/em&gt; return an empty collection instead of throwing
 * {@link IllegalArgumentException} when the reference cannot be resolved.&lt;/li&gt;
 * &lt;/ul&gt;
 * 
 * &lt;h2&gt;Named Value Types&lt;/h2&gt;
 * &lt;p&gt;
 * The following named value collection types &lt;em&gt;must&lt;/em&gt; be supported:
 * &lt;/p&gt;
 *
 * &lt;ul&gt;
 * &lt;li&gt;{@link IuRuntimeConfiguration}&lt;/li&gt;
 * &lt;li&gt;{@link Map}&lt;/li&gt;
 * &lt;/ul&gt;
 * 
 * &lt;p&gt;
 * When handing named value collection types, an implementation:
 * &lt;/p&gt;
 * 
 * &lt;ul&gt;
 * &lt;li&gt;&lt;em&gt;Must&lt;/em&gt; convert atomic types from the underlying configuration
 * source to a singleton with an empty (non-null) name when a named value type
 * is expected and only one value is provided.&lt;/li&gt;
 * 
 * &lt;li&gt;&lt;em&gt;Must&lt;/em&gt; convert collection types from the underlying configuration
 * source to a named value collection using the non-negative integer index
 * values implied by the underlying collection's iterator as names.&lt;/li&gt;
 * 
 * &lt;li&gt;&lt;em&gt;Must&lt;/em&gt; return all configured values relative to the reference when
 * {@link IuRuntimeConfiguration} is used. The resulting configuration must only
 * understand references relative to the resulting configuration.&lt;/li&gt;
 * 
 * &lt;li&gt;&lt;em&gt;Must&lt;/em&gt; use {@link ParameterizedType} to determine the expected
 * type of named values when a generic {@link Map} is used.&lt;/li&gt;
 * 
 * &lt;li&gt;&lt;em&gt;Should&lt;/em&gt; support the use of qualified Java module, package, and
 * type names to resolve specific configuration subsets when using
 * {@link IuRuntimeConfiguration} as the expected type.&lt;/li&gt;
 * &lt;/ul&gt;
 *
 * &lt;h2&gt;Jakarta JSON-P Types&lt;/h2&gt;
 * &lt;p&gt;
 * The following types from the
 * &lt;a href=&quot;https://jakarta.ee/specifications/jsonp/&quot;&gt;Jakarta JSON-P API&lt;/a&gt;
 * &lt;em&gt;should&lt;/em&gt; be supported.
 * &lt;/p&gt;
 * 
 * &lt;ul&gt;
 * &lt;li&gt;JsonArray (collection)&lt;/li&gt;
 * &lt;li&gt;JsonNumber&lt;/li&gt;
 * &lt;li&gt;JsonString&lt;/li&gt;
 * &lt;li&gt;JsonStructure&lt;/li&gt;
 * &lt;li&gt;JsonObject (named value)&lt;/li&gt;
 * &lt;li&gt;JsonPointer&lt;/li&gt;
 * &lt;li&gt;JsonValue&lt;/li&gt;
 * &lt;/ul&gt;
 * 
 * &lt;p&gt;
 * &lt;a href=&quot;https://datatracker.ietf.org/doc/html/rfc6901&quot;&gt;JSON Pointer&lt;/a&gt;
 * &lt;em&gt;should&lt;/em&gt; be a supported configuration reference format.
 * &lt;/p&gt;
 * 
 * &lt;h2&gt;Serialized Form&lt;/h2&gt;
 * &lt;p&gt;
 * All atomic and collection configuration values &lt;em&gt;must&lt;/em&gt; be retrievable
 * using the {@link String} type.
 * &lt;/p&gt;
 * 
 * &lt;ul&gt;
 * &lt;li&gt;Values with an underlying collection type &lt;em&gt;should&lt;/em&gt; use
 * &lt;a href=&quot;https://www.ietf.org/rfc/rfc4180.txt&quot;&gt;CSV&lt;/a&gt; format when converting
 * to {@link String}.&lt;/li&gt;
 * &lt;li&gt;A null value implies that an explicit null was defined by the underlying
 * configuration source.&lt;/li&gt;
 * &lt;li&gt;An empty string value implies an empty collection.&lt;/li&gt;
 * &lt;li&gt;An empty string literal (two double quote characters &quot;&quot;) implies a
 * singleton collection with an empty string value.&lt;/li&gt;
 * &lt;/ul&gt;
 * 
 * &lt;p&gt;
 * Attempted retrieval of a value with an underlying named value collection type
 * using {@link String} &lt;em&gt;should&lt;/em&gt; result in
 * {@link IllegalArgumentException} being thrown.
 * &lt;/p&gt;
 * 
 * &lt;h2&gt;Null Values&lt;/h2&gt;
 * &lt;p&gt;
 * Implementations &lt;em&gt;should&lt;/em&gt; support null values when a reference resolved
 * to an explicit null in the configuration source. A null value does not imply
 * that configuration is missing.
 * &lt;/p&gt;
 * 
 * &lt;p&gt;
 * For example, an application can use the {@link Void} type to check for the
 * presence of a null configuration value.
 * &lt;/p&gt;
 * 
 * &lt;pre&gt;
 * try {
 *     config.getValue(reference, Void.class);
 *     // The value is defined
 * } catch (IllegalArgumentException e) {
 *     // The value is not defined
 * }&lt;/pre&gt;
 *
 * &lt;h2&gt;Security Considerations&lt;/h2&gt;
 * &lt;p&gt;
 * When throwing {@link IllegalArgumentException}, an implementation:
 * &lt;/p&gt;
 * &lt;ul&gt;
 * &lt;li&gt;&lt;em&gt;Should not&lt;/em&gt; include the unresolved reference in the message.&lt;/li&gt;
 * &lt;li&gt;&lt;em&gt;Must not&lt;/em&gt; include any configuration values in the a message.&lt;/li&gt;
 * &lt;/ul&gt;
 */
public interface IuRuntimeConfiguration {

	/**
	 * Gets a serialized configuration value.
	 * 
	 * @param reference configuration value reference
	 * 
	 * @return serialized configuration value
	 * @throws IllegalArgumentException If the name cannot be resolved to a value,
	 *                                  or if the resolved value is not
	 *                                  serializable.
	 */
	default String getValue(String reference) throws IllegalArgumentException {
<span class="fc" id="L250">		return getValue(reference, String.class);</span>
	}

	/**
	 * Gets a serialized configuration value.
	 * 
	 * @param reference    configuration value reference
	 * @param defaultValue value to return instead of throwing
	 *                     {@link IllegalArgumentException} if the reference cannot
	 *                     be resolved
	 * 
	 * @return property value
	 */
	default String getValue(String reference, String defaultValue) {
<span class="fc" id="L264">		return getValue(reference, String.class, defaultValue);</span>
	}

	/**
	 * Gets an environment property.
	 * 
	 * @param reference configuration value reference
	 * @param type      expected type
	 * 
	 * @return property value
	 * @throws IllegalArgumentException If the reference cannot be resolved to a
	 *                                  value, or if the resolved value is
	 *                                  inappropriate for the expected type.
	 */
	Object getValue(String reference, Type type) throws IllegalArgumentException;

	/**
	 * Gets an environment property.
	 * 
	 * @param reference    configuration value reference
	 * @param type         expected type
	 * @param defaultValue default value
	 * 
	 * @return property value
	 */
	default Object getValue(String reference, Type type, Object defaultValue) {
		try {
<span class="fc" id="L291">			return getValue(reference, type);</span>
<span class="fc" id="L292">		} catch (IllegalArgumentException e) {</span>
<span class="fc" id="L293">			Logger.getLogger(IuRuntimeConfiguration.class.getName()).log(Level.FINEST, e,</span>
<span class="fc" id="L294">					() -&gt; &quot;Invalid configuration value for &quot; + reference + &quot; using default&quot;);</span>
<span class="fc" id="L295">			return defaultValue;</span>
		}
	}

	/**
	 * Gets an environment property.
	 * 
	 * @param &lt;V&gt;       expected type
	 * 
	 * @param reference configuration value reference
	 * @param type      expected type
	 * 
	 * @return property value
	 * @throws IllegalArgumentException If the reference cannot be resolved to a
	 *                                  value, or if the resolved value is
	 *                                  inappropriate for the expected type.
	 */
	default &lt;V&gt; V getValue(String reference, Class&lt;V&gt; type) throws IllegalArgumentException {
<span class="fc" id="L313">		return type.cast(getValue(reference, (Type) type));</span>
	}

	/**
	 * Gets an environment property.
	 * 
	 * @param &lt;V&gt;          expected type
	 * 
	 * @param reference    configuration value reference
	 * @param type         expected type
	 * @param defaultValue default value
	 * 
	 * @return property value
	 */
	default &lt;V&gt; V getValue(String reference, Class&lt;V&gt; type, V defaultValue) {
<span class="fc" id="L328">		return type.cast(getValue(reference, (Type) type, defaultValue));</span>
	}

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.10.202304240956</span></div></body></html>