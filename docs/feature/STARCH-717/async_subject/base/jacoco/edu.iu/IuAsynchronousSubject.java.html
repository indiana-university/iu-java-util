<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>IuAsynchronousSubject.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">IU Base Utilities Module</a> &gt; <a href="index.source.html" class="el_package">edu.iu</a> &gt; <span class="el_source">IuAsynchronousSubject.java</span></div><h1>IuAsynchronousSubject.java</h1><pre class="source lang-java linenums">/*
 * Copyright Â© 2023 Indiana University
 * All rights reserved.
 *
 * BSD 3-Clause License
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 
 * - Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 * 
 * - Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 * 
 * - Neither the name of the copyright holder nor the names of its
 *   contributors may be used to endorse or promote products derived from
 *   this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package edu.iu;

import java.util.Queue;
import java.util.Spliterator;
import java.util.concurrent.ConcurrentLinkedDeque;
import java.util.concurrent.ConcurrentLinkedQueue;
import java.util.function.Consumer;
import java.util.function.Supplier;
import java.util.stream.Stream;
import java.util.stream.StreamSupport;

/**
 * Provides &lt;strong&gt;subscriber&lt;/strong&gt; {@link Stream} instances over a shared
 * source &lt;strong&gt;subject&lt;/strong&gt;.
 * 
 * &lt;p&gt;
 * Each &lt;strong&gt;subject&lt;/strong&gt; is backed externally by a &lt;strong&gt;controlling
 * component&lt;/strong&gt; that:
 * &lt;/p&gt;
 * &lt;ul&gt;
 * &lt;li&gt;Provides an &lt;strong&gt;initial {@link Spliterator split}&lt;/strong&gt; of
 * available values at the point in time a new {@link #subscribe() subscription}
 * is created.&lt;/li&gt;
 * &lt;li&gt;{@link #accept(Object) Accepts} new values to be distributed to active
 * &lt;strong&gt;subscribers&lt;/strong&gt;.&lt;/li&gt;
 * &lt;/ul&gt;
 * 
 * &lt;p&gt;
 * After the &lt;strong&gt;initial {@link Spliterator split}&lt;/strong&gt; is created, but
 * before the values available at {@link #subscribe() subscription} time have
 * all been {@link Spliterator#tryAdvance(Consumer) advanced}, newly
 * {@link #accept(Object) accepted} values are offered to a queue. Values
 * &lt;em&gt;may&lt;/em&gt; be removed from the queue if also advanced from the initial
 * split. Queued values will be polled and advanced after the last split of the
 * initial split advances its last value.
 * &lt;/p&gt;
 * 
 * &lt;p&gt;
 * After all queued values have been advanced, the &lt;strong&gt;subscriber&lt;/strong&gt;
 * transitions to a dedicated {@link IuAsynchronousPipe} and passes new values
 * through to {@link IuAsynchronousPipe#accept(Object)}.
 * &lt;/p&gt;
 * 
 * &lt;p&gt;
 * The &lt;strong&gt;subject&lt;/strong&gt; makes no guarantee to the &lt;strong&gt;controlling
 * component&lt;/strong&gt; when or if a &lt;strong&gt;subscriber&lt;/strong&gt; will transition
 * from non-blocking access to available values, to potentially blocking access
 * via {@link IuAsynchronousPipe}. It is, however, guaranteed that all values
 * available from the point in time the &lt;strong&gt;subscriber&lt;/strong&gt; begins
 * processing the {@link Stream} until &lt;strong&gt;unsubscribing&lt;/strong&gt; will be
 * supplied exactly once regardless of how the value is actually delivered.
 * &lt;/p&gt;
 * 
 * &lt;img src=&quot;doc-files/IuAsynchronousSubject.svg&quot; alt=&quot;UML Sequence Diagram&quot;&gt;
 * 
 * &lt;p&gt;
 * New values &lt;em&gt;should&lt;/em&gt; be {@link #accept(Object) accepted} before
 * appending the external source, to gracefully avoid a potential race condition
 * between the initial split and an internal appended values queue. For example:
 * &lt;/p&gt;
 * 
 * &lt;pre&gt;
 * class MyControllingComponent&amp;lt;T&amp;gt; implements Consumer&amp;lt;T&amp;gt; {
 * 	private final Queue&amp;lt;T&amp;gt; queue = new ConcurrentLinkedQueue&amp;lt;&amp;gt;();
 * 	private final IuAsynchronousSubject&amp;lt;T&amp;gt; subject =
 * 		new IuAsynchronousSubject&amp;lt;&amp;gt;(queue::spliterator);
 * 
 * 	{@literal @}Override
 * 	public void accept(T t) {
 * 		subject.accept(t);
 * 		queue.offer(t);
 * 	}
 * }
 * &lt;/pre&gt;
 * 
 * &lt;p&gt;
 * When the &lt;strong&gt;source&lt;/strong&gt; is sequential, &lt;strong&gt;subscribers&lt;/strong&gt;
 * &lt;em&gt;may&lt;/em&gt; expect to receive values in the order supplied.
 * &lt;/p&gt;
 * 
 * &lt;p&gt;
 * Each &lt;strong&gt;subscriber&lt;/strong&gt; {@link Stream} provides all values that may
 * be retrieved without blocking, then transitions to an
 * {@link IuAsynchronousPipe} managed by the &lt;strong&gt;subject&lt;/strong&gt; to block
 * until new values become available.
 * &lt;/p&gt;
 * 
 * &lt;p&gt;
 * A &lt;strong&gt;subscriber's&lt;/strong&gt; {@link Stream} may be {@link Stream#close()
 * closed} without affecting the status of the &lt;strong&gt;controlling
 * component&lt;/strong&gt;, or of any other &lt;strong&gt;subscriber&lt;/strong&gt; {@link Stream
 * streams}.
 * &lt;/p&gt;
 * 
 * &lt;p&gt;
 * This class is thread-safe and intended for use by high-volume
 * parallel-processing workloads.
 * &lt;/p&gt;
 * 
 * @param &lt;T&gt; value type
 * @see IuAsynchronousPipe
 */
public class IuAsynchronousSubject&lt;T&gt; implements Consumer&lt;T&gt;, AutoCloseable {

	private static abstract class DelegatingSource&lt;T&gt; {

		private volatile Spliterator&lt;T&gt; delegate;

<span class="fc" id="L140">		private DelegatingSource(Spliterator&lt;T&gt; delegate) {</span>
<span class="pc bpc" id="L141" title="1 of 2 branches missed.">			if (delegate.estimateSize() &gt; 0)</span>
<span class="fc" id="L142">				this.delegate = delegate;</span>
<span class="fc" id="L143">		}</span>

		protected abstract Consumer&lt;? super T&gt; delegate(Consumer&lt;? super T&gt; action);

		protected abstract Spliterator&lt;T&gt; delegate(Spliterator&lt;T&gt; split);

		protected abstract boolean continueAdvance(Consumer&lt;? super T&gt; action);

		protected abstract void continueForEach(Consumer&lt;? super T&gt; action);

		protected Spliterator&lt;T&gt; delegate() {
<span class="fc" id="L154">			return delegate;</span>
		}

		public synchronized boolean tryAdvance(Consumer&lt;? super T&gt; action) {
<span class="fc bfc" id="L158" title="All 2 branches covered.">			if (delegate != null //</span>
<span class="fc bfc" id="L159" title="All 2 branches covered.">					&amp;&amp; delegate.tryAdvance(delegate(action))) {</span>

<span class="fc bfc" id="L161" title="All 2 branches covered.">				if (delegate.estimateSize() == 0)</span>
<span class="fc" id="L162">					delegate = null;</span>

<span class="fc" id="L164">				return true;</span>
			} else
<span class="fc" id="L166">				delegate = null;</span>

<span class="fc" id="L168">			return continueAdvance(action);</span>
		}

		public synchronized void forEachRemaining(Consumer&lt;? super T&gt; action) {
<span class="fc bfc" id="L172" title="All 2 branches covered.">			if (delegate != null) {</span>
<span class="fc" id="L173">				delegate.forEachRemaining(delegate(action));</span>
<span class="fc" id="L174">				delegate = null;</span>
			}

<span class="fc" id="L177">			continueForEach(action);</span>
<span class="fc" id="L178">		}</span>

		public synchronized Spliterator&lt;T&gt; trySplit() {
<span class="fc bfc" id="L181" title="All 2 branches covered.">			if (delegate == null)</span>
<span class="fc" id="L182">				return null;</span>

<span class="fc" id="L184">			final var split = delegate.trySplit();</span>
<span class="fc bfc" id="L185" title="All 2 branches covered.">			if (split == null)</span>
<span class="fc" id="L186">				return null;</span>
			else
<span class="fc" id="L188">				return delegate(split);</span>
		}
	}

	private static class Source&lt;T&gt; extends DelegatingSource&lt;T&gt; {
<span class="fc" id="L193">		private final Queue&lt;SourceSplit&lt;T&gt;&gt; children = new ConcurrentLinkedDeque&lt;&gt;();</span>
<span class="fc" id="L194">		private final Queue&lt;T&gt; accepted = new ConcurrentLinkedQueue&lt;&gt;();</span>

		private Source(Spliterator&lt;T&gt; delegate) {
<span class="fc" id="L197">			super(delegate);</span>
<span class="fc" id="L198">		}</span>

		@Override
		protected Consumer&lt;? super T&gt; delegate(Consumer&lt;? super T&gt; action) {
<span class="fc" id="L202">			return value -&gt; {</span>
<span class="fc" id="L203">				action.accept(value);</span>

<span class="fc" id="L205">				synchronized (this) {</span>
<span class="fc" id="L206">					accepted.remove(value);</span>
<span class="fc" id="L207">				}</span>
<span class="fc" id="L208">			};</span>
		}

		@Override
		protected Spliterator&lt;T&gt; delegate(Spliterator&lt;T&gt; split) {
<span class="fc" id="L213">			return new SourceSplit&lt;&gt;(split, this);</span>
		}

		@Override
		protected boolean continueAdvance(Consumer&lt;? super T&gt; action) {
<span class="fc bfc" id="L218" title="All 2 branches covered.">			if (isExhausted()) {</span>
<span class="fc" id="L219">				final var value = accepted.poll();</span>
<span class="fc bfc" id="L220" title="All 2 branches covered.">				if (value != null) {</span>
<span class="fc" id="L221">					action.accept(value);</span>
<span class="fc" id="L222">					return true;</span>
				}
			}
<span class="fc" id="L225">			return false;</span>
		}

		@Override
		protected void continueForEach(Consumer&lt;? super T&gt; action) {
<span class="fc bfc" id="L230" title="All 2 branches covered.">			if (isExhausted())</span>
<span class="fc bfc" id="L231" title="All 2 branches covered.">				while (!accepted.isEmpty())</span>
<span class="fc" id="L232">					action.accept(accepted.poll());</span>
<span class="fc" id="L233">		}</span>

		private boolean isExhausted() {
<span class="fc bfc" id="L236" title="All 2 branches covered.">			if (delegate() != null)</span>
<span class="fc" id="L237">				return false;</span>

<span class="fc" id="L239">			final var i = children.iterator();</span>
<span class="fc bfc" id="L240" title="All 2 branches covered.">			while (i.hasNext())</span>
<span class="fc bfc" id="L241" title="All 2 branches covered.">				if (i.next().delegate() == null)</span>
<span class="fc" id="L242">					i.remove();</span>
				else
<span class="fc" id="L244">					return false;</span>

<span class="fc" id="L246">			return true;</span>
		}
	}

	private static class SourceSplit&lt;T&gt; extends DelegatingSource&lt;T&gt; implements Spliterator&lt;T&gt; {
		private final Source&lt;T&gt; source;

		private SourceSplit(Spliterator&lt;T&gt; delegate, Source&lt;T&gt; source) {
<span class="fc" id="L254">			super(delegate);</span>
<span class="fc" id="L255">			this.source = source;</span>
<span class="fc" id="L256">			source.children.offer(this);</span>
<span class="fc" id="L257">		}</span>

		@Override
		protected Consumer&lt;? super T&gt; delegate(Consumer&lt;? super T&gt; action) {
<span class="fc" id="L261">			return source.delegate(action);</span>
		}

		@Override
		protected Spliterator&lt;T&gt; delegate(Spliterator&lt;T&gt; split) {
<span class="fc" id="L266">			return source.delegate(split);</span>
		}

		@Override
		protected boolean continueAdvance(Consumer&lt;? super T&gt; action) {
<span class="fc" id="L271">			return source.continueAdvance(action);</span>
		}

		@Override
		protected void continueForEach(Consumer&lt;? super T&gt; action) {
<span class="fc" id="L276">			source.continueForEach(action);</span>
<span class="fc" id="L277">		}</span>

		@Override
		public long estimateSize() {
<span class="fc" id="L281">			final var delegate = delegate();</span>
<span class="fc bfc" id="L282" title="All 2 branches covered.">			if (delegate != null)</span>
<span class="fc" id="L283">				return delegate.estimateSize();</span>
			else
<span class="fc" id="L285">				return 0L;</span>
		}

		@Override
		public int characteristics() {
<span class="fc" id="L290">			final var delegate = delegate();</span>
<span class="fc bfc" id="L291" title="All 2 branches covered.">			if (delegate != null)</span>
<span class="fc" id="L292">				return delegate.characteristics();</span>
			else
<span class="fc" id="L294">				return SIZED;</span>
		}
	}

	private class Subscriber implements Spliterator&lt;T&gt; {
		private volatile Source&lt;T&gt; source;
		private volatile Throwable error;
		private volatile boolean closed;
		private volatile IuAsynchronousPipe&lt;T&gt; pipe;
		private volatile Spliterator&lt;T&gt; pipedSplit;

<span class="fc" id="L305">		private Subscriber() {</span>
<span class="fc" id="L306">			final var delegate = initialSplitSupplier.get();</span>
<span class="fc bfc" id="L307" title="All 2 branches covered.">			if (delegate.estimateSize() &gt; 0)</span>
<span class="fc" id="L308">				source = new Source&lt;&gt;(delegate);</span>
<span class="fc" id="L309">		}</span>

		@Override
		public Spliterator&lt;T&gt; trySplit() {
<span class="fc" id="L313">			final var sourceSplit = this.source;</span>
<span class="fc bfc" id="L314" title="All 2 branches covered.">			if (sourceSplit != null)</span>
<span class="fc" id="L315">				return sourceSplit.trySplit();</span>

<span class="fc bfc" id="L317" title="All 2 branches covered.">			if (error != null)</span>
<span class="fc" id="L318">				throw IuException.unchecked(error);</span>
<span class="fc bfc" id="L319" title="All 2 branches covered.">			else if (pipedSplit != null)</span>
<span class="fc" id="L320">				return pipedSplit.trySplit();</span>
			else
<span class="fc" id="L322">				return null;</span>
		}

		@Override
		public boolean tryAdvance(Consumer&lt;? super T&gt; action) {
<span class="fc" id="L327">			final var sourceSplit = this.source;</span>
<span class="fc bfc" id="L328" title="All 2 branches covered.">			if (sourceSplit != null) {</span>
<span class="fc" id="L329">				final var sourceResult = sourceSplit.tryAdvance(action);</span>

<span class="fc bfc" id="L331" title="All 2 branches covered.">				if (sourceResult) {</span>
<span class="fc bfc" id="L332" title="All 4 branches covered.">					if (sourceSplit.isExhausted() &amp;&amp; sourceSplit.accepted.isEmpty())</span>
<span class="fc" id="L333">						bootstrapPipe();</span>

<span class="fc" id="L335">					return true;</span>
				}

<span class="fc" id="L338">				bootstrapPipe();</span>
			}

<span class="fc bfc" id="L341" title="All 2 branches covered.">			if (error != null)</span>
<span class="fc" id="L342">				throw IuException.unchecked(error);</span>
<span class="fc bfc" id="L343" title="All 2 branches covered.">			else if (pipedSplit != null)</span>
<span class="fc" id="L344">				return pipedSplit.tryAdvance(action);</span>
			else
<span class="fc" id="L346">				return false;</span>
		}

		@Override
		public void forEachRemaining(Consumer&lt;? super T&gt; action) {
<span class="fc" id="L351">			final var sourceSplit = this.source;</span>
<span class="fc bfc" id="L352" title="All 2 branches covered.">			if (sourceSplit != null)</span>
<span class="fc" id="L353">				sourceSplit.forEachRemaining(action);</span>

<span class="fc" id="L355">			bootstrapPipe();</span>

<span class="fc bfc" id="L357" title="All 2 branches covered.">			if (error != null)</span>
<span class="fc" id="L358">				throw IuException.unchecked(error);</span>
<span class="fc bfc" id="L359" title="All 2 branches covered.">			else if (pipedSplit != null)</span>
<span class="fc" id="L360">				pipedSplit.forEachRemaining(action);</span>
<span class="fc" id="L361">		}</span>

		@Override
		public long estimateSize() {
<span class="fc bfc" id="L365" title="All 2 branches covered.">			if (pipedSplit == null)</span>
<span class="fc bfc" id="L366" title="All 2 branches covered.">				if (source != null)</span>
<span class="fc" id="L367">					return Long.MAX_VALUE;</span>
				else
<span class="fc" id="L369">					return 0L;</span>
			else
<span class="fc" id="L371">				return pipedSplit.estimateSize();</span>
		}

		@Override
		public int characteristics() {
<span class="fc bfc" id="L376" title="All 2 branches covered.">			if (pipedSplit == null)</span>
<span class="fc bfc" id="L377" title="All 2 branches covered.">				if (source != null)</span>
<span class="fc" id="L378">					return CONCURRENT;</span>
				else
<span class="fc" id="L380">					return IMMUTABLE | SIZED;</span>
			else
<span class="fc" id="L382">				return pipedSplit.characteristics();</span>
		}

		private synchronized void bootstrapPipe() {
<span class="fc" id="L386">			this.source = null;</span>
<span class="fc bfc" id="L387" title="All 6 branches covered.">			if (pipe == null &amp;&amp; error == null &amp;&amp; !closed) {</span>
<span class="fc" id="L388">				pipe = new IuAsynchronousPipe&lt;&gt;();</span>
<span class="fc" id="L389">				pipedSplit = pipe.stream().spliterator();</span>
			}
<span class="fc" id="L391">		}</span>

		private synchronized void accept(T t) {
<span class="fc bfc" id="L394" title="All 2 branches covered.">			if (source != null)</span>
<span class="fc" id="L395">				source.accepted.offer(t);</span>
			else {
<span class="fc" id="L397">				bootstrapPipe();</span>
<span class="fc" id="L398">				pipe.accept(t);</span>
			}
<span class="fc" id="L400">		}</span>

		private synchronized void close() {
<span class="fc bfc" id="L403" title="All 2 branches covered.">			if (pipe != null)</span>
<span class="fc" id="L404">				pipe.close();</span>
			else
<span class="fc" id="L406">				closed = true;</span>
<span class="fc" id="L407">		}</span>

		private void error(Throwable e) {
<span class="fc bfc" id="L410" title="All 2 branches covered.">			if (pipe != null)</span>
<span class="fc" id="L411">				pipe.error(e);</span>
			else
<span class="fc" id="L413">				error = e;</span>
<span class="fc" id="L414">		}</span>
	}

	private final Supplier&lt;Spliterator&lt;T&gt;&gt; initialSplitSupplier;
<span class="fc" id="L418">	private final Queue&lt;Subscriber&gt; subscribers = new ConcurrentLinkedQueue&lt;&gt;();</span>
	private boolean closed;

	/**
	 * Creates a new &lt;strong&gt;subject&lt;/strong&gt;.
	 * 
	 * @param initialSplitSupplier supplies the initial split backing new
	 *                             &lt;strong&gt;subscriber&lt;/strong&gt; streams.
	 */
<span class="fc" id="L427">	public IuAsynchronousSubject(Supplier&lt;Spliterator&lt;T&gt;&gt; initialSplitSupplier) {</span>
<span class="fc" id="L428">		this.initialSplitSupplier = initialSplitSupplier;</span>
<span class="fc" id="L429">	}</span>

	/**
	 * &lt;strong&gt;Subscribes&lt;/strong&gt; to a {@link Stream} that supplies all values
	 * available without blocking then blocks until new values are available or the
	 * &lt;strong&gt;subject&lt;/strong&gt; is {@link #close() closed}.
	 * 
	 * @return {@link Stream}
	 */
	public Stream&lt;T&gt; subscribe() {
<span class="fc bfc" id="L439" title="All 2 branches covered.">		if (closed)</span>
<span class="fc" id="L440">			throw new IllegalStateException(&quot;closed&quot;);</span>

<span class="fc" id="L442">		final var subscriber = new Subscriber();</span>
<span class="fc" id="L443">		subscribers.offer(subscriber);</span>

<span class="fc" id="L445">		return StreamSupport.stream(subscriber, false).onClose(() -&gt; {</span>
<span class="fc" id="L446">			subscriber.close();</span>
<span class="fc" id="L447">			subscribers.remove(subscriber);</span>
<span class="fc" id="L448">		});</span>
	}

	/**
	 * Distributes a value to all potentially blocking &lt;strong&gt;subscribers&lt;/strong&gt;
	 * that have completed the transition to an {@link IuAsynchronousPipe}.
	 * 
	 * &lt;p&gt;
	 * This method does not supply values to &lt;strong&gt;subscribers&lt;/strong&gt; that
	 * haven't yet completed the transition. The &lt;strong&gt;controlling
	 * component&lt;/strong&gt; is responsible for independently supplying those values to
	 * it's {@link Spliterator}-supplying backing &lt;strong&gt;source&lt;/strong&gt;.
	 * &lt;/p&gt;
	 * 
	 * @param value value to supply to all &lt;strong&gt;subscribers&lt;/strong&gt;
	 */
	@Override
	public synchronized void accept(T value) {
<span class="fc bfc" id="L466" title="All 2 branches covered.">		if (closed)</span>
<span class="fc" id="L467">			throw new IllegalStateException(&quot;closed&quot;);</span>

<span class="fc" id="L469">		subscribers.forEach(subscriber -&gt; subscriber.accept(value));</span>
<span class="fc" id="L470">	}</span>

	/**
	 * Closes the &lt;strong&gt;subject&lt;/strong&gt;.
	 * 
	 * &lt;p&gt;
	 * Once closed:
	 * &lt;/p&gt;
	 * &lt;ul&gt;
	 * &lt;li&gt;Existing &lt;strong&gt;subscribers&lt;/strong&gt; may finish retrieving all values
	 * already supplied&lt;/li&gt;
	 * &lt;li&gt;Blocking &lt;strong&gt;subscriber&lt;/strong&gt; {@link Stream}s will be terminated
	 * gracefully&lt;/li&gt;
	 * &lt;li&gt;No new &lt;strong&gt;subscribers&lt;/strong&gt; may be created&lt;/li&gt;
	 * &lt;li&gt;No new &lt;strong&gt;values&lt;/strong&gt; may be supplied&lt;/li&gt;
	 * &lt;/ul&gt;
	 */
	@Override
	public synchronized void close() {
<span class="fc bfc" id="L489" title="All 2 branches covered.">		if (closed)</span>
<span class="fc" id="L490">			return;</span>

<span class="fc" id="L492">		closed = true;</span>

<span class="fc" id="L494">		Throwable e = null;</span>
<span class="fc bfc" id="L495" title="All 2 branches covered.">		while (!subscribers.isEmpty())</span>
<span class="fc" id="L496">			e = IuException.suppress(e, () -&gt; subscribers.poll().close());</span>

<span class="fc bfc" id="L498" title="All 2 branches covered.">		if (e != null)</span>
<span class="fc" id="L499">			throw IuException.unchecked(e);</span>
<span class="fc" id="L500">	}</span>

	/**
	 * Reports a fatal error to all &lt;strong&gt;subscribers&lt;/strong&gt; and {@link #close()
	 * closes} the &lt;strong&gt;subject&lt;/strong&gt;.
	 * 
	 * @param e fatal error
	 */
	public synchronized void error(Throwable e) {
<span class="fc bfc" id="L509" title="All 2 branches covered.">		while (!subscribers.isEmpty())</span>
<span class="fc" id="L510">			IuException.suppress(e, () -&gt; subscribers.poll().error(e));</span>

<span class="fc" id="L512">		closed = true;</span>
<span class="fc" id="L513">	}</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.10.202304240956</span></div></body></html>