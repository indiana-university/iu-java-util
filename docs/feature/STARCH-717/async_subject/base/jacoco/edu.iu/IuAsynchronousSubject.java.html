<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>IuAsynchronousSubject.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">IU Base Utilities Module</a> &gt; <a href="index.source.html" class="el_package">edu.iu</a> &gt; <span class="el_source">IuAsynchronousSubject.java</span></div><h1>IuAsynchronousSubject.java</h1><pre class="source lang-java linenums">/*
 * Copyright Â© 2023 Indiana University
 * All rights reserved.
 *
 * BSD 3-Clause License
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 
 * - Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 * 
 * - Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 * 
 * - Neither the name of the copyright holder nor the names of its
 *   contributors may be used to endorse or promote products derived from
 *   this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package edu.iu;

import java.util.Queue;
import java.util.Spliterator;
import java.util.concurrent.ConcurrentLinkedQueue;
import java.util.function.Consumer;
import java.util.function.Supplier;
import java.util.stream.Stream;
import java.util.stream.StreamSupport;

/**
 * Provides &lt;strong&gt;subscriber&lt;/strong&gt; {@link Stream} instances over a shared
 * source &lt;strong&gt;subject&lt;/strong&gt;.
 * 
 * &lt;p&gt;
 * &lt;strong&gt;Subjects&lt;/strong&gt; are backed externally by a &lt;strong&gt;controlling
 * component&lt;/strong&gt;, which is responsible for both appending new values to a
 * &lt;strong&gt;source&lt;/strong&gt; capable of supplying a {@link Spliterator}, and
 * independently {@link #accept(Object) supplying} the same values to be
 * distributed to all active subscribers. The &lt;strong&gt;subject&lt;/strong&gt; makes no
 * guarantee to the &lt;strong&gt;controlling component&lt;/strong&gt; when or if a
 * &lt;strong&gt;subscriber&lt;/strong&gt; will transition from non-blocking access to
 * available values to potentially blocking access via
 * {@link IuAsynchronousPipe}. It is, however, guaranteed that all values
 * available from the point in time the &lt;strong&gt;subscriber&lt;/strong&gt; begins
 * processing the {@link Stream} until &lt;strong&gt;unsubscribing&lt;/strong&gt; will be
 * supplied exactly once.
 * &lt;/p&gt;
 * 
 * &lt;p&gt;
 * For example:
 * &lt;/p&gt;
 * 
 * &lt;pre&gt;
 * class MyControllingComponent&amp;lt;T&amp;gt; implements Consumer&amp;lt;T&amp;gt; {
 * 	private final Queue&amp;lt;T&amp;gt; queue = new ConcurrentLinkedQueue&amp;lt;&amp;gt;();
 * 	private final IuAsynchronousSubject&amp;lt;T&amp;gt; subject =
 * 		new IuAsynchronousSubject&amp;lt;&amp;gt;(queue::spliterator);
 * 
 * 	{@literal @}Override
 * 	public void accept(T t) {
 * 		queue.offer(t);
 * 		subject.accept(t);
 * 	}
 * }
 * &lt;/pre&gt;
 * 
 * &lt;p&gt;
 * When the &lt;strong&gt;source&lt;/strong&gt; is sequential, &lt;strong&gt;subscribers&lt;/strong&gt;
 * &lt;em&gt;may&lt;/em&gt; expect to receive values in the order supplied.
 * &lt;/p&gt;
 * 
 * &lt;p&gt;
 * Each &lt;strong&gt;subscriber&lt;/strong&gt; {@link Stream} provides all values that may
 * be retrieved without blocking, then transitions to an
 * {@link IuAsynchronousPipe} managed by the &lt;strong&gt;subject&lt;/strong&gt; to block
 * until new values become available.
 * &lt;/p&gt;
 * 
 * &lt;p&gt;
 * A &lt;strong&gt;subscriber's&lt;/strong&gt; {@link Stream} may be {@link Stream#close()
 * closed} without affecting the status of the &lt;strong&gt;controlling
 * component&lt;/strong&gt;, or of any other &lt;strong&gt;subscriber&lt;/strong&gt; {@link Stream
 * streams}.
 * &lt;/p&gt;
 * 
 * &lt;p&gt;
 * This class is thread-safe and intended for use by high-volume
 * parallel-processing workloads.
 * &lt;/p&gt;
 * 
 * @param &lt;T&gt; value type
 * @see IuAsynchronousPipe
 */
public class IuAsynchronousSubject&lt;T&gt; implements Consumer&lt;T&gt;, AutoCloseable {

	private final Supplier&lt;Spliterator&lt;T&gt;&gt; source;
<span class="fc" id="L109">	private final Queue&lt;Subscriber&gt; subscribers = new ConcurrentLinkedQueue&lt;&gt;();</span>
	private boolean closed;

<span class="fc" id="L112">	private class Subscriber implements Spliterator&lt;T&gt; {</span>
<span class="fc" id="L113">		private final Spliterator&lt;T&gt; sourceSplit = source.get();</span>
<span class="fc" id="L114">		private final IuAsynchronousPipe&lt;T&gt; pipe = new IuAsynchronousPipe&lt;T&gt;();</span>

		private volatile Spliterator&lt;T&gt; pipedSplit;

		@Override
		public synchronized boolean tryAdvance(Consumer&lt;? super T&gt; action) {
<span class="fc bfc" id="L120" title="All 2 branches covered.">			if (pipedSplit == null)</span>
<span class="fc bfc" id="L121" title="All 2 branches covered.">				if (sourceSplit.tryAdvance(action))</span>
<span class="fc" id="L122">					return true;</span>
				else
<span class="fc" id="L124">					pipedSplit = pipe.stream().spliterator();</span>

<span class="fc" id="L126">			return pipedSplit.tryAdvance(action);</span>
		}

		@Override
		public synchronized Spliterator&lt;T&gt; trySplit() {
<span class="fc bfc" id="L131" title="All 2 branches covered.">			if (pipedSplit == null) {</span>
<span class="fc" id="L132">				pipedSplit = pipe.stream().spliterator();</span>
<span class="fc" id="L133">				return sourceSplit;</span>
			}

<span class="fc" id="L136">			return pipedSplit.trySplit();</span>
		}

		@Override
		public long estimateSize() {
<span class="fc bfc" id="L141" title="All 2 branches covered.">			if (pipedSplit == null)</span>
<span class="fc" id="L142">				return Long.MAX_VALUE;</span>
			else
<span class="fc" id="L144">				return pipedSplit.estimateSize();</span>
		}

		@Override
		public int characteristics() {
<span class="fc bfc" id="L149" title="All 2 branches covered.">			if (pipedSplit == null)</span>
<span class="fc" id="L150">				return CONCURRENT;</span>
			else
<span class="fc" id="L152">				return pipedSplit.characteristics();</span>
		}
	}

	/**
	 * Creates a new &lt;strong&gt;subject&lt;/strong&gt;.
	 * 
	 * @param source supplies the initial split backing new
	 *               &lt;strong&gt;subscriber&lt;/strong&gt; streams.
	 */
<span class="fc" id="L162">	public IuAsynchronousSubject(Supplier&lt;Spliterator&lt;T&gt;&gt; source) {</span>
<span class="fc" id="L163">		this.source = source;</span>
<span class="fc" id="L164">	}</span>

	/**
	 * &lt;strong&gt;Subscribes&lt;/strong&gt; to a {@link Stream} that supplies all values
	 * available without blocking then blocks until new values are available or the
	 * &lt;strong&gt;subject&lt;/strong&gt; is {@link #close() closed}.
	 * 
	 * @return {@link Stream}
	 */
	public Stream&lt;T&gt; subscribe() {
<span class="fc bfc" id="L174" title="All 2 branches covered.">		if (closed)</span>
<span class="fc" id="L175">			throw new IllegalStateException(&quot;closed&quot;);</span>

<span class="fc" id="L177">		final var subscriber = new Subscriber();</span>
<span class="fc" id="L178">		subscribers.offer(subscriber);</span>

<span class="fc" id="L180">		return StreamSupport.stream(subscriber, false).onClose(() -&gt; subscribers.remove(subscriber));</span>
	}

	/**
	 * Distributes a value to all potentially blocking &lt;strong&gt;subscribers&lt;/strong&gt;
	 * that have completed the transition to an {@link IuAsynchronousPipe}.
	 * 
	 * &lt;p&gt;
	 * This method does not supply values to &lt;strong&gt;subscribers&lt;/strong&gt; that
	 * haven't yet completed the transition. The &lt;strong&gt;controlling
	 * component&lt;/strong&gt; is responsible for independently supplying those values to
	 * it's {@link Spliterator}-supplying backing &lt;strong&gt;source&lt;/strong&gt;.
	 * &lt;/p&gt;
	 * 
	 * @param value value to supply to all &lt;strong&gt;subscribers&lt;/strong&gt;
	 */
	@Override
	public void accept(T value) {
<span class="fc bfc" id="L198" title="All 2 branches covered.">		if (closed)</span>
<span class="fc" id="L199">			throw new IllegalStateException(&quot;closed&quot;);</span>

<span class="fc" id="L201">		subscribers.forEach(subscriber -&gt; subscriber.pipe.accept(value));</span>
<span class="fc" id="L202">	}</span>

	/**
	 * Closes the &lt;strong&gt;subject&lt;/strong&gt;.
	 * 
	 * &lt;p&gt;
	 * Once closed:
	 * &lt;/p&gt;
	 * &lt;ul&gt;
	 * &lt;li&gt;Existing &lt;strong&gt;subscribers&lt;/strong&gt; may finish retrieving all values
	 * already supplied&lt;/li&gt;
	 * &lt;li&gt;Blocking &lt;strong&gt;subscriber&lt;/strong&gt; {@link Stream}s will be terminated
	 * gracefully&lt;/li&gt;
	 * &lt;li&gt;No new &lt;strong&gt;subscribers&lt;/strong&gt; may be created&lt;/li&gt;
	 * &lt;li&gt;No new &lt;strong&gt;values&lt;/strong&gt; may be supplied&lt;/li&gt;
	 * &lt;/ul&gt;
	 */
	@Override
	public synchronized void close() {
<span class="fc bfc" id="L221" title="All 2 branches covered.">		if (closed)</span>
<span class="fc" id="L222">			return;</span>

<span class="fc" id="L224">		closed = true;</span>

<span class="fc" id="L226">		Throwable e = null;</span>
<span class="fc bfc" id="L227" title="All 2 branches covered.">		while (!subscribers.isEmpty())</span>
<span class="fc" id="L228">			e = IuException.suppress(e, () -&gt; subscribers.poll().pipe.close());</span>

<span class="fc bfc" id="L230" title="All 2 branches covered.">		if (e != null)</span>
<span class="fc" id="L231">			throw IuException.unchecked(e);</span>
<span class="fc" id="L232">	}</span>

	/**
	 * Reports a fatal error to all &lt;strong&gt;subscribers&lt;/strong&gt; and {@link #close()
	 * closes} the &lt;strong&gt;subject&lt;/strong&gt;.
	 * 
	 * @param e fatal error
	 */
	public synchronized void error(Throwable e) {
<span class="fc bfc" id="L241" title="All 2 branches covered.">		while (!subscribers.isEmpty())</span>
<span class="fc" id="L242">			IuException.suppress(e, () -&gt; subscribers.poll().pipe.error(e));</span>

<span class="fc" id="L244">		closed = true;</span>
<span class="fc" id="L245">	}</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.10.202304240956</span></div></body></html>