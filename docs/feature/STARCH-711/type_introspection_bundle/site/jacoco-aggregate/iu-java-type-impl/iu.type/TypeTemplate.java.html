<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>TypeTemplate.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">IU Java Utilities API Reference</a> &gt; <a href="../index.html" class="el_bundle">iu-java-type-impl</a> &gt; <a href="index.source.html" class="el_package">iu.type</a> &gt; <span class="el_source">TypeTemplate.java</span></div><h1>TypeTemplate.java</h1><pre class="source lang-java linenums">/*
 * Copyright Â© 2023 Indiana University
 * All rights reserved.
 *
 * BSD 3-Clause License
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 
 * - Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 * 
 * - Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 * 
 * - Neither the name of the copyright holder nor the names of its
 *   contributors may be used to endorse or promote products derived from
 *   this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package iu.type;

import java.beans.Introspector;
import java.lang.reflect.AnnotatedElement;
import java.lang.reflect.Constructor;
import java.lang.reflect.Modifier;
import java.lang.reflect.ParameterizedType;
import java.lang.reflect.Type;
import java.util.ArrayDeque;
import java.util.LinkedHashMap;
import java.util.Map;
import java.util.Objects;
import java.util.Queue;
import java.util.function.Consumer;

import edu.iu.IuException;
import edu.iu.IuObject;
import edu.iu.IuVisitor;
import edu.iu.type.InstanceReference;
import edu.iu.type.IuConstructor;
import edu.iu.type.IuReferenceKind;
import edu.iu.type.IuType;
import edu.iu.type.IuTypeReference;

/**
 * Represents the internal structure of a {@link TypeFacade}.
 * 
 * &lt;p&gt;
 * Each template is a standalone representation of a single generic type,
 * potentially paired with a raw template representing its erasure.
 * &lt;/p&gt;
 * 
 * &lt;p&gt;
 * Note that {@link TypeTemplate} is not sterotyped as a hash key, but
 * {@link IuType} is. This hash key behavior comes from same-instance identity
 * default {@link #hashCode()} and {@link #equals(Object)} implementations of
 * instances managed by {@link TypeFactory}. Since ClassLoading data is loaded
 * exactly once and remains static once loaded, type introspection instances
 * match that load-once static behavior. It is expected that each raw type
 * (primitive, class, interface, enum, record, etc) has exactly one
 * {@link TypeTemplate} instance, and that each {@link TypeTemplate} instance
 * backed by a generic type contains a {@link TypeFacade} backed by a singleton
 * raw type instances representing its {@link #erase() type erasure}. This
 * behavior mirrors the hash key behavior of {@link Type}, so internal checks
 * for equality (and inequality) may use == (and !=).
 * &lt;/p&gt;
 * 
 * &lt;p&gt;
 * Note also that Java does not constrain the number of {@link Type} instances,
 * and considers those instances other than {@link Class} to be disposable.
 * {@link TypeFactory} does not manage {@link TypeTemplate} instances for
 * generic type markers once returned to the application.
 * &lt;/p&gt;
 * 
 * &lt;h2&gt;Initialization Order&lt;/h2&gt;
 * &lt;p&gt;
 * Type templates are initialized in two phases, managed by {@link TypeFactory}.
 * &lt;/p&gt;
 * &lt;ol&gt;
 * &lt;li&gt;Declared elements&lt;/li&gt;
 * &lt;li&gt;Inherited elements&lt;/li&gt;
 * &lt;/ol&gt;
 * 
 * &lt;h3&gt;Declared Elements&lt;/h3&gt;
 * &lt;p&gt;
 * Resolved in order upon instantiation:
 * &lt;/p&gt;
 * &lt;ol&gt;
 * &lt;li&gt;{@link ElementBase#ElementBase(Consumer)} {@code preInitHook} binds raw
 * {@link Class} instances to {@link TypeFactory}{@code #RAW_TYPES}&lt;/li&gt;
 * &lt;li&gt;{@link AnnotatedElementBase#AnnotatedElementBase(AnnotatedElement, Consumer)}
 * binds {@link #annotatedElement}&lt;/li&gt;
 * &lt;li&gt;{@link DeclaredElementBase#DeclaredElementBase(AnnotatedElement, Consumer, Type, TypeTemplate)}
 * binds:
 * &lt;ul&gt;
 * &lt;li&gt;{@link #type}&lt;/li&gt;
 * &lt;li&gt;{@link #declaringType()}, potentially null or unsealed&lt;/li&gt;
 * &lt;/ul&gt;
 * &lt;/li&gt;
 * &lt;li&gt;Apply actual type arguments from {@link ParameterizedType}&lt;/li&gt;
 * &lt;li&gt;{@link #erase()}&lt;/li&gt;
 * &lt;li&gt;{@link #constructors()}&lt;/li&gt;
 * &lt;/ol&gt;
 * 
 * &lt;h3&gt;Inherited Elements&lt;/h3&gt;
 * &lt;p&gt;
 * Resolved by {@link #sealHierarchy(Iterable)}, order incidental
 * &lt;/p&gt;
 * &lt;ul&gt;
 * &lt;li&gt;{@link #fields()}&lt;/li&gt;
 * &lt;li&gt;{@link #properties()}&lt;/li&gt;
 * &lt;li&gt;{@link #methods()}&lt;/li&gt;
 * &lt;li&gt;{@link #typeParameters()}&lt;/li&gt;
 * &lt;/ul&gt;
 * 
 * @param &lt;D&gt; declaring type
 * @param &lt;T&gt; raw or generic type
 */
<span class="fc" id="L130">final class TypeTemplate&lt;D, T&gt; extends DeclaredElementBase&lt;D, Class&lt;T&gt;&gt; implements IuType&lt;D, T&gt;, ParameterizedFacade {</span>

	@SuppressWarnings(&quot;unchecked&quot;)
	private static &lt;D&gt; TypeTemplate&lt;?, D&gt; resolveDeclaringType(Class&lt;?&gt; enclosed) {
<span class="fc" id="L134">		final var declaringClass = enclosed.getDeclaringClass();</span>
<span class="fc bfc" id="L135" title="All 2 branches covered.">		if (declaringClass == null)</span>
<span class="fc" id="L136">			return null;</span>
<span class="fc" id="L137">		return (TypeTemplate&lt;?, D&gt;) TypeFactory.resolveRawClass(declaringClass);</span>
	}

	// Declared
	private IuType&lt;D, T&gt; erasedType;
	private Iterable&lt;TypeFacade&lt;T, ?&gt;&gt; enclosedTypes;
	private Iterable&lt;ConstructorFacade&lt;T&gt;&gt; constructors;

	// Inherited
	private Iterable&lt;TypeFacade&lt;?, ? super T&gt;&gt; hierarchy;
	private Iterable&lt;FieldFacade&lt;? super T, ?&gt;&gt; fields;
	private Iterable&lt;PropertyFacade&lt;? super T, ?&gt;&gt; properties;
	private Iterable&lt;MethodFacade&lt;? super T, ?&gt;&gt; methods;

	// Parameterized
<span class="fc" id="L152">	private final ParameterizedElement parameterizedElement = new ParameterizedElement();</span>

	// Instance management
<span class="fc" id="L155">	private final IuVisitor&lt;InstanceReference&lt;T&gt;&gt; instanceReferences = new IuVisitor&lt;&gt;();</span>

	private TypeTemplate(Class&lt;T&gt; annotatedElement, Consumer&lt;TypeTemplate&lt;?, ?&gt;&gt; preInitHook, Type type,
			TypeTemplate&lt;D, T&gt; erasedType) {
<span class="fc" id="L159">		super(annotatedElement, preInitHook, type, resolveDeclaringType(annotatedElement));</span>

<span class="fc bfc" id="L161" title="All 4 branches covered.">		if (declaringType == null || isStatic())</span>
<span class="fc" id="L162">			initializeDeclared(erasedType);</span>
		else
<span class="fc" id="L164">			declaringType.template.postInit(() -&gt; initializeDeclared(erasedType));</span>
<span class="fc" id="L165">	}</span>

	/**
	 * Raw class constructor intended for use only by {@link TypeFactory}.
	 * 
	 * @param rawClass    raw class
	 * @param preInitHook receives a handle to {@code this} after binding the
	 *                    annotated element but before initializing and members
	 */
	TypeTemplate(Class&lt;T&gt; rawClass, Consumer&lt;TypeTemplate&lt;?, ?&gt;&gt; preInitHook) {
<span class="fc" id="L175">		this(rawClass, preInitHook, rawClass, null);</span>
<span class="fc" id="L176">	}</span>

	/**
	 * Generic type constructor intended for use only by {@link TypeFactory}.
	 * 
	 * @param preInitHook receives a handle to {@code this} after binding the
	 *                    annotated element but before initializing and members
	 * @param type        generic type; &lt;em&gt;must not&lt;/em&gt; be a class
	 * @param erasedType  pre-calculated raw type template; a {@link TypeTemplate}
	 *                    cannot be created for a generic type without a
	 *                    fully-formed instance of its type erasure, provided as an
	 *                    argument to this parameter
	 */
	TypeTemplate(Consumer&lt;TypeTemplate&lt;?, ?&gt;&gt; preInitHook, Type type, TypeTemplate&lt;D, T&gt; erasedType) {
<span class="fc" id="L190">		this(erasedType.erasedClass(), preInitHook, type, erasedType);</span>
<span class="fc bfc" id="L191" title="All 2 branches covered.">		assert !(type instanceof Class) : type;</span>
<span class="fc bfc" id="L192" title="All 2 branches covered.">		assert erasedType.erasedClass() == TypeFactory.getErasedClass(type)</span>
<span class="fc" id="L193">				: erasedType + &quot; &quot; + TypeUtils.printType(type);</span>

<span class="fc" id="L195">		erasedType.postInit(() -&gt; sealHierarchy(erasedType.hierarchy));</span>
<span class="fc" id="L196">	}</span>

	private boolean isNative() {
<span class="fc" id="L199">		final var packageName = annotatedElement.getPackageName();</span>
<span class="fc" id="L200">		final var targetModule = annotatedElement.getModule();</span>
<span class="fc" id="L201">		final var typeImplModule = getClass().getModule();</span>
<span class="fc bfc" id="L202" title="All 4 branches covered.">		return IuObject.isPlatformName(name()) //</span>
				|| targetModule == typeImplModule //
<span class="fc bfc" id="L204" title="All 2 branches covered.">				|| !targetModule.isOpen(packageName, typeImplModule);</span>
	}

	private void initializeDeclared(TypeTemplate&lt;D, T&gt; erasedType) {
<span class="fc bfc" id="L208" title="All 4 branches covered.">		if (declaringType != null &amp;&amp; !isStatic())</span>
<span class="fc" id="L209">			parameterizedElement.apply(declaringType.template.typeParameters());</span>

<span class="fc bfc" id="L211" title="All 2 branches covered.">		if (erasedType == null) {</span>
<span class="fc" id="L212">			this.erasedType = this;</span>
<span class="fc" id="L213">			initializeConstructors();</span>
		} else {
<span class="fc" id="L215">			this.erasedType = new TypeFacade&lt;D, T&gt;(erasedType, this, IuReferenceKind.ERASURE);</span>
<span class="fc" id="L216">			erasedType.postInit(() -&gt; {</span>
<span class="fc" id="L217">				initializeConstructors();</span>
<span class="fc" id="L218">			});</span>
		}
<span class="fc" id="L220">	}</span>

	@SuppressWarnings({ &quot;rawtypes&quot;, &quot;unchecked&quot; })
	private void initializeEnclosedTypes() {
<span class="fc" id="L224">		Queue&lt;TypeFacade&lt;T, ?&gt;&gt; enclosedTypes = new ArrayDeque&lt;&gt;();</span>

<span class="fc bfc" id="L226" title="All 2 branches covered.">		if (!isNative()) {</span>
<span class="fc" id="L227">			Class&lt;?&gt;[] enclosedClasses = annotatedElement.getDeclaredClasses();</span>
<span class="fc" id="L228">			postInit(() -&gt; {</span>
<span class="fc bfc" id="L229" title="All 2 branches covered.">				for (var enclosedClass : enclosedClasses) {</span>
<span class="fc" id="L230">					final var enclosedType = TypeFactory.resolveRawClass(enclosedClass);</span>
<span class="fc" id="L231">					enclosedTypes.offer(new TypeFacade(enclosedType, this, IuReferenceKind.ENCLOSING_TYPE));</span>
				}
<span class="fc" id="L233">			});</span>
		}

<span class="fc" id="L236">		this.enclosedTypes = enclosedTypes;</span>
<span class="fc" id="L237">	}</span>

	@SuppressWarnings(&quot;unchecked&quot;)
	private void initializeConstructors() {
<span class="fc" id="L241">		Queue&lt;ConstructorFacade&lt;T&gt;&gt; constructors = new ArrayDeque&lt;&gt;();</span>

<span class="fc bfc" id="L243" title="All 2 branches covered.">		if (!isNative() //</span>
<span class="fc bfc" id="L244" title="All 2 branches covered.">				&amp;&amp; !annotatedElement.isInterface() //</span>
<span class="fc bfc" id="L245" title="All 2 branches covered.">				&amp;&amp; !annotatedElement.isEnum())</span>
<span class="fc bfc" id="L246" title="All 2 branches covered.">			for (var constructor : annotatedElement.getDeclaredConstructors())</span>
				// _unchecked warning_: see source for #getDeclaredConstructors()
				// =&gt; This cast is safe as of Java 17
<span class="fc" id="L249">				constructors.offer(new ConstructorFacade&lt;&gt;((Constructor&lt;T&gt;) constructor, this));</span>

<span class="fc" id="L251">		this.constructors = constructors;</span>
<span class="fc" id="L252">	}</span>

	@SuppressWarnings({ &quot;unchecked&quot;, &quot;rawtypes&quot; })
	private Iterable&lt;FieldFacade&lt;? super T, ?&gt;&gt; initializeFields() {
<span class="fc" id="L256">		Queue&lt;FieldFacade&lt;? super T, ?&gt;&gt; rv = new ArrayDeque&lt;&gt;();</span>

<span class="fc bfc" id="L258" title="All 2 branches covered.">		if (!isNative()) //</span>
<span class="fc bfc" id="L259" title="All 2 branches covered.">			for (var field : annotatedElement.getDeclaredFields()) {</span>
				TypeTemplate&lt;?, ?&gt; fieldType;
<span class="fc bfc" id="L261" title="All 2 branches covered.">				if (field.getType() == annotatedElement)</span>
<span class="fc" id="L262">					fieldType = this;</span>
				else
<span class="fc" id="L264">					fieldType = TypeFactory.resolveType(field.getGenericType());</span>

<span class="fc" id="L266">				rv.offer(new FieldFacade(field, fieldType, this));</span>
			}

<span class="fc bfc" id="L269" title="All 2 branches covered.">		for (var superType : hierarchy)</span>
<span class="fc" id="L270">			superType.template.postInit(() -&gt; {</span>
<span class="fc bfc" id="L271" title="All 2 branches covered.">				for (var inheritedField : superType.template.fields)</span>
<span class="fc" id="L272">					rv.offer(inheritedField);</span>
<span class="fc" id="L273">			});</span>

<span class="fc" id="L275">		return rv;</span>
	}

	@SuppressWarnings({ &quot;unchecked&quot;, &quot;rawtypes&quot; })
	private Iterable&lt;PropertyFacade&lt;? super T, ?&gt;&gt; initializeProperties() {
<span class="fc" id="L280">		Queue&lt;PropertyFacade&lt;? super T, ?&gt;&gt; rv = new ArrayDeque&lt;&gt;();</span>

<span class="fc bfc" id="L282" title="All 2 branches covered.">		if (!isNative()) //</span>
<span class="fc bfc" id="L283" title="All 2 branches covered.">			for (var property : IuException.unchecked(() -&gt; Introspector.getBeanInfo(annotatedElement))</span>
<span class="fc" id="L284">					.getPropertyDescriptors()) {</span>
<span class="fc bfc" id="L285" title="All 2 branches covered.">				if (property.getName().equals(&quot;class&quot;))</span>
<span class="fc" id="L286">					continue;</span>

<span class="fc" id="L288">				var readMethod = property.getReadMethod();</span>
<span class="fc" id="L289">				var writeMethod = property.getWriteMethod();</span>

				Type propertyType;
<span class="fc bfc" id="L292" title="All 2 branches covered.">				if (readMethod != null)</span>
<span class="fc" id="L293">					propertyType = readMethod.getGenericReturnType();</span>
<span class="fc bfc" id="L294" title="All 2 branches covered.">				else if (writeMethod != null)</span>
<span class="fc" id="L295">					propertyType = writeMethod.getGenericParameterTypes()[0];</span>
				else
					continue;

				TypeTemplate&lt;?, T&gt; propertyTypeTemplate;
<span class="fc bfc" id="L300" title="All 2 branches covered.">				if (propertyType == annotatedElement)</span>
<span class="fc" id="L301">					propertyTypeTemplate = this;</span>
				else
<span class="fc" id="L303">					propertyTypeTemplate = (TypeTemplate&lt;?, T&gt;) TypeFactory.resolveType(propertyType);</span>

<span class="fc" id="L305">				rv.offer(new PropertyFacade(property, propertyTypeTemplate, this));</span>
			}

<span class="fc bfc" id="L308" title="All 2 branches covered.">		for (var superType : hierarchy)</span>
<span class="fc" id="L309">			superType.template.postInit(() -&gt; {</span>
<span class="fc bfc" id="L310" title="All 2 branches covered.">				for (var inheritedProperty : superType.template.properties)</span>
<span class="fc" id="L311">					rv.offer(inheritedProperty);</span>
<span class="fc" id="L312">			});</span>

<span class="fc" id="L314">		return rv;</span>
	}

	private Iterable&lt;MethodFacade&lt;? super T, ?&gt;&gt; initializeMethods() {
<span class="fc" id="L318">		Queue&lt;MethodFacade&lt;? super T, ?&gt;&gt; rv = new ArrayDeque&lt;&gt;();</span>

<span class="fc bfc" id="L320" title="All 2 branches covered.">		if (!isNative()) //</span>
<span class="fc bfc" id="L321" title="All 2 branches covered.">			for (var method : annotatedElement.getDeclaredMethods()) {</span>
<span class="fc bfc" id="L322" title="All 2 branches covered.">				if (method.isSynthetic())</span>
<span class="fc" id="L323">					continue; // skip lambdas</span>

				TypeTemplate&lt;?, ?&gt; returnType;
<span class="fc bfc" id="L326" title="All 2 branches covered.">				if (method.getReturnType() == annotatedElement)</span>
<span class="fc" id="L327">					returnType = this;</span>
				else
<span class="fc" id="L329">					returnType = TypeFactory.resolveType(method.getGenericReturnType());</span>

<span class="fc" id="L331">				rv.offer(new MethodFacade&lt;&gt;(method, returnType, this));</span>
			}

<span class="fc bfc" id="L334" title="All 2 branches covered.">		for (var superType : hierarchy)</span>
<span class="fc" id="L335">			superType.template.postInit(() -&gt; {</span>
<span class="fc bfc" id="L336" title="All 2 branches covered.">				for (var inheritedMethod : superType.template.methods)</span>
<span class="fc" id="L337">					rv.offer(inheritedMethod);</span>
<span class="fc" id="L338">			});</span>

<span class="fc" id="L340">		return rv;</span>
	}

	private void doSealHierarchy(Iterable&lt;? extends IuType&lt;?, ? super T&gt;&gt; hierarchy) {
<span class="fc" id="L344">		Map&lt;Class&lt;?&gt;, TypeFacade&lt;?, ? super T&gt;&gt; hierarchyByErasure = new LinkedHashMap&lt;&gt;();</span>
<span class="fc bfc" id="L345" title="All 2 branches covered.">		for (var superType : hierarchy) {</span>
<span class="fc" id="L346">			var templateReference = superType.reference();</span>

			TypeTemplate&lt;?, ? super T&gt; superTypeTemplate;
<span class="fc bfc" id="L349" title="All 2 branches covered.">			if (templateReference == null) {</span>
<span class="fc" id="L350">				superTypeTemplate = (TypeTemplate&lt;?, ? super T&gt;) superType;</span>

				// common case: direct generalization of raw class
<span class="fc" id="L353">				hierarchyByErasure.put(superType.erasedClass(),</span>
						new TypeFacade&lt;&gt;(superTypeTemplate, this, IuReferenceKind.SUPER));
<span class="fc" id="L355">				continue;</span>
			}

			else // exception case: inherited generalization ...
<span class="fc" id="L359">				superTypeTemplate = ((TypeFacade&lt;?, ? super T&gt;) superType).template;</span>

			// ... by type erasure, same as direct
<span class="fc" id="L362">			var erasedReferrerClass = ((IuType&lt;?, ?&gt;) templateReference.referrer()).erasedClass();</span>
<span class="fc bfc" id="L363" title="All 2 branches covered.">			if (erasedReferrerClass == annotatedElement) {</span>
<span class="fc" id="L364">				hierarchyByErasure.put(superType.erasedClass(),</span>
						new TypeFacade&lt;&gt;(superTypeTemplate, this, IuReferenceKind.SUPER));
<span class="fc" id="L366">				continue;</span>
			}

			// ... via superclass or interface, look up unsealed reference by erasure
<span class="fc" id="L370">			final var referrer = Objects.requireNonNull(hierarchyByErasure.get(erasedReferrerClass));</span>
<span class="fc" id="L371">			final var superTypeFacade = new TypeFacade&lt;&gt;(superTypeTemplate, referrer, IuReferenceKind.SUPER);</span>
<span class="fc" id="L372">			hierarchyByErasure.put(superTypeFacade.erasedClass(), superTypeFacade);</span>
<span class="fc" id="L373">		}</span>

<span class="fc" id="L375">		this.hierarchy = hierarchyByErasure.values();</span>

<span class="fc bfc" id="L377" title="All 2 branches covered.">		if (type instanceof ParameterizedType parameterizedType) {</span>
<span class="fc" id="L378">			final var actualTypeArguments = parameterizedType.getActualTypeArguments();</span>
<span class="fc" id="L379">			final var typeVariables = annotatedElement.getTypeParameters();</span>
<span class="fc" id="L380">			final var length = actualTypeArguments.length;</span>
<span class="fc bfc" id="L381" title="All 2 branches covered.">			assert typeVariables.length == length; // enforced by javac</span>
<span class="fc bfc" id="L382" title="All 2 branches covered.">			for (var i = 0; i &lt; length; i++)</span>
<span class="fc" id="L383">				parameterizedElement.apply(this, typeVariables[i], actualTypeArguments[i]);</span>
		}

<span class="fc" id="L386">		fields = initializeFields();</span>
<span class="fc" id="L387">		properties = initializeProperties();</span>
<span class="fc" id="L388">		methods = initializeMethods();</span>

<span class="fc" id="L390">		parameterizedElement.seal(annotatedElement, this);</span>
<span class="fc" id="L391">		super.seal();</span>
<span class="fc" id="L392">	}</span>

	/**
	 * Unsupported, use {@link #sealHierarchy(Iterable)} to provide hierarchy when
	 * sealing.
	 * 
	 * @throws UnsupportedOperationException when invoked
	 */
	@Override
	final void seal() throws UnsupportedOperationException {
<span class="fc" id="L402">		throw new UnsupportedOperationException(&quot;use sealHierarchy() only with TypeTemplate&quot;);</span>
	}

	private boolean isStatic() {
<span class="fc" id="L406">		final var erased = erasedClass();</span>
<span class="pc bpc" id="L407" title="1 of 6 branches missed.">		if (erased.isInterface() || erased.isRecord() || erased.isEnum())</span>
<span class="fc" id="L408">			return true;</span>

<span class="fc" id="L410">		final var mod = annotatedElement.getModifiers();</span>
<span class="fc bfc" id="L411" title="All 2 branches covered.">		return (mod | Modifier.STATIC) == mod;</span>
	}

	/**
	 * Seals {@link #hierarchy()} and resolves &lt;strong&gt;inherited elements&lt;/strong&gt;.
	 * 
	 * @param hierarchy Resolved type hierarchy
	 */
	void sealHierarchy(Iterable&lt;? extends IuType&lt;?, ? super T&gt;&gt; hierarchy) {
<span class="fc bfc" id="L420" title="All 4 branches covered.">		if (declaringType == null || isStatic())</span>
<span class="fc" id="L421">			doSealHierarchy(hierarchy);</span>
		else
<span class="fc" id="L423">			declaringType.template.postInit(() -&gt; doSealHierarchy(hierarchy));</span>
<span class="fc" id="L424">	}</span>

	@Override
	public Runnable subscribe(InstanceReference&lt;T&gt; instanceReference) {
<span class="fc" id="L428">		instanceReferences.accept(instanceReference);</span>
<span class="fc" id="L429">		return () -&gt; instanceReferences.clear(instanceReference);</span>
	}

	@Override
	public Runnable observe(T instance) {
<span class="fc" id="L434">		instanceReferences.visit(listener -&gt; {</span>
<span class="fc bfc" id="L435" title="All 2 branches covered.">			if (listener != null)</span>
<span class="fc" id="L436">				listener.accept(instance);</span>
<span class="fc" id="L437">			return null;</span>
		});
<span class="fc" id="L439">		return () -&gt; instanceReferences.visit(listener -&gt; {</span>
<span class="fc bfc" id="L440" title="All 2 branches covered.">			if (listener != null)</span>
<span class="fc" id="L441">				listener.clear(instance);</span>
<span class="fc" id="L442">			return null;</span>
		});
	}

	@Override
	public Map&lt;String, TypeFacade&lt;?, ?&gt;&gt; typeParameters() {
<span class="fc" id="L448">		checkSealed();</span>
<span class="fc" id="L449">		return parameterizedElement.typeParameters();</span>
	}

	@Override
	public String name() {
<span class="fc" id="L454">		return annotatedElement.getName();</span>
	}

	@Override
	public IuTypeReference&lt;T, ?&gt; reference() {
<span class="fc" id="L459">		return null;</span>
	}

	@Override
	public Type deref() {
<span class="fc" id="L464">		return type;</span>
	}

	@Override
	public IuType&lt;D, T&gt; erase() {
<span class="fc" id="L469">		return erasedType;</span>
	}

	@Override
	public Class&lt;T&gt; erasedClass() {
<span class="fc" id="L474">		return annotatedElement;</span>
	}

	@Override
	public IuType&lt;?, ? super T&gt; referTo(Type referentType) {
<span class="fc" id="L479">		return TypeUtils.referTo(this, hierarchy(), referentType);</span>
	}

	@Override
	public Iterable&lt;TypeFacade&lt;T, ?&gt;&gt; enclosedTypes() {
<span class="fc bfc" id="L484" title="All 2 branches covered.">		if (enclosedTypes == null)</span>
<span class="fc" id="L485">			initializeEnclosedTypes();</span>
<span class="fc" id="L486">		return enclosedTypes;</span>
	}

	@Override
	public Iterable&lt;? extends IuConstructor&lt;T&gt;&gt; constructors() {
<span class="fc" id="L491">		return constructors;</span>
	}

	@Override
	public Iterable&lt;TypeFacade&lt;?, ? super T&gt;&gt; hierarchy() {
<span class="fc bfc" id="L496" title="All 2 branches covered.">		if (hierarchy == null)</span>
<span class="fc" id="L497">			throw new IllegalStateException(&quot;hierarchy not sealed&quot;);</span>
<span class="fc" id="L498">		return hierarchy;</span>
	}

	@Override
	@SuppressWarnings(&quot;unchecked&quot;)
	public &lt;F&gt; FieldFacade&lt;? super T, F&gt; field(String name) {
<span class="fc" id="L504">		return (FieldFacade&lt;? super T, F&gt;) IuType.super.field(name);</span>
	}

	@Override
	public Iterable&lt;FieldFacade&lt;? super T, ?&gt;&gt; fields() {
<span class="fc bfc" id="L509" title="All 2 branches covered.">		if (fields == null)</span>
<span class="fc" id="L510">			throw new IllegalStateException(&quot;fields not sealed&quot;);</span>
<span class="fc" id="L511">		return fields;</span>
	}

	@Override
	@SuppressWarnings(&quot;unchecked&quot;)
	public &lt;P&gt; PropertyFacade&lt;? super T, P&gt; property(String name) {
<span class="fc" id="L517">		return (PropertyFacade&lt;? super T, P&gt;) IuType.super.property(name);</span>
	}

	@Override
	public Iterable&lt;PropertyFacade&lt;? super T, ?&gt;&gt; properties() {
<span class="fc bfc" id="L522" title="All 2 branches covered.">		if (properties == null)</span>
<span class="fc" id="L523">			throw new IllegalStateException(&quot;properties not sealed&quot;);</span>
<span class="fc" id="L524">		return properties;</span>
	}

	@Override
	public Iterable&lt;MethodFacade&lt;? super T, ?&gt;&gt; methods() {
<span class="fc bfc" id="L529" title="All 2 branches covered.">		if (methods == null)</span>
<span class="fc" id="L530">			throw new IllegalStateException(&quot;methods not sealed&quot;);</span>
<span class="fc" id="L531">		return methods;</span>
	}

	@Override
	public String toString() {
<span class="fc" id="L536">		return &quot;IuType[&quot; + TypeUtils.printType(deref()) + ']';</span>
	}

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.10.202304240956</span></div></body></html>