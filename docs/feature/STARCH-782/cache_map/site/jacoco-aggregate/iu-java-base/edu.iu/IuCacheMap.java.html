<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>IuCacheMap.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">IU Java Utilities API Reference</a> &gt; <a href="../index.html" class="el_bundle">iu-java-base</a> &gt; <a href="index.source.html" class="el_package">edu.iu</a> &gt; <span class="el_source">IuCacheMap.java</span></div><h1>IuCacheMap.java</h1><pre class="source lang-java linenums">/*
 * Copyright Â© 2024 Indiana University
 * All rights reserved.
 *
 * BSD 3-Clause License
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 
 * - Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 * 
 * - Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 * 
 * - Neither the name of the copyright holder nor the names of its
 *   contributors may be used to endorse or promote products derived from
 *   this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package edu.iu;

import java.time.Duration;
import java.util.ArrayDeque;
import java.util.Collection;
import java.util.Iterator;
import java.util.Map;
import java.util.NoSuchElementException;
import java.util.Objects;
import java.util.Set;
import java.util.Spliterator;
import java.util.concurrent.ConcurrentHashMap;
import java.util.function.Consumer;
import java.util.function.Function;
import java.util.stream.Collectors;
import java.util.stream.Stream;

/**
 * Caching {@link Map} implementation backed by {@link IuCachedValue}.
 * 
 * @param &lt;K&gt; key type
 * @param &lt;V&gt; value type
 */
public class IuCacheMap&lt;K, V&gt; implements Map&lt;K, V&gt; {

<span class="fc" id="L57">	private static final Object[] O0 = new Object[0];</span>

	private static class CacheIterator&lt;K, V, T&gt; implements Iterator&lt;T&gt; {
		private final Iterator&lt;Entry&lt;K, IuCachedValue&lt;V&gt;&gt;&gt; iterator;
		private final Function&lt;Entry&lt;K, IuCachedValue&lt;V&gt;&gt;, T&gt; transform;
		private Entry&lt;K, IuCachedValue&lt;V&gt;&gt; current;

		// ensures GC doesn't clear reference between hasNext() and next()
		@SuppressWarnings(&quot;unused&quot;)
		private V hardRef;

		private CacheIterator(Iterator&lt;Entry&lt;K, IuCachedValue&lt;V&gt;&gt;&gt; iterator,
<span class="fc" id="L69">				Function&lt;Entry&lt;K, IuCachedValue&lt;V&gt;&gt;, T&gt; transform) {</span>
<span class="fc" id="L70">			this.transform = transform;</span>
<span class="fc" id="L71">			this.iterator = iterator;</span>
<span class="fc" id="L72">		}</span>

		@Override
		public boolean hasNext() {
<span class="fc bfc" id="L76" title="All 2 branches covered.">			if (current != null)</span>
<span class="fc" id="L77">				return true;</span>

<span class="fc bfc" id="L79" title="All 2 branches covered.">			while (iterator.hasNext()) {</span>
<span class="fc" id="L80">				final var current = iterator.next();</span>
<span class="fc" id="L81">				final var ref = current.getValue();</span>
<span class="fc" id="L82">				final var hardRef = ref.get();</span>
<span class="fc bfc" id="L83" title="All 2 branches covered.">				if (ref.isValid()) {</span>
<span class="fc" id="L84">					this.current = current;</span>
<span class="fc" id="L85">					this.hardRef = hardRef;</span>
<span class="fc" id="L86">					return true;</span>
				}
<span class="fc" id="L88">			}</span>

<span class="fc" id="L90">			return false;</span>
		}

		@Override
		public T next() {
<span class="fc bfc" id="L95" title="All 2 branches covered.">			if (hasNext()) {</span>
<span class="fc" id="L96">				T rv = transform.apply(current);</span>
<span class="fc" id="L97">				hardRef = null;</span>
<span class="fc" id="L98">				current = null;</span>
<span class="fc" id="L99">				return rv;</span>
			} else
<span class="fc" id="L101">				throw new NoSuchElementException();</span>
		}

		@Override
		public void remove() {
<span class="fc" id="L106">			iterator.remove();</span>
<span class="fc" id="L107">		}</span>
	}

	private static class CacheSpliterator&lt;K, V, T&gt; implements Spliterator&lt;T&gt; {
		private final Spliterator&lt;Entry&lt;K, IuCachedValue&lt;V&gt;&gt;&gt; split;
		private final Function&lt;Entry&lt;K, IuCachedValue&lt;V&gt;&gt;, T&gt; transform;

		private CacheSpliterator(Spliterator&lt;Entry&lt;K, IuCachedValue&lt;V&gt;&gt;&gt; split,
<span class="fc" id="L115">				Function&lt;Entry&lt;K, IuCachedValue&lt;V&gt;&gt;, T&gt; transform) {</span>
<span class="fc" id="L116">			this.split = split;</span>
<span class="fc" id="L117">			this.transform = transform;</span>
<span class="fc" id="L118">		}</span>

		@Override
		public boolean tryAdvance(Consumer&lt;? super T&gt; action) {
<span class="fc" id="L122">			class Box {</span>
				private boolean found;
			}
<span class="fc" id="L125">			final var box = new Box();</span>
<span class="fc bfc" id="L126" title="All 2 branches covered.">			while (!box.found)</span>
<span class="fc bfc" id="L127" title="All 2 branches covered.">				if (!split.tryAdvance(entry -&gt; {</span>
<span class="fc" id="L128">					final var ref = entry.getValue();</span>
					@SuppressWarnings(&quot;unused&quot;)
<span class="fc" id="L130">					final var hardRef = ref.get();</span>
<span class="fc bfc" id="L131" title="All 2 branches covered.">					if (box.found = ref.isValid())</span>
<span class="fc" id="L132">						action.accept(transform.apply(entry));</span>
<span class="fc" id="L133">				}))</span>
<span class="fc" id="L134">					return false;</span>

<span class="fc" id="L136">			return true;</span>
		}

		@Override
		public Spliterator&lt;T&gt; trySplit() {
<span class="fc" id="L141">			final var split = this.split.trySplit();</span>
<span class="fc bfc" id="L142" title="All 2 branches covered.">			if (split == null)</span>
<span class="fc" id="L143">				return null;</span>
			else
<span class="fc" id="L145">				return new CacheSpliterator&lt;&gt;(split, transform);</span>
		}

		@Override
		public long estimateSize() {
<span class="fc" id="L150">			return split.estimateSize();</span>
		}

		@Override
		public int characteristics() {
<span class="fc" id="L155">			return split.characteristics();</span>
		}
	}

<span class="fc" id="L159">	private abstract class CacheCollection&lt;T&gt; implements Collection&lt;T&gt; {</span>
		protected abstract T transform(Entry&lt;K, IuCachedValue&lt;V&gt;&gt; entry);

		protected abstract Stream&lt;Entry&lt;K, IuCachedValue&lt;V&gt;&gt;&gt; findEntries(Object value);

		@Override
		public int size() {
<span class="fc" id="L166">			return IuCacheMap.this.size();</span>
		}

		@Override
		public boolean isEmpty() {
<span class="fc" id="L171">			return IuCacheMap.this.isEmpty();</span>
		}

		@Override
		public boolean add(T e) {
<span class="fc" id="L176">			throw new UnsupportedOperationException();</span>
		}

		@Override
		public boolean addAll(Collection&lt;? extends T&gt; c) {
<span class="fc" id="L181">			throw new UnsupportedOperationException();</span>
		}

		@Override
		public Iterator&lt;T&gt; iterator() {
<span class="fc" id="L186">			return new CacheIterator&lt;&gt;(cache.entrySet().iterator(), this::transform);</span>
		}

		@Override
		public Spliterator&lt;T&gt; spliterator() {
<span class="fc" id="L191">			return new CacheSpliterator&lt;&gt;(cache.entrySet().spliterator(), this::transform);</span>
		}

		@Override
		public Object[] toArray() {
<span class="fc" id="L196">			return toArray(O0);</span>
		}

		@Override
		public &lt;U&gt; U[] toArray(U[] a) {
<span class="fc" id="L201">			final var q = new ArrayDeque&lt;&gt;();</span>
<span class="fc" id="L202">			final var i = iterator();</span>
<span class="fc bfc" id="L203" title="All 2 branches covered.">			while (i.hasNext())</span>
<span class="fc" id="L204">				q.offer(i.next());</span>
<span class="fc" id="L205">			return q.toArray(a);</span>
		}

		@Override
		public boolean contains(Object o) {
<span class="fc" id="L210">			return findEntries(o).findAny().isPresent();</span>
		}

		@Override
		public boolean remove(Object o) {
<span class="fc" id="L215">			final var entry = findEntries(o).findAny();</span>
<span class="fc bfc" id="L216" title="All 2 branches covered.">			if (entry.isEmpty())</span>
<span class="fc" id="L217">				return false;</span>

<span class="fc" id="L219">			final var removed = entry.get();</span>
<span class="fc" id="L220">			cache.remove(entry.get().getKey());</span>
<span class="fc" id="L221">			removed.getValue().clear();</span>
<span class="fc" id="L222">			return true;</span>
		}

		@Override
		public boolean containsAll(Collection&lt;?&gt; c) {
<span class="fc" id="L227">			return c.parallelStream().allMatch(this::contains);</span>
		}

		@Override
		public boolean removeAll(Collection&lt;?&gt; c) {
<span class="fc" id="L232">			class Box {</span>
				boolean removed;
			}
<span class="fc" id="L235">			final var box = new Box();</span>
<span class="fc" id="L236">			c.parallelStream().forEach(a -&gt; {</span>
<span class="fc bfc" id="L237" title="All 2 branches covered.">				if (remove(a))</span>
<span class="fc" id="L238">					box.removed = true;</span>
<span class="fc" id="L239">			});</span>
<span class="fc" id="L240">			return box.removed;</span>
		}

		@Override
		public boolean retainAll(Collection&lt;?&gt; c) {
<span class="fc" id="L245">			return cache.entrySet().retainAll(</span>
<span class="fc" id="L246">					c.parallelStream().flatMap(this::findEntries).filter(Objects::nonNull).collect(Collectors.toSet()));</span>
		}

		@Override
		public void clear() {
<span class="fc" id="L251">			IuCacheMap.this.clear();</span>
<span class="fc" id="L252">		}</span>
	}

	private class CacheEntry implements Entry&lt;K, V&gt; {
		private final Entry&lt;K, IuCachedValue&lt;V&gt;&gt; entry;
		private V value;

<span class="fc" id="L259">		private CacheEntry(Entry&lt;K, IuCachedValue&lt;V&gt;&gt; entry) {</span>
<span class="fc" id="L260">			this.entry = entry;</span>
<span class="fc" id="L261">			this.value = entry.getValue().get();</span>
<span class="fc" id="L262">		}</span>

		@Override
		public K getKey() {
<span class="fc" id="L266">			return entry.getKey();</span>
		}

		@Override
		public V getValue() {
<span class="fc" id="L271">			return value;</span>
		}

		@Override
		public V setValue(V value) {
<span class="fc" id="L276">			K key = getKey();</span>
<span class="fc" id="L277">			V oldValue = this.value;</span>
<span class="fc" id="L278">			entry.setValue(ref(key, value));</span>
<span class="fc" id="L279">			this.value = value;</span>
<span class="fc" id="L280">			return oldValue;</span>
		}

		@Override
		public int hashCode() {
			// matches HashMap.Entry#hashCode
<span class="fc" id="L286">			return Objects.hashCode(getKey()) ^ Objects.hashCode(value);</span>
		}

		@Override
		public boolean equals(Object obj) {
<span class="fc bfc" id="L291" title="All 2 branches covered.">			if (this == obj)</span>
<span class="fc" id="L292">				return true;</span>
<span class="fc bfc" id="L293" title="All 2 branches covered.">			if (!(obj instanceof Entry))</span>
<span class="fc" id="L294">				return false;</span>
<span class="fc" id="L295">			Entry&lt;?, ?&gt; other = (Entry&lt;?, ?&gt;) obj;</span>
<span class="fc bfc" id="L296" title="All 4 branches covered.">			return IuObject.equals(getKey(), other.getKey()) &amp;&amp; entry.getValue().has(other.getValue());</span>
		}
	}

<span class="fc" id="L300">	private class CacheEntrySet extends CacheCollection&lt;Entry&lt;K, V&gt;&gt; implements Set&lt;Entry&lt;K, V&gt;&gt; {</span>
		@Override
		protected Entry&lt;K, V&gt; transform(Entry&lt;K, IuCachedValue&lt;V&gt;&gt; entry) {
<span class="fc" id="L303">			return new CacheEntry(entry);</span>
		}

		@Override
		protected Stream&lt;Entry&lt;K, IuCachedValue&lt;V&gt;&gt;&gt; findEntries(Object value) {
<span class="fc bfc" id="L308" title="All 2 branches covered.">			if (value instanceof Entry entry)</span>
<span class="fc" id="L309">				return cache.entrySet().parallelStream().filter(//</span>
<span class="fc bfc" id="L310" title="All 2 branches covered.">						a -&gt; a.getKey().equals(entry.getKey()) //</span>
<span class="fc bfc" id="L311" title="All 2 branches covered.">								&amp;&amp; a.getValue().has(entry.getValue()));</span>
			else
<span class="fc" id="L313">				return Stream.empty();</span>
		}
	}

<span class="fc" id="L317">	private class CacheKeySet extends CacheCollection&lt;K&gt; implements Set&lt;K&gt; {</span>
		@Override
		protected K transform(Entry&lt;K, IuCachedValue&lt;V&gt;&gt; entry) {
<span class="fc" id="L320">			return entry.getKey();</span>
		}

		@Override
		protected Stream&lt;Entry&lt;K, IuCachedValue&lt;V&gt;&gt;&gt; findEntries(Object value) {
<span class="fc" id="L325">			return cache.entrySet().parallelStream().filter(a -&gt; a.getKey().equals(value));</span>
		}
	}

<span class="fc" id="L329">	private class CacheValues extends CacheCollection&lt;V&gt; {</span>
		@Override
		protected V transform(Entry&lt;K, IuCachedValue&lt;V&gt;&gt; entry) {
<span class="fc" id="L332">			return entry.getValue().get();</span>
		}

		@Override
		protected Stream&lt;Entry&lt;K, IuCachedValue&lt;V&gt;&gt;&gt; findEntries(Object value) {
<span class="fc" id="L337">			return cache.entrySet().parallelStream().filter(a -&gt; a.getValue().has(value));</span>
		}

	}

<span class="fc" id="L342">	private final Map&lt;K, IuCachedValue&lt;V&gt;&gt; cache = new ConcurrentHashMap&lt;&gt;();</span>
	private final Duration cacheTimeToLive;
	private CacheKeySet keySet;
	private CacheValues values;
	private CacheEntrySet entrySet;

	/**
	 * Constructor.
	 * 
	 * @param cacheTimeToLive maximum time to live for cache entries
	 */
<span class="fc" id="L353">	public IuCacheMap(Duration cacheTimeToLive) {</span>
<span class="fc" id="L354">		this.cacheTimeToLive = cacheTimeToLive;</span>
<span class="fc" id="L355">	}</span>

	@Override
	public int size() {
<span class="fc" id="L359">		return cache.size();</span>
	}

	@Override
	public boolean isEmpty() {
<span class="fc" id="L364">		return cache.isEmpty();</span>
	}

	@Override
	public boolean containsKey(Object key) {
<span class="fc" id="L369">		return cache.containsKey(key);</span>
	}

	@Override
	public boolean containsValue(Object value) {
<span class="fc" id="L374">		return cache.values().parallelStream().anyMatch(a -&gt; a.has(value));</span>
	}

	@Override
	public V get(Object key) {
<span class="fc" id="L379">		final var ref = cache.get(key);</span>
<span class="fc bfc" id="L380" title="All 2 branches covered.">		if (ref == null)</span>
<span class="fc" id="L381">			return null;</span>
		else
<span class="fc" id="L383">			return ref.get();</span>
	}

	@Override
	public V put(K key, V value) {
<span class="fc" id="L388">		final var ref = cache.get(key);</span>
		final V rv;
<span class="fc bfc" id="L390" title="All 2 branches covered.">		if (ref == null)</span>
<span class="fc" id="L391">			rv = null;</span>
		else {
<span class="fc" id="L393">			rv = ref.get();</span>
<span class="fc" id="L394">			ref.clear();</span>
		}
<span class="fc" id="L396">		cache.put(key, ref(key, value));</span>
<span class="fc" id="L397">		return rv;</span>
	}

	@Override
	public V remove(Object key) {
<span class="fc" id="L402">		final var ref = cache.remove(key);</span>
<span class="fc bfc" id="L403" title="All 2 branches covered.">		if (ref == null)</span>
<span class="fc" id="L404">			return null;</span>
		else {
<span class="fc" id="L406">			final var rv = ref.get();</span>
<span class="fc" id="L407">			ref.clear();</span>
<span class="fc" id="L408">			return rv;</span>
		}
	}

	@Override
	public void putAll(Map&lt;? extends K, ? extends V&gt; m) {
<span class="fc" id="L414">		m.forEach((k, v) -&gt; cache.put(k, ref(k, v)));</span>
<span class="fc" id="L415">	}</span>

	@Override
	public void clear() {
<span class="fc" id="L419">		cache.values().forEach(IuCachedValue::clear);</span>
<span class="fc" id="L420">		cache.clear();</span>
<span class="fc" id="L421">	}</span>

	@Override
	public Set&lt;K&gt; keySet() {
<span class="fc bfc" id="L425" title="All 2 branches covered.">		if (keySet == null)</span>
<span class="fc" id="L426">			keySet = new CacheKeySet();</span>
<span class="fc" id="L427">		return keySet;</span>
	}

	@Override
	public Collection&lt;V&gt; values() {
<span class="fc bfc" id="L432" title="All 2 branches covered.">		if (values == null)</span>
<span class="fc" id="L433">			values = new CacheValues();</span>
<span class="fc" id="L434">		return values;</span>
	}

	@Override
	public Set&lt;Entry&lt;K, V&gt;&gt; entrySet() {
<span class="fc bfc" id="L439" title="All 2 branches covered.">		if (entrySet == null)</span>
<span class="fc" id="L440">			entrySet = new CacheEntrySet();</span>
<span class="fc" id="L441">		return entrySet;</span>
	}

	private IuCachedValue&lt;V&gt; ref(K key, V value) {
<span class="fc" id="L445">		return new IuCachedValue&lt;&gt;(value, cacheTimeToLive, () -&gt; cache.remove(key));</span>
	}

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.10.202304240956</span></div></body></html>