<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>PemEncoded.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">IU Java Utilities API Reference</a> &gt; <a href="../index.html" class="el_bundle">iu-java-crypt</a> &gt; <a href="index.source.html" class="el_package">edu.iu.crypt</a> &gt; <span class="el_source">PemEncoded.java</span></div><h1>PemEncoded.java</h1><pre class="source lang-java linenums">/*
 * Copyright Â© 2026 Indiana University
 * All rights reserved.
 *
 * BSD 3-Clause License
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 
 * - Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 * 
 * - Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 * 
 * - Neither the name of the copyright holder nor the names of its
 *   contributors may be used to endorse or promote products derived from
 *   this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package edu.iu.crypt;

import java.io.ByteArrayInputStream;
import java.io.InputStream;
import java.net.URI;
import java.security.KeyFactory;
import java.security.KeyPair;
import java.security.PrivateKey;
import java.security.PublicKey;
import java.security.cert.CertificateFactory;
import java.security.cert.X509CRL;
import java.security.cert.X509Certificate;
import java.security.interfaces.RSAPrivateCrtKey;
import java.security.interfaces.RSAPublicKey;
import java.security.spec.PKCS8EncodedKeySpec;
import java.security.spec.X509EncodedKeySpec;
import java.util.ArrayDeque;
import java.util.Base64;
import java.util.Iterator;
import java.util.NoSuchElementException;
import java.util.Queue;

import edu.iu.IuException;
import edu.iu.IuIterable;
import edu.iu.IuStream;
import edu.iu.IuText;

/**
 * Reads PEM-encoded key and/or certificate data.
 */
public final class PemEncoded {

	/**
	 * Enumerates encoded key type.
	 */
<span class="fc" id="L67">	public enum KeyType {</span>
		/**
		 * Private key.
		 */
<span class="fc" id="L71">		PRIVATE_KEY,</span>

		/**
		 * Public key.
		 */
<span class="fc" id="L76">		PUBLIC_KEY,</span>

		/**
		 * X509 certificate.
		 */
<span class="fc" id="L81">		CERTIFICATE,</span>

		/**
		 * X509 certificate revocation list.
		 */
<span class="fc" id="L86">		X509_CRL;</span>
	}

	/**
	 * Reads PEM-encoded key and/or certificate data.
	 * 
	 * @param in input stream of PEM-encoded key and/or certificate data, multiple
	 *           entries may be concatenated
	 * @return Parsed PEM-encoded data
	 * @see &lt;a href=
	 *      &quot;https://datatracker.ietf.org/doc/html/rfc4945#section-6.1&quot;&gt;RFC-4945
	 *      Section 6.1&lt;/a&gt;
	 */
	public static Iterator&lt;PemEncoded&gt; parse(InputStream in) {
<span class="fc" id="L100">		return IuException.unchecked(() -&gt; parse(IuText.utf8(IuStream.read(in))));</span>
	}

	/**
	 * Parses PEM-encoded key and/or certificate data.
	 * 
	 * @param pemEncoded PEM-encoded key and/or certificate data, may be
	 *                   concatenated
	 * @return Parsed PEM-encoded data
	 * @see &lt;a href=
	 *      &quot;https://datatracker.ietf.org/doc/html/rfc4945#section-6.1&quot;&gt;RFC-4945
	 *      Section 6.1&lt;/a&gt;
	 */
	public static Iterator&lt;PemEncoded&gt; parse(String pemEncoded) {
<span class="fc" id="L114">		final var length = pemEncoded.length();</span>
<span class="fc" id="L115">		return new Iterator&lt;PemEncoded&gt;() {</span>
<span class="fc" id="L116">			private int start = 0;</span>
<span class="fc" id="L117">			private int end = -1;</span>

			@Override
			public boolean hasNext() {
<span class="fc bfc" id="L121" title="All 2 branches covered.">				if (end &lt; start) {</span>
					// * 11 chars: &quot;-----BEGIN &quot;
					// * 10-11 chars: key type
					// * 5 chars: &quot;-----&quot;
					// =&gt; 27 chars
<span class="fc bfc" id="L126" title="All 2 branches covered.">					if (start + 27 &gt; length)</span>
<span class="fc" id="L127">						return false;</span>
<span class="fc bfc" id="L128" title="All 2 branches covered.">					else if (!&quot;-----BEGIN &quot;.equals(pemEncoded.substring(start, start + 11)))</span>
<span class="fc" id="L129">						end = pemEncoded.length();</span>
					else {
<span class="fc" id="L131">						start += 11;</span>
<span class="fc" id="L132">						final var endOfKeyType = pemEncoded.indexOf(&quot;-----&quot;, start);</span>
<span class="fc" id="L133">						final var keyType = pemEncoded.substring(start, endOfKeyType);</span>
<span class="fc" id="L134">						start += keyType.length() + 5;</span>

<span class="fc" id="L136">						int endOfKey = pemEncoded.indexOf(&quot;-----END &quot; + keyType + &quot;-----&quot;, start);</span>
<span class="fc bfc" id="L137" title="All 2 branches covered.">						if (endOfKey == -1)</span>
<span class="fc" id="L138">							end = length;</span>
						else
<span class="fc" id="L140">							end = endOfKey;</span>
					}
				}

<span class="fc" id="L144">				return true;</span>
			}

			@Override
			public PemEncoded next() {
<span class="fc bfc" id="L149" title="All 2 branches covered.">				if (!hasNext())</span>
<span class="fc" id="L150">					throw new NoSuchElementException();</span>

<span class="fc" id="L152">				final var sb = new StringBuilder(pemEncoded.substring(start, end));</span>
<span class="fc bfc" id="L153" title="All 2 branches covered.">				for (var i = 0; i &lt; sb.length(); i++)</span>
<span class="fc bfc" id="L154" title="All 2 branches covered.">					if (Character.isWhitespace(sb.charAt(i)))</span>
<span class="fc" id="L155">						sb.deleteCharAt(i--);</span>

				final KeyType keyType;
				try {
<span class="fc bfc" id="L159" title="All 2 branches covered.">					if (start &lt; 24)</span>
<span class="fc" id="L160">						keyType = KeyType.CERTIFICATE;</span>
					else {
<span class="fc" id="L162">						keyType = KeyType.valueOf(</span>
<span class="fc" id="L163">								pemEncoded.substring(pemEncoded.lastIndexOf(&quot;-----BEGIN &quot;, start) + 11, start - 5)</span>
<span class="fc" id="L164">										.replace(' ', '_'));</span>
<span class="fc bfc" id="L165" title="All 2 branches covered.">						if (end &gt;= length)</span>
<span class="fc" id="L166">							throw new IllegalArgumentException(</span>
<span class="fc" id="L167">									&quot;Missing -----END &quot; + keyType.name().replace('_', ' ') + &quot;-----&quot;);</span>
					}
				} finally {
<span class="fc" id="L170">					final var nextStart = pemEncoded.indexOf(&quot;-----BEGIN &quot;, end);</span>
<span class="fc bfc" id="L171" title="All 2 branches covered.">					if (nextStart == -1)</span>
<span class="fc" id="L172">						start = length + 1;</span>
					else
<span class="fc" id="L174">						start = nextStart;</span>
				}

<span class="fc" id="L177">				return new PemEncoded(keyType, Base64.getDecoder().decode(sb.toString()));</span>
			}
		};
	}

	/**
	 * Serializes an X509 certificate chain as PEM encoded.
	 * 
	 * @param cert certificate chain
	 * @return PEM encoded certificate data
	 */
	public static Iterator&lt;PemEncoded&gt; serialize(X509Certificate... cert) {
<span class="fc" id="L189">		return IuIterable</span>
<span class="fc" id="L190">				.map(IuIterable.iter(cert),</span>
<span class="fc" id="L191">						c -&gt; IuException.unchecked(() -&gt; new PemEncoded(KeyType.CERTIFICATE, c.getEncoded())))</span>
<span class="fc" id="L192">				.iterator();</span>
	}

	/**
	 * Checks that public and private key, and certificate chain, are related and
	 * converts to PEM encoded form.
	 * 
	 * &lt;p&gt;
	 * Public key will be omitted if it matches the first certificate in the chain,
	 * or if it is fully encoded as a subset of the private key.
	 * &lt;/p&gt;
	 * 
	 * @param keyPair public and optional private key to export
	 * @param cert    certificate chain
	 * @return PEM encoded key data
	 */
	public static Iterator&lt;PemEncoded&gt; serialize(KeyPair keyPair, X509Certificate... cert) {
<span class="fc" id="L209">		final Queue&lt;PemEncoded&gt; q = new ArrayDeque&lt;&gt;();</span>
<span class="fc" id="L210">		var pub = keyPair.getPublic();</span>
<span class="fc bfc" id="L211" title="All 2 branches covered.">		if (cert.length &gt; 0)</span>
<span class="fc bfc" id="L212" title="All 2 branches covered.">			if (pub == null)</span>
<span class="fc" id="L213">				pub = cert[0].getPublicKey();</span>
<span class="fc bfc" id="L214" title="All 2 branches covered.">			else if (!pub.equals(cert[0].getPublicKey()))</span>
<span class="fc" id="L215">				throw new IllegalArgumentException(&quot;Public key doesn't match certificate&quot;);</span>

<span class="fc" id="L217">		final var priv = keyPair.getPrivate();</span>
<span class="fc bfc" id="L218" title="All 2 branches covered.">		if (priv != null)</span>
<span class="fc" id="L219">			q.add(new PemEncoded(KeyType.PRIVATE_KEY, priv.getEncoded()));</span>

<span class="fc bfc" id="L221" title="All 2 branches covered.">		if (priv instanceof RSAPrivateCrtKey) {</span>
<span class="fc" id="L222">			final var rsa = (RSAPrivateCrtKey) priv;</span>
<span class="fc" id="L223">			final var rsapub = (RSAPublicKey) pub;</span>
<span class="fc bfc" id="L224" title="All 2 branches covered.">			if (!rsa.getModulus().equals(rsapub.getModulus())</span>
<span class="fc bfc" id="L225" title="All 2 branches covered.">					|| !rsa.getPublicExponent().equals(rsapub.getPublicExponent()))</span>
<span class="fc" id="L226">				throw new IllegalArgumentException(&quot;RSA Public key doesn't match private&quot;);</span>
<span class="fc bfc" id="L227" title="All 2 branches covered.">		} else if (cert.length == 0)</span>
<span class="fc" id="L228">			q.add(new PemEncoded(KeyType.PUBLIC_KEY, pub.getEncoded()));</span>

<span class="fc" id="L230">		return IuIterable.cat(q, IuIterable.of(() -&gt; serialize(cert))).iterator();</span>
	}

	/**
	 * Converts parsed PEM data to a certificate chain.
	 * 
	 * @param pem PEM encoded certificate chain
	 * @return certificate chain
	 */
	public static X509Certificate[] getCertificateChain(Iterator&lt;PemEncoded&gt; pem) {
<span class="fc" id="L240">		final Queue&lt;X509Certificate&gt; c = new ArrayDeque&lt;&gt;();</span>
<span class="fc bfc" id="L241" title="All 2 branches covered.">		while (pem.hasNext())</span>
<span class="fc" id="L242">			c.offer(pem.next().asCertificate());</span>
<span class="fc" id="L243">		return c.toArray(new X509Certificate[c.size()]);</span>
	}

	/**
	 * Reads a certificate chain from a URI.
	 * 
	 * @param uri {@link URI}
	 * @return certificate chain
	 * @see &lt;a href=
	 *      &quot;https://datatracker.ietf.org/doc/html/rfc4945#section-6.1&quot;&gt;RFC-4945 PKI
	 *      Section 6.1&lt;/a&gt;
	 */
	public static X509Certificate[] getCertificateChain(URI uri) {
<span class="fc" id="L256">		return Init.SPI.getCertificateChain(uri);</span>
	}

	/**
	 * Parses raw data as {@link X509Certificate}
	 * 
	 * @param encoded DER encoded X.509 certificate data
	 * @return {@link X509Certificate}
	 */
	public static X509Certificate asCertificate(byte[] encoded) {
<span class="fc" id="L266">		return IuException.unchecked(() -&gt; (X509Certificate) CertificateFactory.getInstance(&quot;X.509&quot;)</span>
<span class="fc" id="L267">				.generateCertificate(new ByteArrayInputStream(encoded)));</span>
	}

	/**
	 * Parses raw data as {@link X509CRL}
	 * 
	 * @param encoded DER encoded X.509 CLR data
	 * @return {@link X509CRL}
	 */
	public static X509CRL asCRL(byte[] encoded) {
<span class="fc" id="L277">		return IuException.unchecked(</span>
<span class="fc" id="L278">				() -&gt; (X509CRL) CertificateFactory.getInstance(&quot;X.509&quot;).generateCRL(new ByteArrayInputStream(encoded)));</span>
	}

	private final KeyType keyType;
	private final byte[] encoded;

	/**
	 * Gets the key type.
	 * 
	 * @return {@link KeyType}
	 */
	public KeyType getKeyType() {
<span class="fc" id="L290">		return keyType;</span>
	}

	/**
	 * Gets the key as a public key when {@link #keyType} is
	 * {@link KeyType#PUBLIC_KEY}.
	 * 
	 * @param algorithm {@link KeyFactory} algorithm
	 * @return public key
	 */
	public PublicKey asPublic(String algorithm) {
<span class="fc bfc" id="L301" title="All 2 branches covered.">		if (!keyType.equals(KeyType.PUBLIC_KEY))</span>
<span class="fc" id="L302">			throw new IllegalStateException();</span>
<span class="fc" id="L303">		return IuException</span>
<span class="fc" id="L304">				.unchecked(() -&gt; KeyFactory.getInstance(algorithm).generatePublic(new X509EncodedKeySpec(encoded)));</span>
	}

	/**
	 * Gets the key as a private key when {@link #keyType} is
	 * {@link KeyType#PRIVATE_KEY}.
	 * 
	 * @param algorithm {@link KeyFactory} algorithm
	 * @return private key
	 */
	public PrivateKey asPrivate(String algorithm) {
<span class="fc bfc" id="L315" title="All 2 branches covered.">		if (!keyType.equals(KeyType.PRIVATE_KEY))</span>
<span class="fc" id="L316">			throw new IllegalStateException();</span>
<span class="fc" id="L317">		return IuException</span>
<span class="fc" id="L318">				.unchecked(() -&gt; KeyFactory.getInstance(algorithm).generatePrivate(new PKCS8EncodedKeySpec(encoded)));</span>
	}

	/**
	 * Gets the certificate when {@link #keyType} is {@link KeyType#CERTIFICATE}.
	 * 
	 * @return private key
	 */
	public X509Certificate asCertificate() {
<span class="fc bfc" id="L327" title="All 2 branches covered.">		if (!keyType.equals(KeyType.CERTIFICATE))</span>
<span class="fc" id="L328">			throw new IllegalStateException();</span>
<span class="fc" id="L329">		return asCertificate(encoded);</span>
	}

	/**
	 * Gets the certificate when {@link #keyType} is {@link KeyType#CERTIFICATE}.
	 * 
	 * @return private key
	 */
	public X509CRL asCRL() {
<span class="fc bfc" id="L338" title="All 2 branches covered.">		if (!keyType.equals(KeyType.X509_CRL))</span>
<span class="fc" id="L339">			throw new IllegalStateException();</span>
<span class="fc" id="L340">		return asCRL(encoded);</span>
	}

	@Override
	public String toString() {
<span class="fc" id="L345">		final var headerType = keyType.name().replace('_', ' ');</span>
<span class="fc" id="L346">		final var sb = new StringBuilder();</span>
<span class="fc" id="L347">		sb.append(&quot;-----BEGIN &quot;);</span>
<span class="fc" id="L348">		sb.append(headerType);</span>
<span class="fc" id="L349">		sb.append(&quot;-----&quot;);</span>

<span class="fc" id="L351">		var pos = sb.length();</span>
<span class="fc" id="L352">		sb.append(IuText.base64(encoded));</span>
<span class="fc bfc" id="L353" title="All 2 branches covered.">		for (; pos &lt; sb.length() - 1; pos += 65)</span>
<span class="fc" id="L354">			sb.insert(pos, '\n');</span>

<span class="fc" id="L356">		sb.append(&quot;\n-----END &quot;);</span>
<span class="fc" id="L357">		sb.append(headerType);</span>
<span class="fc" id="L358">		sb.append(&quot;-----\n&quot;);</span>
<span class="fc" id="L359">		return sb.toString();</span>
	}

<span class="fc" id="L362">	private PemEncoded(KeyType keyType, byte[] encoded) {</span>
<span class="fc" id="L363">		this.keyType = keyType;</span>
<span class="fc" id="L364">		this.encoded = encoded;</span>
<span class="fc" id="L365">	}</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.10.202304240956</span></div></body></html>