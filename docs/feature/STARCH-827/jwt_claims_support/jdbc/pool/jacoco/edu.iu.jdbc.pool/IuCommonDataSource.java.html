<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>IuCommonDataSource.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">IU Database Connection Pools</a> &gt; <a href="index.source.html" class="el_package">edu.iu.jdbc.pool</a> &gt; <span class="el_source">IuCommonDataSource.java</span></div><h1>IuCommonDataSource.java</h1><pre class="source lang-java linenums">/*
 * Copyright Â© 2024 Indiana University
 * All rights reserved.
 *
 * BSD 3-Clause License
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 
 * - Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 * 
 * - Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 * 
 * - Neither the name of the copyright holder nor the names of its
 *   contributors may be used to endorse or promote products derived from
 *   this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package edu.iu.jdbc.pool;

import java.io.PrintWriter;
import java.sql.Connection;
import java.sql.SQLException;
import java.sql.SQLFeatureNotSupportedException;
import java.time.Duration;
import java.time.Instant;
import java.util.Queue;
import java.util.concurrent.ConcurrentLinkedQueue;
import java.util.concurrent.TimeoutException;
import java.util.function.BiConsumer;
import java.util.logging.Level;
import java.util.logging.LogManager;
import java.util.logging.Logger;

import javax.sql.CommonDataSource;
import javax.sql.ConnectionEvent;
import javax.sql.ConnectionEventListener;
import javax.sql.DataSource;
import javax.sql.PooledConnection;
import javax.sql.XADataSource;

import edu.iu.IuException;
import edu.iu.IuObject;
import edu.iu.IuUtilityTaskController;
import edu.iu.UnsafeFunction;
import edu.iu.UnsafeRunnable;
import edu.iu.UnsafeSupplier;

/**
 * Abstract common database connection pool implementation.
 * 
 * &lt;p&gt;
 * May be overridden to implement {@link DataSource} or {@link XADataSource} and
 * integrate with an application runtime environment.
 * &lt;/p&gt;
 * 
 * @see #getPooledConnection()
 */
public abstract class IuCommonDataSource implements CommonDataSource, ConnectionEventListener, AutoCloseable {

	static {
<span class="fc" id="L75">		Logger.getLogger(IuCommonDataSource.class.getPackageName());</span>
	}
<span class="fc" id="L77">	private static final Logger LOG = Logger.getLogger(IuCommonDataSource.class.getName());</span>

<span class="fc" id="L79">	private final Queue&lt;IuPooledConnection&gt; openConnections = new ConcurrentLinkedQueue&lt;&gt;();</span>
<span class="fc" id="L80">	private final Queue&lt;IuPooledConnection&gt; reusableConnections = new ConcurrentLinkedQueue&lt;&gt;();</span>
	private final UnsafeSupplier&lt;? extends PooledConnection&gt; factory;

<span class="fc" id="L83">	private int loginTimeout = 15;</span>
	private String url;
	private String username;
	private String schema;
<span class="fc" id="L87">	private int maxSize = 16;</span>
<span class="fc" id="L88">	private int maxRetry = 1;</span>
<span class="fc" id="L89">	private long maxConnectionReuseCount = 100;</span>
<span class="fc" id="L90">	private Duration maxConnectionReuseTime = Duration.ofMinutes(15L);</span>
<span class="fc" id="L91">	private Duration abandonedConnectionTimeout = Duration.ofMinutes(30L);</span>
<span class="fc" id="L92">	private Duration shutdownTimeout = Duration.ofSeconds(30L);</span>

	private String validationQuery;
<span class="fc" id="L95">	private Duration validationInterval = Duration.ofSeconds(15L);</span>
	private UnsafeFunction&lt;Connection, Connection&gt; connectionInitializer;
	private UnsafeRunnable onClose;

	private boolean closed;
	private volatile int pendingConnections;

	/**
	 * Default constructor.
	 * 
	 * @param factory {@link UnsafeSupplier} of downstream {@link PooledConnection}
	 *                instances; each {@link UnsafeSupplier#get()} invocation
	 *                &lt;em&gt;must&lt;/em&gt; return a newly established physical database
	 *                connection.
	 */
<span class="fc" id="L110">	protected IuCommonDataSource(UnsafeSupplier&lt;? extends PooledConnection&gt; factory) {</span>
<span class="fc" id="L111">		this.factory = factory;</span>
<span class="fc" id="L112">	}</span>

	/**
	 * Checks out a {@link PooledConnection}.
	 * 
	 * &lt;img src=&quot;doc-files/IuCommonDataSource.svg&quot; alt=&quot;UML Communication Diagram&quot;&gt;
	 * 
	 * &lt;p&gt;
	 * &lt;strong&gt;Implementation Note:&lt;/strong&gt; The upstream {@link DataSource}
	 * implementation should discard this instance once the logical
	 * {@link Connection} view has been obtained. Application code will invoke
	 * {@link Connection#close()} to return the connection to the pool to be reused
	 * or retired. Note that invoking {@link PooledConnection#close()} &lt;em&gt;will&lt;/em&gt;
	 * close the physical connection and remove it from the pool. This facilitates
	 * ejecting physical connections by an upstream pool manager.
	 * &lt;/p&gt;
	 * 
	 * @return {@link PooledConnection}
	 * @throws SQLException if the connection fails due to a database error
	 */
	public IuPooledConnection getPooledConnection() throws SQLException {
<span class="fc" id="L133">		IuPooledConnection iuPooledConnection = null;</span>
<span class="fc" id="L134">		Instant timeout = Instant.now().plusSeconds(loginTimeout);</span>

<span class="fc" id="L136">		var attempt = 0;</span>
<span class="fc" id="L137">		Throwable error = null;</span>
<span class="fc bfc" id="L138" title="All 4 branches covered.">		while (!closed //</span>
				&amp;&amp; attempt &lt;= maxRetry //
<span class="fc bfc" id="L140" title="All 2 branches covered.">				&amp;&amp; timeout.isAfter(Instant.now()))</span>
			try {
<span class="fc" id="L142">				attempt++;</span>

<span class="fc" id="L144">				synchronized (this) {</span>
<span class="fc bfc" id="L145" title="All 2 branches covered.">					IuObject.waitFor(this, () -&gt; closed //</span>
<span class="fc bfc" id="L146" title="All 2 branches covered.">							|| !reusableConnections.isEmpty() //</span>
<span class="fc bfc" id="L147" title="All 2 branches covered.">							|| !this.isExhausted(), timeout);</span>

<span class="fc" id="L149">					pendingConnections++;</span>
<span class="fc" id="L150">				}</span>

				try {
<span class="fc bfc" id="L153" title="All 2 branches covered.">					while (!reusableConnections.isEmpty()) {</span>
<span class="fc" id="L154">						final var reusableConnection = reusableConnections.poll();</span>

<span class="fc" id="L156">						final var timeSinceInit = Duration.between(reusableConnection.getConnectionInitiated(),</span>
<span class="fc" id="L157">								Instant.now());</span>
<span class="fc bfc" id="L158" title="All 2 branches covered.">						if (timeSinceInit.compareTo(maxConnectionReuseTime) &gt;= 0) {</span>
<span class="fc" id="L159">							reusableConnection.close();</span>
<span class="fc" id="L160">							LOG.fine(() -&gt; &quot;jdbc-pool-retire-timeout:&quot; + timeSinceInit + ' ' + reusableConnection + ' '</span>
									+ this);
<span class="fc" id="L162">							continue;</span>
						}

<span class="fc" id="L165">						iuPooledConnection = reusableConnection;</span>
<span class="fc" id="L166">						LOG.finer(() -&gt; &quot;jdbc-pool-reuse; &quot; + reusableConnection + ' ' + this);</span>
<span class="fc" id="L167">						break;</span>
					}

<span class="fc bfc" id="L170" title="All 2 branches covered.">					if (iuPooledConnection == null)</span>
<span class="fc" id="L171">						iuPooledConnection = openConnection(timeout);</span>

<span class="fc" id="L173">					final var lastUsed = iuPooledConnection.getLastTransactionSegmentEnded();</span>
<span class="fc bfc" id="L174" title="All 4 branches covered.">					if (validationQuery != null //</span>
							&amp;&amp; (lastUsed == null //
<span class="fc bfc" id="L176" title="All 2 branches covered.">									|| Duration.between(lastUsed, Instant.now()).compareTo(validationInterval) &gt;= 0))</span>
<span class="fc" id="L177">						iuPooledConnection.validate(validationQuery);</span>

<span class="fc bfc" id="L179" title="All 2 branches covered.">					if (error != null)</span>
<span class="fc" id="L180">						LOG.log(Level.INFO, error, () -&gt; &quot;jdbc-pool-recoverable; &quot; + this);</span>

<span class="fc" id="L182">					return iuPooledConnection;</span>

				} finally {
<span class="fc" id="L185">					synchronized (this) {</span>
<span class="fc" id="L186">						pendingConnections--;</span>
<span class="fc" id="L187">						this.notifyAll();</span>
<span class="fc" id="L188">					}</span>
				}

<span class="fc" id="L191">			} catch (Throwable e) {</span>
<span class="fc bfc" id="L192" title="All 2 branches covered.">				if (iuPooledConnection != null) {</span>
<span class="fc" id="L193">					IuException.suppress(e, iuPooledConnection::close);</span>
<span class="fc" id="L194">					iuPooledConnection = null;</span>
				}

<span class="fc bfc" id="L197" title="All 2 branches covered.">				if (error == null)</span>
<span class="fc" id="L198">					error = e;</span>
				else
<span class="fc" id="L200">					error.addSuppressed(e);</span>
<span class="fc" id="L201">			}</span>

<span class="fc" id="L203">		throw new SQLException(&quot;jdbc-pool-fail: attempt=&quot; + attempt + &quot;, timeout=&quot; + timeout + &quot;; &quot; + this, error);</span>
	}

	@Override
	public void connectionClosed(ConnectionEvent event) {
<span class="fc" id="L208">		final var reusableConnection = (IuPooledConnection) event.getSource();</span>

<span class="fc" id="L210">		final var count = reusableConnection.getTransactionSegmentCount();</span>
<span class="fc bfc" id="L211" title="All 2 branches covered.">		if (count &gt;= maxConnectionReuseCount) {</span>
			try {
<span class="fc" id="L213">				reusableConnection.close();</span>
<span class="fc" id="L214">				LOG.fine(() -&gt; &quot;jdbc-pool-retire-count:&quot; + count + ' ' + reusableConnection + ' ' + this);</span>
<span class="fc" id="L215">			} catch (Throwable e) {</span>
<span class="fc" id="L216">				LOG.log(Level.INFO, e, () -&gt; &quot;jdbc-pool-retire-count:&quot; + count + ' ' + reusableConnection + ' ' + this);</span>
<span class="fc" id="L217">			}</span>
<span class="fc" id="L218">			return;</span>
		}

<span class="fc bfc" id="L221" title="All 2 branches covered.">		if (!closed) {</span>
<span class="fc" id="L222">			LOG.finer(() -&gt; &quot;jdbc-pool-reusable; &quot; + reusableConnection);</span>
<span class="fc" id="L223">			reusableConnections.offer(reusableConnection);</span>
<span class="fc" id="L224">			synchronized (this) {</span>
<span class="fc" id="L225">				this.notifyAll();</span>
<span class="fc" id="L226">			}</span>
		}
<span class="fc" id="L228">	}</span>

	@Override
	public void connectionErrorOccurred(ConnectionEvent event) {
<span class="fc" id="L232">		reusableConnections.remove((IuPooledConnection) event.getSource());</span>
<span class="fc" id="L233">	}</span>

	@Override
	public Logger getParentLogger() {
<span class="fc" id="L237">		return LogManager.getLogManager().getLogger(IuCommonDataSource.class.getPackageName());</span>
	}

	@Override
	public PrintWriter getLogWriter() throws SQLException {
<span class="fc" id="L242">		return null;</span>
	}

	@Override
	public void setLogWriter(PrintWriter out) throws SQLException {
<span class="fc" id="L247">		throw new SQLFeatureNotSupportedException();</span>
	}

	@Override
	public void setLoginTimeout(int seconds) throws SQLException {
<span class="fc bfc" id="L252" title="All 2 branches covered.">		if (seconds &lt; 0)</span>
<span class="fc" id="L253">			throw new IllegalArgumentException();</span>
<span class="fc bfc" id="L254" title="All 2 branches covered.">		else if (seconds == 0)</span>
<span class="fc" id="L255">			loginTimeout = 15;</span>
		else
<span class="fc" id="L257">			loginTimeout = seconds;</span>
<span class="fc" id="L258">	}</span>

	@Override
	public int getLoginTimeout() {
<span class="fc" id="L262">		return loginTimeout;</span>
	}

	/**
	 * Determines whether or not this database pool is closed.
	 * 
	 * @return true if closed; else false
	 */
	public boolean isClosed() {
<span class="fc" id="L271">		return closed;</span>
	}

	/**
	 * Gets the number of open connections immediately available for reuse.
	 * 
	 * @return number of open connections immediately available for reuse
	 */
	public int getAvailable() {
<span class="fc" id="L280">		return reusableConnections.size();</span>
	}

	/**
	 * Gets a count of all open connections in the pool.
	 * 
	 * @return count of all open connections
	 */
	public int getOpen() {
<span class="fc" id="L289">		return openConnections.size();</span>
	}

	/**
	 * Gets the URL used to initialize the downstream connection factory.
	 * 
	 * @return Full JDBC URL
	 */
	public String getUrl() {
<span class="fc" id="L298">		return url;</span>
	}

	/**
	 * Sets the URL used to initialize the downstream connection factory.
	 * 
	 * @param url Full JDBC URL
	 */
	public void setUrl(String url) {
<span class="fc" id="L307">		this.url = url;</span>
<span class="fc" id="L308">	}</span>

	/**
	 * Gets the database username used to initialize the downstream connection
	 * factory.
	 * 
	 * @return Database username
	 */
	public String getUsername() {
<span class="fc" id="L317">		return username;</span>
	}

	/**
	 * Sets the database username used to initialize the downstream connection
	 * factory.
	 * 
	 * @param username Database username
	 */
	public void setUsername(String username) {
<span class="fc" id="L327">		this.username = username;</span>
<span class="fc" id="L328">	}</span>

	/**
	 * Gets the database schema used to initialize the downstream connection
	 * factory.
	 * 
	 * @return Database schema
	 */
	public String getSchema() {
<span class="fc" id="L337">		return schema;</span>
	}

	/**
	 * Sets the database schema used to initialize the downstream connection
	 * factory.
	 * 
	 * @param schema Database schema
	 */
	public void setSchema(String schema) {
<span class="fc" id="L347">		this.schema = schema;</span>
<span class="fc" id="L348">	}</span>

	/**
	 * Gets the maximum number of connections to allow in the pool.
	 * 
	 * @return Pool max size
	 */
	public int getMaxSize() {
<span class="fc" id="L356">		return maxSize;</span>
	}

	/**
	 * Sets the maximum number of connections to allow in the pool.
	 * 
	 * @param maxSize Pool max size
	 */
	public void setMaxSize(int maxSize) {
<span class="fc" id="L365">		this.maxSize = maxSize;</span>
<span class="fc" id="L366">	}</span>

	/**
	 * Gets the maximum number of times a connection attempt will be retried before
	 * resulting in failure.
	 * 
	 * @return maximum number of times a connection attempt will be retried before
	 *         resulting in failure.
	 */
	public int getMaxRetry() {
<span class="fc" id="L376">		return maxRetry;</span>
	}

	/**
	 * Gets the maximum number of times a connection attempt will be retried before
	 * resulting in failure.
	 * 
	 * @param maxRetry maximum number of times a connection attempt will be retried
	 *                 before resulting in failure.
	 */
	public void setMaxRetry(int maxRetry) {
<span class="fc" id="L387">		this.maxRetry = maxRetry;</span>
<span class="fc" id="L388">	}</span>

	/**
	 * Gets the maximum number of times a single connection can be used before
	 * ejecting from the pool.
	 * 
	 * @return Per-connection max reuse count
	 */
	public long getMaxConnectionReuseCount() {
<span class="fc" id="L397">		return maxConnectionReuseCount;</span>
	}

	/**
	 * Sets the maximum number of times a single connection can be used before
	 * ejecting from the pool.
	 * 
	 * @param maxConnectionReuseCount Per-connection max reuse count
	 */
	public void setMaxConnectionReuseCount(long maxConnectionReuseCount) {
<span class="fc" id="L407">		this.maxConnectionReuseCount = maxConnectionReuseCount;</span>
<span class="fc" id="L408">	}</span>

	/**
	 * Gets the maximum length of time a single connection can remain open before
	 * ejecting from the pool.
	 * 
	 * @return Per-connection max reuse time
	 */
	public Duration getMaxConnectionReuseTime() {
<span class="fc" id="L417">		return maxConnectionReuseTime;</span>
	}

	/**
	 * Gets the maximum length of time a single connection can remain open before
	 * ejecting from the pool.
	 * 
	 * @param maxConnectionReuseTime Per-connection max reuse time
	 */
	public void setMaxConnectionReuseTime(Duration maxConnectionReuseTime) {
<span class="fc" id="L427">		this.maxConnectionReuseTime = maxConnectionReuseTime;</span>
<span class="fc" id="L428">	}</span>

	/**
	 * Gets the maximum length of time a connection can be checked out from the pool
	 * before attempting to forcibly close and consider it abandoned.
	 * 
	 * @return Abandoned connection timeout interval
	 */
	public Duration getAbandonedConnectionTimeout() {
<span class="fc" id="L437">		return abandonedConnectionTimeout;</span>
	}

	/**
	 * Sets the maximum length of time a connection can be checked out from the pool
	 * before attempting to forcibly close and consider it abandoned.
	 * 
	 * @param abandonedConnectionTimeout Abandoned connection timeout interval
	 */
	public void setAbandonedConnectionTimeout(Duration abandonedConnectionTimeout) {
<span class="fc" id="L447">		this.abandonedConnectionTimeout = abandonedConnectionTimeout;</span>
<span class="fc" id="L448">	}</span>

	/**
	 * Gets the maximum length of time to wait for all connections to close on
	 * shutdown.
	 * 
	 * @return Maximum length of time to wait for all connections to close
	 *         gracefully
	 */
	public Duration getShutdownTimeout() {
<span class="fc" id="L458">		return shutdownTimeout;</span>
	}

	/**
	 * Sets the maximum length of time to wait for all connections to close on
	 * shutdown.
	 * 
	 * @param shutdownTimeout Maximum length of time to wait for all connections to
	 *                        close gracefully
	 */
	protected void setShutdownTimeout(Duration shutdownTimeout) {
<span class="fc" id="L469">		this.shutdownTimeout = shutdownTimeout;</span>
<span class="fc" id="L470">	}</span>

	/**
	 * Gets the query to use for validating connections on creation, and
	 * intermittently before checking out from the pool.
	 * 
	 * @return SQL select statement, &lt;em&gt;must&lt;/em&gt; return a single row with a single
	 *         non-null column; may be null to skip query validation
	 */
	public String getValidationQuery() {
<span class="fc" id="L480">		return validationQuery;</span>
	}

	/**
	 * Sets the query to use for validating connections on creation, and
	 * intermittently before checking out from the pool.
	 * 
	 * @param validationQuery SQL select statement, &lt;em&gt;must&lt;/em&gt; return a single
	 *                        row with a single non-null column; may be null to skip
	 *                        query validation
	 */
	public void setValidationQuery(String validationQuery) {
<span class="fc" id="L492">		this.validationQuery = validationQuery;</span>
<span class="fc" id="L493">	}</span>

	/**
	 * Gets the frequency at which to validate connections, when
	 * {@link #getValidationQuery()} returns a non-null value.
	 *
	 * @return Frequency at which to validate connections; may be
	 */
	public Duration getValidationInterval() {
<span class="fc" id="L502">		return validationInterval;</span>
	}

	/**
	 * Sets the frequency at which to validate connections, when
	 * {@link #getValidationQuery()} returns a non-null value.
	 *
	 * @param validationInterval Frequency at which to validate connections; may be
	 */
	public void setValidationInterval(Duration validationInterval) {
<span class="fc" id="L512">		this.validationInterval = validationInterval;</span>
<span class="fc" id="L513">	}</span>

	/**
	 * Sets an optional transform function to be apply directly before checking out
	 * a connection from the pool.
	 * 
	 * @param connectionInitializer {@link UnsafeFunction}: accepts and returns a
	 *                              {@link Connection} such that
	 *                              {@link Connection#unwrap(Class)} invoked on the
	 *                              return value delegates to the {@link Connection}
	 *                              passed as an argument; &lt;em&gt;should not&lt;/em&gt; throw
	 *                              checked exceptions other than
	 *                              {@link SQLException}; &lt;em&gt;may&lt;/em&gt; throw
	 *                              {@link TimeoutException} or
	 *                              {@link InterruptedException}.
	 */
	public void setConnectionInitializer(UnsafeFunction&lt;Connection, Connection&gt; connectionInitializer) {
<span class="fc" id="L530">		this.connectionInitializer = connectionInitializer;</span>
<span class="fc" id="L531">	}</span>

	/**
	 * Sets an optional shutdown hook to be invoked from {@link #close()} after all
	 * physical connections managed by the pool have been closed.
	 * 
	 * @param onClose {@link UnsafeRunnable}
	 */
	public void setOnClose(UnsafeRunnable onClose) {
<span class="fc" id="L540">		this.onClose = onClose;</span>
<span class="fc" id="L541">	}</span>

	/**
	 * Waits for completion and closes all open connections.
	 */
	@Override
	public synchronized void close() throws SQLException {
<span class="fc bfc" id="L548" title="All 2 branches covered.">		if (!closed) {</span>
<span class="fc" id="L549">			closed = true;</span>

<span class="fc" id="L551">			class CloseStatus {</span>
<span class="fc" id="L552">				Throwable error = null;</span>
			}
<span class="fc" id="L554">			final var closeStatus = new CloseStatus();</span>

<span class="fc bfc" id="L556" title="All 2 branches covered.">			while (!reusableConnections.isEmpty())</span>
<span class="fc" id="L557">				closeStatus.error = IuException.suppress(closeStatus.error, () -&gt; reusableConnections.poll().close());</span>

<span class="fc" id="L559">			IuException.suppress(closeStatus.error, () -&gt; IuObject.waitFor(this, () -&gt; {</span>
<span class="fc bfc" id="L560" title="All 2 branches covered.">				for (final var c : openConnections)</span>
<span class="fc bfc" id="L561" title="All 2 branches covered.">					if (c.getLogicalConnectionOpened() == null)</span>
<span class="fc" id="L562">						closeStatus.error = IuException.suppress(closeStatus.error, () -&gt; c.close());</span>

<span class="fc" id="L564">				return openConnections.isEmpty();</span>
			}, shutdownTimeout));

<span class="fc bfc" id="L567" title="All 2 branches covered.">			if (onClose != null)</span>
<span class="fc" id="L568">				closeStatus.error = IuException.suppress(closeStatus.error, onClose);</span>

<span class="fc" id="L570">			closeStatus.error = IuException.suppress(closeStatus.error, () -&gt; {</span>
<span class="fc" id="L571">				final var size = openConnections.size();</span>
<span class="fc bfc" id="L572" title="All 2 branches covered.">				if (size &gt; 0)</span>
<span class="fc" id="L573">					throw new SQLException(</span>
							size + &quot; connections remaining in the pool after graceful shutdown &quot; + shutdownTimeout);
<span class="fc" id="L575">			});</span>

<span class="fc bfc" id="L577" title="All 2 branches covered.">			if (closeStatus.error != null)</span>
<span class="fc" id="L578">				throw IuException.checked(closeStatus.error, SQLException.class);</span>
		}
<span class="fc" id="L580">	}</span>

	@Override
	public String toString() {
		// Not using JSON-P to avoid complex dependency issues with legacy apps
<span class="fc" id="L585">		final var sb = new StringBuilder(&quot;{&quot;);</span>
<span class="fc" id="L586">		final BiConsumer&lt;String, Object&gt; addValue = (n, v) -&gt; {</span>
<span class="fc bfc" id="L587" title="All 2 branches covered.">			if (sb.length() &gt; 1)</span>
<span class="fc" id="L588">				sb.append(',');</span>
<span class="fc" id="L589">			sb.append('\&quot;').append(n).append(&quot;\&quot;:&quot;).append(v);</span>
<span class="fc" id="L590">		};</span>
<span class="fc" id="L591">		final BiConsumer&lt;String, Object&gt; addText = (n, t) -&gt; {</span>
<span class="fc bfc" id="L592" title="All 2 branches covered.">			if (t == null)</span>
<span class="fc" id="L593">				return;</span>
<span class="fc" id="L594">			addValue.accept(n, '\&quot;' + t.toString().replace(&quot;\\&quot;, &quot;\\\\&quot;).replace(&quot;\&quot;&quot;, &quot;\\\&quot;&quot;) + '\&quot;');</span>
<span class="fc" id="L595">		};</span>
<span class="fc" id="L596">		addText.accept(&quot;type&quot;, getClass().getSimpleName());</span>
<span class="fc" id="L597">		addText.accept(&quot;url&quot;, getUrl());</span>
<span class="fc" id="L598">		addText.accept(&quot;username&quot;, getUsername());</span>
<span class="fc" id="L599">		addText.accept(&quot;schema&quot;, getSchema());</span>
<span class="fc" id="L600">		addValue.accept(&quot;available&quot;, getAvailable());</span>
<span class="fc" id="L601">		addValue.accept(&quot;open&quot;, getOpen());</span>
<span class="fc" id="L602">		addValue.accept(&quot;maxSize&quot;, getMaxSize());</span>
<span class="fc" id="L603">		addValue.accept(&quot;maxRetry&quot;, getMaxRetry());</span>
<span class="fc" id="L604">		addValue.accept(&quot;closed&quot;, isClosed());</span>
<span class="fc" id="L605">		addValue.accept(&quot;maxConnectionReuseCount&quot;, getMaxConnectionReuseCount());</span>
<span class="fc" id="L606">		addText.accept(&quot;maxConnectionReuseTime&quot;, getMaxConnectionReuseTime());</span>
<span class="fc" id="L607">		addText.accept(&quot;abandonedConnectionTimeout&quot;, getAbandonedConnectionTimeout());</span>
<span class="fc" id="L608">		addText.accept(&quot;validationQuery&quot;, getValidationQuery());</span>
<span class="fc" id="L609">		addText.accept(&quot;validationInterval&quot;, getValidationInterval());</span>
<span class="fc" id="L610">		addText.accept(&quot;shutdownTimeout&quot;, getShutdownTimeout());</span>
<span class="fc" id="L611">		return sb.append('}').toString();</span>
	}

	private synchronized boolean isExhausted() {
<span class="fc bfc" id="L615" title="All 2 branches covered.">		return openConnections.size() + pendingConnections &gt;= maxSize;</span>
	}

	private IuPooledConnection openConnection(Instant timeout) throws SQLException {
<span class="fc bfc" id="L619" title="All 2 branches covered.">		if (closed)</span>
<span class="fc" id="L620">			throw new SQLException(&quot;closed&quot;);</span>

<span class="fc" id="L622">		final var initTime = Instant.now();</span>
<span class="fc" id="L623">		final var pooledConnection = IuException.checked(SQLException.class, () -&gt; {</span>
			try {
<span class="fc" id="L625">				return IuUtilityTaskController.getBefore(factory, timeout);</span>
<span class="fc" id="L626">			} catch (TimeoutException e) {</span>
<span class="fc" id="L627">				throw new SQLException(e);</span>
			}
		});

<span class="fc" id="L631">		final var newConnection = new IuPooledConnection(initTime, pooledConnection, connectionInitializer,</span>
				abandonedConnectionTimeout, this::handleClose);
<span class="fc" id="L633">		newConnection.addConnectionEventListener(this);</span>

<span class="fc" id="L635">		openConnections.offer(newConnection);</span>
<span class="fc" id="L636">		LOG.fine(() -&gt; &quot;jdbc-pool-open:&quot; + Duration.between(initTime, Instant.now()) + ' ' + pooledConnection + ' '</span>
				+ this);

<span class="fc" id="L639">		return newConnection;</span>
	}

	private void handleClose(IuPooledConnection closedConnection) {
<span class="fc" id="L643">		openConnections.remove(closedConnection);</span>
<span class="fc" id="L644">		synchronized (this) {</span>
<span class="fc" id="L645">			this.notifyAll();</span>
<span class="fc" id="L646">		}</span>

<span class="fc" id="L648">		final var error = closedConnection.error();</span>
<span class="fc bfc" id="L649" title="All 2 branches covered.">		if (error == null)</span>
<span class="fc" id="L650">			LOG.fine(() -&gt; &quot;jdbc-pool-close:&quot; + Duration.between(closedConnection.getConnectionInitiated(), Instant.now())</span>
					+ ' ' + closedConnection + ' ' + this);
		else
<span class="fc" id="L653">			LOG.log(Level.WARNING, error,</span>
<span class="fc" id="L654">					() -&gt; &quot;jdbc-pool-close:&quot; + Duration.between(closedConnection.getConnectionInitiated(), Instant.now())</span>
							+ ' ' + closedConnection + ' ' + this);
<span class="fc" id="L656">	}</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.10.202304240956</span></div></body></html>